<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>

<head>

<link rel="STYLESHEET" href="tut.css" type="text/css" />

<link rel="SHORTCUT ICON" href="../icons/pyfav.png" type="image/png" />

<link rel="start" href="../index.html" title="Chỉ mục tài liệu Python" />

<link rel="first" href="tut.html" title="Bài chỉ dẫn Python" />

<link rel="contents" href="node2.html" title="Mục lục" />

<link rel="index" href="node19.html" title="Chỉ mục" />

<link rel="last" href="about.html" title="Về tài liệu này..." />

<link rel="help" href="about.html" title="Về tài liệu này..." />

<link rel="next" href="node11.html" />

<link rel="prev" href="node9.html" />

<link rel="parent" href="tut.html" />

<link rel="next" href="node11.html" />

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="aesop" content="information" />

<title>8. Lỗi và biệt lệ </title>

</head>

<body>

<div class="navigation">

<div id="top-navigation-panel" xml:id="top-navigation-panel">

<table align="center" width="100%" cellpadding="0" cellspacing="2">

<tr>

<td class="online-navigation"><a rel="prev" title="7. Vào và ra" href="node9.html"><img src="../icons/previous.png" border="0" height="32" alt="Trang trước" width="32" /></a></td>

<td class="online-navigation"><a rel="parent" title="Bài chỉ dẫn Python" href="tut.html"><img src="../icons/up.png" border="0" height="32" alt="Lên một bậc" width="32" /></a></td>

<td class="online-navigation"><a rel="next" title="9. Lớp" href="node11.html"><img src="../icons/next.png" border="0" height="32" alt="Trang sau" width="32" /></a></td>

<td align="center" width="100%">Bài chỉ dẫn Python</td>

<td class="online-navigation"><a rel="contents" title="Bảng mục lục" href="node2.html"><img src="../icons/contents.png" border="0" height="32" alt="Mục lục" width="32" /></a></td>

<td class="online-navigation"><img src="../icons/blank.png" border="0" height="32" alt="" width="32" /></td>

<td class="online-navigation"><a rel="index" title="Chỉ mục" href="node19.html"><img src="../icons/index.png" border="0" height="32" alt="Chỉ mục" width="32" /></a></td>

</tr></table>

<div class="online-navigation">

<b class="navlabel">Trước:</b>

<a class="sectref" rel="prev" href="node9.html">7. Vào và ra</a>

<b class="navlabel">Lên:</b>

<a class="sectref" rel="parent" href="tut.html">Bài chỉ dẫn Python</a>

<b class="navlabel">Sau:</b>

<a class="sectref" rel="next" href="node11.html">9. Lớp</a>

</div>

<hr /></div>

</div>

<!--End of Navigation Panel-->

<div class="online-navigation">

<!--Table of Child-Links-->

<a name="CHILD_LINKS"><strong>Mục con</strong></a>

<ul class="ChildLinks">

<li><a href="node10.html#SECTION0010100000000000000000">8.1 Lỗi cú pháp</a>

</li><li><a href="node10.html#SECTION0010200000000000000000">8.2 Biệt lệ</a>

</li><li><a href="node10.html#SECTION0010300000000000000000">8.3 Xử lý biệt lệ</a>

</li><li><a href="node10.html#SECTION0010400000000000000000">8.4 Nâng biệt lệ</a>

</li><li><a href="node10.html#SECTION0010500000000000000000">8.5 Biệt lệ tự định nghĩa</a>

</li><li><a href="node10.html#SECTION0010600000000000000000">8.6 Định nghĩa cách xử lý</a>

</li><li><a href="node10.html#SECTION0010700000000000000000">8.7 Định nghĩa xử lý có sẵn</a>

</li></ul>

<!--End of Table of Child-Links-->

</div>

<hr />

<h1><a name="SECTION0010000000000000000000"></a><a name="errors"></a>

<br />
8. Lỗi và biệt lệ 
</h1>

<p>
Đến bây giờ chũng ta cũng chỉ mới nhắc đến các thông điệp lỗi, nhưng nếu bạn đã thử qua các ví dụ thì bạn có thể đã gặp nhiều hơn. Có (ít nhất) hai loại lỗi khác biệt:
<em>lỗi cú pháp</em> và <em>biệt lệ</em>.

</p><p>

<h1><a name="SECTION0010100000000000000000"></a><a name="syntaxErrors"></a>

<br />
8.1 Lỗi cú pháp 
</h1>

</p><p>
Lỗi cú pháp, còn biết đến như lỗi phân tích (parsing error), có lẽ là phàn nàn lớn nhất bạn gặp phải khi vẫn đang học Python:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; while True print 'Hello world'
  File "&lt;stdin&gt;", line 1, in ?
    while True print 'Hello world'
                   ^
SyntaxError: invalid syntax
</pre></div>

</p><p>
Bộ phân tích lặp lại dòng gây lỗi và hiển thị một mũi tên nhỏ trỏ vào điểm đầu tiên lỗi được phát hiện. Lỗi nằm ở dấu hiệu
<em>phía trước</em> mũi tên: trong ví dụ trên, lỗi được phát hiện ở từ khóa <tt class="keyword">print</tt>, vì thiếu một dấu hai chấm ("<tt class="character">:</tt>") ở trước đó. Tên tập tin vào số dòng được hiển thị để bạn biết tìm lỗi ở chỗ nào nếu đầu vào là từ một kịch bản.

</p><p>

<h1><a name="SECTION0010200000000000000000"></a><a name="exceptions"></a>

<br />
8.2 Biệt lệ 
</h1>

</p><p>
Cho dù một câu lệnh hoặc biểu thức là đúng đắn, nó vẫn có thể tạo lỗi khi thực thi. Những lỗi bị phát hiện trong lúc thực thi được gọi là <em>biệt lệ</em> và không tai hại một cách vô điều kiện: bạn sẽ học cách xử lý chúng trong các chương trình Python. Hầu hết các biệt lệ đều được xử lý bởi chương trình và dẫn đến kết quả là các thông điệp lỗi như ở đây:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; 10 * (1/0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ZeroDivisionError: integer division or modulo by zero
&gt;&gt;&gt; 4 + spam*3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: name 'spam' is not defined
&gt;&gt;&gt; '2' + 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: cannot concatenate 'str' and 'int' objects
</pre></div>

</p><p>
Dòng cuối cùng của thông điệp lỗi cho biết chuyện gì xảy ra. Biệt lệ có nhiều kiểu, và kiểu được hiển thị như là một phần của thông điệp: các kiểu trong ví dụ là
<tt class="exception">ZeroDivisionError</tt>, <tt class="exception">NameError</tt> và
<tt class="exception">TypeError</tt>. Chuỗi được hiển thị như là kiểu biệt lệ là tên của biệt lệ có sẵn vừa xảy ra. Điều này đúng với tất cả các biệt lệ có sẵn, nhưng không nhất thiết đúng với các biệt lệ do người dùng định nghĩa (mặc dù đó là một quy ước hữu dụng). Các tên biệt lệ chuẩn là những từ định danh có sẵn (không phải là từ khóa).

</p><p>
Phần còn lại cho biết chi tiết về kiểu biệt lệ và chuyện gì gây ra nó.

</p><p>
Phần trước của thông điệp lỗi cho biết hoàn cảnh khi xảy ra biệt lệ, ở dạng lần ngược ngăn xếp (stack traceback). Bình thường nó chứa một lần ngược ngăn xếp liệt kê các dòng nguồn; tuy nhiên, nó sẽ không hiển thị các dòng đọc từ đầu vào chuẩn.

</p><p>
  <em class="citetitle"><a href="../lib/module-exceptions.html" title="Tham khảo thư viện Python">Tham khảo thư viện Python</a></em> liệt kê các biệt lệ có sẵn và ý nghĩa của chúng.

</p><p>

<h1><a name="SECTION0010300000000000000000"></a><a name="handling"></a>

<br />
8.3 Xử lý biệt lệ 
</h1>

</p><p>
Chúng ta có thể viết những chương trình xử lý những biệt lệ được chọn. Hãy xem ví dụ sau, nó yêu cầu người dùng nhập vào dữ liệu cho tới khi một số nguyên được nhập, nhưng cũng cho phép người dùng ngưng chương trình (dùng <kbd>Control-C</kbd> hoặc phím tắt khác mà hệ điều hành hỗ trợ); lưu ý rằng sự ngắt quãng do người dùng tạo nên được đánh dấu bởi việc nâng biệt lệ <tt class="exception">KeyboardInterrupt</tt> .

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; while True:
...     try:
...         x = int(raw_input("Please enter a number: "))
...         break
...     except ValueError:
...         print "Oops!  That was no valid number.  Try again..."
...
</pre></div>

</p><p>
  <tt class="keyword">try</tt> (câu lệnh) hoạt động như sau.

</p><p>

<ul>

<li>Trước tiên, <em>vế try</em> (các câu lệnh giữa từ khóa
<tt class="keyword">try</tt> và <tt class="keyword">except</tt> ) được thực thi.

<p>

</p></li>

<li>Nếu không có biệt lệ nào xảy ra, vế <em>except</em> được bỏ qua và câu lệnh <tt class="keyword">try</tt> kết thúc.

<p>

</p></li>

<li>Nếu trong khi thực thi vế try xảy ra biệt lệ, phần còn lại của vế được bỏ qua. Sau đó nếu kiểu biệt lệ hợp với kiểu được chỉ định sau từ khóa <tt class="keyword">except</tt> , thì vế except được thực thi, và rồi việc thực thi tiếp tục sau câu lệnh <tt class="keyword">try</tt> .

<p>

</p></li>

<li>Nếu biệt lệ xảy ra không hợp với biệt lệ được chỉ định ở vế except, nó sẽ được truyền ra các câu lệnh <tt class="keyword">try</tt> bên ngoài; nếu không có đoạn mã xử lý nào, nó là một <em>biệt lệ không được xử lý</em> và việc thực thi dừng lại với một thông báo như trên.

<p>

</p></li>

</ul>

</p><p>
A <tt class="keyword">try</tt> (câu lệnh) có thể có nhiều hơn một vế except, để chỉ rõ cách xử lý cho những biệt lệ khác nhau. Nhiều nhất là một đoạn xử lý (handler) sẽ được thực thi. Các đoạn xử lý chỉ xử lý biệt lệ xảy ra trong vế try tương ứng, không xử lý các biệt lệ trong các đoạn xử lý khác của cùng câu lệnh
<tt class="keyword">try</tt> . Vế except có thể định danh nhiều biệt lệ trong một bộ (tuple), ví dụ:

</p><p>

<div class="verbatim"><pre>
... except (RuntimeError, TypeError, NameError):
...     pass
</pre></div>

</p><p>
Vế except cuối cùng có thể bỏ qua tên biệt lệ, có tác dụng như là một thay thế (wildcard). Phải hết sức cẩn trọng khi dùng nó, vì nó có thể dễ dàng che đi lỗi lập trình thật! Nó cũng có thể được dùng để in thông báo lỗi và sau đó nâng biệt lệ lại (re-raise exception) (nhằm cho phép nơi gọi xử lý biệt lệ):

</p><p>

<div class="verbatim"><pre>
import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except IOError, (errno, strerror):
    print "I/O error(%s): %s" % (errno, strerror)
except ValueError:
    print "Could not convert data to an integer."
except:
    print "Unexpected error:", sys.exc_info()[0]
    raise
</pre></div>

</p><p>
  <tt class="keyword">try</tt> ... <tt class="keyword">except</tt> (câu lệnh) có một
<em>vế else</em>không bắt buộc, mà khi có mặt sẽ phải đi sau tất cả các vế except. Nó dùng cho mã sẽ được thực thi nếu vế try không nâng biệt lệ nào. Ví dụ:

</p><p>

<div class="verbatim"><pre>
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print 'cannot open', arg
    else:
        print arg, 'has', len(f.readlines()), 'lines'
        f.close()
</pre></div>

</p><p>
Việc dùng vế <tt class="keyword">else</tt> tốt hơn là thêm mã vào vế <tt class="keyword">try</tt> vì nó tránh việc vô tình bắt một biệt lệ không được nâng từ mã được bảo vệ trong câu lệnh <tt class="keyword">try</tt> ... <tt class="keyword">except</tt> .

</p><p>
Khi một biệt lệ xảy ra, nó có thể có một giá trị gắn liền, còn được biết đến như là <em>thông số</em>của biệt lệ. Sự có mặt và kiểu của thông số phụ thuộc vào kiểu biệt lệ.

</p><p>
Vế except có thể chỉ định một biến sau một (hoặc một bộ) tên biệt lệ. Biến đó được gán với một trường hợp biệt lệ (exception instance) với các thông số chứa trong <code>instance.args</code>. Để thuận tiện, trường hợp biệt lệ định nghĩa <tt class="method">__getitem__</tt> và <tt class="method">__str__</tt> để cho các thông số có thể được truy xuất và in ra trực tiếp mà không phải tham chiếu <code>.args</code>.

</p><p>
Nhưng việc dùng <code>.args</code> đã không được khuyến khích. Thay vào đó, cách dùng tốt nhất là truyền một thông số đơn lẻ vào một biệt lệ (có thể là một bộ nếu có nhiều thông số) và gán nó vào thuộc tính <code>message</code> . Ta cũng có thể tạo một biệt lệ trước và thêm các thuộc tính vào nó trước khi nâng.

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; try:
...    raise Exception('spam', 'eggs')
... except Exception, inst:
...    print type(inst)     # the exception instance
...    print inst.args      # arguments stored in .args
...    print inst           # __str__ allows args to printed directly
...    x, y = inst          # __getitem__ allows args to be unpacked directly
...    print 'x =', x
...    print 'y =', y
...
&lt;type 'instance'&gt;
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
</pre></div>

</p><p>
Nếu biệt lệ có một thông số, nó sẽ được in ra như là phần cuối (`chi tiết') của thông điệp của những biệt lệ không được xử lý.

</p><p>
Các phần xử lý biệt lệ không chỉ xử lý các biệt lệ xảy ra ngay trong vế try, mà còn xử lý cả biệt trong những hàm được gọi (trực tiếp hoặc gián tiếp) trong vế try. Ví dụ:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; def this_fails():
...     x = 1/0
... 
&gt;&gt;&gt; try:
...     this_fails()
... except ZeroDivisionError, detail:
...     print 'Handling run-time error:', detail
... 
Handling run-time error: integer division or modulo by zero
</pre></div>

</p><p>

<h1><a name="SECTION0010400000000000000000"></a><a name="raising"></a>

<br />
8.4 Nâng biệt lệ 
</h1>

</p><p>
  <tt class="keyword">raise</tt> (câu lệnh) cho phép nhà lập trình ép xảy ra một biệt lệ được chỉ định. Ví dụ:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; raise NameError, 'HiThere'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: HiThere
</pre></div>

</p><p>
Thông số đầu tiên cho <tt class="keyword">raise</tt> chỉ định biệt lệ sẽ được nâng. Thông số (tùy chọn) thứ hai chỉ định thông số của biệt lệ. Hoặc là, các dòng trên có thể được viết
<code>raise NameError('HiThere')</code>. Cả hai dạng đều đúng, nhưng người ta có vẻ chuộng dạng thứ hai hơn.

</p><p>
Nếu bạn cần xác định xem một biệt lệ có được nâng chưa nhưng không định xử lý nó, dạng đơn giản hơn của câu lệnh <tt class="keyword">raise</tt> cho phép bạn nâng lại (re-raise) biệt lệ:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; try:
...     raise NameError, 'HiThere'
... except NameError:
...     print 'An exception flew by!'
...     raise
...
An exception flew by!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in ?
NameError: HiThere
</pre></div>

</p><p>

<h1><a name="SECTION0010500000000000000000"></a><a name="userExceptions"></a>

<br />
8.5 Biệt lệ tự định nghĩa 
</h1>

</p><p>
Các chương trình có thể đặt tên biệt lệ riêng bằng cách tạo một lớp biệt lệ mới. Các biệt lệ thường nên kế thừa từ lớp
<tt class="exception">Exception</tt> , trực tiếp hoặc gián tiếp. Ví dụ:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; class MyError(Exception):
...     def __init__(self, value):
...         self.value = value
...     def __str__(self):
...         return repr(self.value)
... 
&gt;&gt;&gt; try:
...     raise MyError(2*2)
... except MyError, e:
...     print 'My exception occurred, value:', e.value
... 
My exception occurred, value: 4
&gt;&gt;&gt; raise MyError, 'oops!'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
__main__.MyError: 'oops!'
</pre></div>

</p><p>
Trong ví dụ này, mặc định <tt class="method">__init__</tt> của <tt class="class">Exception</tt>
đã được định nghĩa lại. Cách thức mới chỉ đơn giản tạo thuộc tính <var>value</var>
. Nó thay thế cách thức mặc định tạo thuộc tính
<var>args</var> .

</p><p>
Các lớp biệt lệ có thể được định nghĩa để làm bất kỳ việc gì như các lớp khác, nhưng chúng thường là đơn giản và chỉ cung cấp một số thuộc tính để chứa thông tin về lỗi cho các phần xử lý biệt lệ. Khi tạo một mô-đun mà có thể nâng vài lỗi khác biệt, cách thông thường là tạo một lớp cơ sở cho các biệt lệ được định nghĩa bởi mô-đun đó, và kế thừa từ đó để tạo những lớp biệt lệ cụ thể cho những trường hợp lỗi khác nhau:

</p><p>

<div class="verbatim"><pre>
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
</pre></div>

</p><p>
Đa số biệt lệ được định nghĩa với tên tận cùng bằng ``Error'', tương tự như cách đặt tên của các biệt lệ chuẩn.

</p><p>
Nhiều mô-đun chuẩn định nghĩa biệt lệ riêng cho chúng để thông báo những lỗi mà có thể xảy ra trong các hàm chúng định nghĩa. Thông tin thêm về các lớp được trình bày trong chương <a href="node11.html#classes">9</a>, ``Lớp''.

</p><p>

<h1><a name="SECTION0010600000000000000000"></a><a name="cleanup"></a>

<br />
8.6 Định nghĩa cách xử lý 
</h1>

</p><p>
  <tt class="keyword">try</tt> (câu lệnh) có một vế không bắt buộc khác với mục đích định nghĩa những tác vụ dọn dẹp (clean-up action) mà sẽ được thực hiện trong mọi trường hợp. Ví dụ:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; try:
...     raise KeyboardInterrupt
... finally:
...     print 'Goodbye, world!'
... 
Goodbye, world!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in ?
KeyboardInterrupt
</pre></div>

</p><p>
A <em>vế finally</em> luôn được thực thi trước khi rời khỏi câu lệnh
<tt class="keyword">try</tt> , cho dù có xảy ra biệt lệ hay không. Khi một biệt lệ đã xảy ra trong vế <tt class="keyword">try</tt> và không được xử lý bởi vế <tt class="keyword">except</tt> (hoặc nó đã xảy ra trong một vế
<tt class="keyword">except</tt> hay <tt class="keyword">else</tt> ), nó sẽ được nâng lại sau khi vế
<tt class="keyword">finally</tt> đã được thực thi. Vế <tt class="keyword">finally</tt> cũng được thực thi ``trên đường ra'' khi bất kỳ vế nào của câu lệnh
<tt class="keyword">try</tt> được bỏ lại thông qua câu lệnh <tt class="keyword">break</tt>, <tt class="keyword">continue</tt>
hay <tt class="keyword">return</tt> . Một ví dụ phức tạp hơn:

</p><p>

<div class="verbatim"><pre>
&gt;&gt;&gt; def divide(x, y):
...     try:
...         result = x / y
...     except ZeroDivisionError:
...         print "division by zero!"
...     else:
...         print "result is", result
...     finally:
...         print "executing finally clause"
...
&gt;&gt;&gt; divide(2, 1)
result is 2
executing finally clause
&gt;&gt;&gt; divide(2, 0)
division by zero!
executing finally clause
&gt;&gt;&gt; divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "&lt;stdin&gt;", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'
</pre></div>

</p><p>
Như bạn có thể thấy, vế <tt class="keyword">finally</tt> được thực thi trong mọi trường hợp. <tt class="exception">TypeError</tt> được nâng vì chia hai chuỗi không được xử lý bởi vế <tt class="keyword">except</tt> và vì thế nên được nâng lại sau khi vế <tt class="keyword">finally</tt> đã được thực thi.

</p><p>
Trong các ứng dụng thực thế, vế <tt class="keyword">finally</tt> được dùng để trả lại những tài nguyên ngoài (như tập tin, hoặc kết nối mạng), cho dù việc sử dụng tài nguyên có thành công hay không.

</p><p>

<h1><a name="SECTION0010700000000000000000"></a><a name="cleanup-with"></a>

<br />
8.7 Định nghĩa xử lý có sẵn 
</h1>

</p><p>
Một số đối tượng định nghĩa các tác vụ dọn dẹp chuẩn để thực thi khi một đối tượng không còn được cần đến, cho dù việc xử dụng đối tượng là thành công hay thất bại. Xem qua ví dụ sau, nó thử mở một tập tin và viết nội dung của nó ra màn hình.

</p><p>

<div class="verbatim"><pre>
for line in open("myfile.txt"):
    print line
</pre></div>

</p><p>
Vấn đề với đoạn mã trên là nó để tập tin ngỏ trong một thời gian không xác định sau khi đoạn mã đã kết thúc. Đây không phải là vấn đề gì trong các đoạn kịch bản đơn giản, nhưng có thể là một vấn đề phức tạp đối với các ứng dụng lớn hơn. Câu lệnh <tt class="keyword">with</tt> cho phép các đối tượng như tập tin được dùng theo một cách đảm bảo chúng sẽ được dọn dẹp đúng lúc và đúng đắn.

</p><p>

<div class="verbatim"><pre>
with open("myfile.txt") as f:
    for line in f:
        print line
</pre></div>

</p><p>
Sau khi câu lệnh được thực thi, tập tin <var>f</var> luôn được đóng lại, cho dù gặp phải vấn đề trong khi xử lý các dòng. Các đối tượng khác mà cung cấp những tác vụ dọn dẹp định nghĩa sẵn sẽ cho biết về điểm này trong tài liệu của chúng.

</p><p>

<div class="navigation">

<div class="online-navigation">

<p></p><hr />

<table align="center" width="100%" cellpadding="0" cellspacing="2">

<tr>

<td class="online-navigation"><a rel="prev" title="7. Vào và ra" href="node9.html"><img src="../icons/previous.png" border="0" height="32" alt="Trang trước" width="32" /></a></td>

<td class="online-navigation"><a rel="parent" title="Bài chỉ dẫn Python" href="tut.html"><img src="../icons/up.png" border="0" height="32" alt="Lên một bậc" width="32" /></a></td>

<td class="online-navigation"><a rel="next" title="9. Lớp" href="node11.html"><img src="../icons/next.png" border="0" height="32" alt="Trang sau" width="32" /></a></td>

<td align="center" width="100%">Bài chỉ dẫn Python</td>

<td class="online-navigation"><a rel="contents" title="Bảng mục lục" href="node2.html"><img src="../icons/contents.png" border="0" height="32" alt="Mục lục" width="32" /></a></td>

<td class="online-navigation"><img src="../icons/blank.png" border="0" height="32" alt="" width="32" /></td>

<td class="online-navigation"><a rel="index" title="Chỉ mục" href="node19.html"><img src="../icons/index.png" border="0" height="32" alt="Chỉ mục" width="32" /></a></td>

</tr></table>

<div class="online-navigation">

<b class="navlabel">Trước:</b>

<a class="sectref" rel="prev" href="node9.html">7. Vào và ra</a>

<b class="navlabel">Lên:</b>

<a class="sectref" rel="parent" href="tut.html">Bài chỉ dẫn Python</a>

<b class="navlabel">Sau:</b>

<a class="sectref" rel="next" href="node11.html">9. Lớp</a>

</div>

</div>

<hr />

<span class="release-info">Phiên bản 2.5, tài liệu được cập nhật ngày 19, tháng 09, năm 2006.</span>

</div>

<!--End of Navigation Panel-->

<address>
Xem <i><a href="about.html">Về tài liệu này...</a></i> về cách đề nghị thay đổi.
</address>

</p></body>

</html>

